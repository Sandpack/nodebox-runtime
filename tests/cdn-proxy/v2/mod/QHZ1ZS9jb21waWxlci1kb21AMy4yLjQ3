ŒÙ&/dist/compiler-dom.esm-browser.prod.jsÅßfunction e(e,t){const n=Object.create(null),o=e.split(",");for(let r=0;r<o.length;r++)n[o[r]]=!0;return t?e=>!!n[e.toLowerCase()]:e=>!!n[e]}function t(e,t=0,n=e.length){let o=e.split(/(\r?\n)/);const r=o.filter(((e,t)=>t%2==1));o=o.filter(((e,t)=>t%2==0));let s=0;const i=[];for(let c=0;c<o.length;c++)if(s+=o[c].length+(r[c]&&r[c].length||0),s>=t){for(let e=c-2;e<=c+2||n>s;e++){if(e<0||e>=o.length)continue;const l=e+1;i.push(`${l}${" ".repeat(Math.max(3-String(l).length,0))}|  ${o[e]}`);const a=o[e].length,p=r[e]&&r[e].length||0;if(e===c){const e=t-(s-(a+p)),o=Math.max(1,n>s?a-e:n-t);i.push("   |  "+" ".repeat(e)+"^".repeat(o))}else if(e>c){if(n>s){const e=Math.max(Math.min(n-s,a),1);i.push("   |  "+"^".repeat(e))}s+=a+p}}break}return i.join("\n")}const n=/;(?![^(]*\))/g,o=/:([^]+)/,r=/\/\*.*?\*\//gs;const s=e("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"),i=e("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"),c=e("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"),l={},a=()=>{},p=()=>!1,u=/^on[^a-z]/,f=e=>u.test(e),d=Object.assign,h=Array.isArray,m=e=>"string"==typeof e,g=e=>"symbol"==typeof e,y=e=>null!==e&&"object"==typeof e,v=e(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),b=e("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),S=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},x=/-(\w)/g,k=S((e=>e.replace(x,((e,t)=>t?t.toUpperCase():"")))),N=/\B([A-Z])/g,_=S((e=>e.replace(N,"-$1").toLowerCase())),T=S((e=>e.charAt(0).toUpperCase()+e.slice(1))),E=S((e=>e?`on${T(e)}`:""));function w(e){throw e}function O(e){}function $(e,t,n,o){const r=new SyntaxError(String(e));return r.code=e,r.loc=t,r}const C=Symbol(""),M=Symbol(""),I=Symbol(""),P=Symbol(""),R=Symbol(""),V=Symbol(""),L=Symbol(""),A=Symbol(""),B=Symbol(""),j=Symbol(""),F=Symbol(""),D=Symbol(""),H=Symbol(""),W=Symbol(""),U=Symbol(""),J=Symbol(""),z=Symbol(""),G=Symbol(""),K=Symbol(""),q=Symbol(""),Z=Symbol(""),Y=Symbol(""),Q=Symbol(""),X=Symbol(""),ee=Symbol(""),te=Symbol(""),ne=Symbol(""),oe=Symbol(""),re=Symbol(""),se=Symbol(""),ie=Symbol(""),ce=Symbol(""),le=Symbol(""),ae=Symbol(""),pe=Symbol(""),ue=Symbol(""),fe=Symbol(""),de=Symbol(""),he=Symbol(""),me={[C]:"Fragment",[M]:"Teleport",[I]:"Suspense",[P]:"KeepAlive",[R]:"BaseTransition",[V]:"openBlock",[L]:"createBlock",[A]:"createElementBlock",[B]:"createVNode",[j]:"createElementVNode",[F]:"createCommentVNode",[D]:"createTextVNode",[H]:"createStaticVNode",[W]:"resolveComponent",[U]:"resolveDynamicComponent",[J]:"resolveDirective",[z]:"resolveFilter",[G]:"withDirectives",[K]:"renderList",[q]:"renderSlot",[Z]:"createSlots",[Y]:"toDisplayString",[Q]:"mergeProps",[X]:"normalizeClass",[ee]:"normalizeStyle",[te]:"normalizeProps",[ne]:"guardReactiveProps",[oe]:"toHandlers",[re]:"camelize",[se]:"capitalize",[ie]:"toHandlerKey",[ce]:"setBlockTracking",[le]:"pushScopeId",[ae]:"popScopeId",[pe]:"withCtx",[ue]:"unref",[fe]:"isRef",[de]:"withMemo",[he]:"isMemoSame"};function ge(e){Object.getOwnPropertySymbols(e).forEach((t=>{me[t]=e[t]}))}const ye={source:"",start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function ve(e,t=ye){return{type:0,children:e,helpers:new Set,components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc:t}}function be(e,t,n,o,r,s,i,c=!1,l=!1,a=!1,p=ye){return e&&(c?(e.helper(V),e.helper(it(e.inSSR,a))):e.helper(st(e.inSSR,a)),i&&e.helper(G)),{type:13,tag:t,props:n,children:o,patchFlag:r,dynamicProps:s,directives:i,isBlock:c,disableTracking:l,isComponent:a,loc:p}}function Se(e,t=ye){return{type:17,loc:t,elements:e}}function xe(e,t=ye){return{type:15,loc:t,properties:e}}function ke(e,t){return{type:16,loc:ye,key:m(e)?Ne(e,!0):e,value:t}}function Ne(e,t=!1,n=ye,o=0){return{type:4,loc:n,content:e,isStatic:t,constType:t?3:o}}function _e(e,t){return{type:5,loc:t,content:m(e)?Ne(e,!1,t):e}}function Te(e,t=ye){return{type:8,loc:t,children:e}}function Ee(e,t=[],n=ye){return{type:14,loc:n,callee:e,arguments:t}}function we(e,t,n=!1,o=!1,r=ye){return{type:18,params:e,returns:t,newline:n,isSlot:o,loc:r}}function Oe(e,t,n,o=!0){return{type:19,test:e,consequent:t,alternate:n,newline:o,loc:ye}}function $e(e,t,n=!1){return{type:20,index:e,value:t,isVNode:n,loc:ye}}function Ce(e){return{type:21,body:e,loc:ye}}function Me(e){return{type:22,elements:e,loc:ye}}function Ie(e,t,n){return{type:23,test:e,consequent:t,alternate:n,loc:ye}}function Pe(e,t){return{type:24,left:e,right:t,loc:ye}}function Re(e){return{type:25,expressions:e,loc:ye}}function Ve(e){return{type:26,returns:e,loc:ye}}const Le=e=>4===e.type&&e.isStatic,Ae=(e,t)=>e===t||e===_(t);function Be(e){return Ae(e,"Teleport")?M:Ae(e,"Suspense")?I:Ae(e,"KeepAlive")?P:Ae(e,"BaseTransition")?R:void 0}const je=/^\d|[^\$\w]/,Fe=e=>!je.test(e),De=/[A-Za-z_$\xA0-\uFFFF]/,He=/[\.\?\w$\xA0-\uFFFF]/,We=/\s+[.[]\s*|\s*[.[]\s+/g,Ue=e=>{e=e.trim().replace(We,(e=>e.trim()));let t=0,n=[],o=0,r=0,s=null;for(let i=0;i<e.length;i++){const c=e.charAt(i);switch(t){case 0:if("["===c)n.push(t),t=1,o++;else if("("===c)n.push(t),t=2,r++;else if(!(0===i?De:He).test(c))return!1;break;case 1:"'"===c||'"'===c||"`"===c?(n.push(t),t=3,s=c):"["===c?o++:"]"===c&&(--o||(t=n.pop()));break;case 2:if("'"===c||'"'===c||"`"===c)n.push(t),t=3,s=c;else if("("===c)r++;else if(")"===c){if(i===e.length-1)return!1;--r||(t=n.pop())}break;case 3:c===s&&(t=n.pop(),s=null)}}return!o&&!r},Je=a,ze=Ue;function Ge(e,t,n){const o={source:e.source.slice(t,t+n),start:Ke(e.start,e.source,t),end:e.end};return null!=n&&(o.end=Ke(e.start,e.source,t+n)),o}function Ke(e,t,n=t.length){return qe(d({},e),t,n)}function qe(e,t,n=t.length){let o=0,r=-1;for(let s=0;s<n;s++)10===t.charCodeAt(s)&&(o++,r=s);return e.offset+=n,e.line+=o,e.column=-1===r?e.column+n:n-r,e}function Ze(e,t){if(!e)throw new Error(t||"unexpected compiler condition")}function Ye(e,t,n=!1){for(let o=0;o<e.props.length;o++){const r=e.props[o];if(7===r.type&&(n||r.exp)&&(m(t)?r.name===t:t.test(r.name)))return r}}function Qe(e,t,n=!1,o=!1){for(let r=0;r<e.props.length;r++){const s=e.props[r];if(6===s.type){if(n)continue;if(s.name===t&&(s.value||o))return s}else if("bind"===s.name&&(s.exp||o)&&Xe(s.arg,t))return s}}function Xe(e,t){return!(!e||!Le(e)||e.content!==t)}function et(e){return e.props.some((e=>!(7!==e.type||"bind"!==e.name||e.arg&&4===e.arg.type&&e.arg.isStatic)))}function tt(e){return 5===e.type||2===e.type}function nt(e){return 7===e.type&&"slot"===e.name}function ot(e){return 1===e.type&&3===e.tagType}function rt(e){return 1===e.type&&2===e.tagType}function st(e,t){return e||t?B:j}function it(e,t){return e||t?L:A}const ct=new Set([te,ne]);function lt(e,t=[]){if(e&&!m(e)&&14===e.type){const n=e.callee;if(!m(n)&&ct.has(n))return lt(e.arguments[0],t.concat(e))}return[e,t]}function at(e,t,n){let o,r,s=13===e.type?e.props:e.arguments[2],i=[];if(s&&!m(s)&&14===s.type){const e=lt(s);s=e[0],i=e[1],r=i[i.length-1]}if(null==s||m(s))o=xe([t]);else if(14===s.type){const e=s.arguments[0];m(e)||15!==e.type?s.callee===oe?o=Ee(n.helper(Q),[xe([t]),s]):s.arguments.unshift(xe([t])):pt(t,e)||e.properties.unshift(t),!o&&(o=s)}else 15===s.type?(pt(t,s)||s.properties.unshift(t),o=s):(o=Ee(n.helper(Q),[xe([t]),s]),r&&r.callee===ne&&(r=i[i.length-2]));13===e.type?r?r.arguments[0]=o:e.props=o:r?r.arguments[0]=o:e.arguments[2]=o}function pt(e,t){let n=!1;if(4===e.key.type){const o=e.key.content;n=t.properties.some((e=>4===e.key.type&&e.key.content===o))}return n}function ut(e,t){return`_${t}_${e.replace(/[^\w]/g,((t,n)=>"-"===t?"_":e.charCodeAt(n).toString()))}`}function ft(e,t){if(!e||0===Object.keys(t).length)return!1;switch(e.type){case 1:for(let n=0;n<e.props.length;n++){const o=e.props[n];if(7===o.type&&(ft(o.arg,t)||ft(o.exp,t)))return!0}return e.children.some((e=>ft(e,t)));case 11:return!!ft(e.source,t)||e.children.some((e=>ft(e,t)));case 9:return e.branches.some((e=>ft(e,t)));case 10:return!!ft(e.condition,t)||e.children.some((e=>ft(e,t)));case 4:return!e.isStatic&&Fe(e.content)&&!!t[e.content];case 8:return e.children.some((e=>y(e)&&ft(e,t)));case 5:case 12:return ft(e.content,t);default:return!1}}function dt(e){return 14===e.type&&e.callee===de?e.arguments[1].returns:e}function ht(e,{helper:t,removeHelper:n,inSSR:o}){e.isBlock||(e.isBlock=!0,n(st(o,e.isComponent)),t(V),t(it(o,e.isComponent)))}const mt={COMPILER_IS_ON_ELEMENT:{message:'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',link:"https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"},COMPILER_V_BIND_SYNC:{message:e=>`.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e}.sync\` should be changed to \`v-model:${e}\`.`,link:"https://v3-migration.vuejs.org/breaking-changes/v-model.html"},COMPILER_V_BIND_PROP:{message:".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."},COMPILER_V_BIND_OBJECT_ORDER:{message:'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',link:"https://v3-migration.vuejs.org/breaking-changes/v-bind.html"},COMPILER_V_ON_NATIVE:{message:".native modifier for v-on has been removed as is no longer necessary.",link:"https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"},COMPILER_V_IF_V_FOR_PRECEDENCE:{message:"v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",link:"https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"},COMPILER_NATIVE_TEMPLATE:{message:"<template> with no special directives will render as a native template element instead of its inner content in Vue 3."},COMPILER_INLINE_TEMPLATE:{message:'"inline-template" has been removed in Vue 3.',link:"https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"},COMPILER_FILTER:{message:'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',link:"https://v3-migration.vuejs.org/breaking-changes/filters.html"}};function gt(e,t){const n=t.options?t.options.compatConfig:t.compatConfig,o=n&&n[e];return"MODE"===e?o||3:o}function yt(e,t){const n=gt("MODE",t),o=gt(e,t);return 3===n?!0===o:!1!==o}function vt(e,t,n,...o){return yt(e,t)}function bt(e,t,n,...o){if("suppress-warning"===gt(e,t))return;const{message:r,link:s}=mt[e],i=`(deprecation ${e}) ${"function"==typeof r?r(...o):r}${s?`\n  Details: ${s}`:""}`,c=new SyntaxError(i);c.code=e,n&&(c.loc=n),t.onWarn(c)}const St=/&(gt|lt|amp|apos|quot);/g,xt={gt:">",lt:"<",amp:"&",apos:"'",quot:'"'},kt={delimiters:["{{","}}"],getNamespace:()=>0,getTextMode:()=>0,isVoidTag:p,isPreTag:p,isCustomElement:p,decodeEntities:e=>e.replace(St,((e,t)=>xt[t])),onError:w,onWarn:O,comments:!1};function Nt(e,t={}){const n=function(e,t){const n=d({},kt);let o;for(o in t)n[o]=void 0===t[o]?kt[o]:t[o];return{options:n,column:1,line:1,offset:0,originalSource:e,source:e,inPre:!1,inVPre:!1,onWarn:n.onWarn}}(e,t),o=At(n);return ve(_t(n,0,[]),Bt(n,o))}function _t(e,t,n){const o=jt(n),r=o?o.ns:0,s=[];for(;!Ut(e,t,n);){const i=e.source;let c;if(0===t||1===t)if(!e.inVPre&&Ft(i,e.options.delimiters[0]))c=Rt(e,t);else if(0===t&&"<"===i[0])if(1===i.length);else if("!"===i[1])c=Ft(i,"\x3c!--")?wt(e):Ft(i,"<!DOCTYPE")?Ot(e):Ft(i,"<![CDATA[")&&0!==r?Et(e,n):Ot(e);else if("/"===i[1])if(2===i.length);else{if(">"===i[2]){Dt(e,3);continue}if(/[a-z]/i.test(i[2])){Mt(e,1,o);continue}c=Ot(e)}else/[a-z]/i.test(i[1])?(c=$t(e,n),yt("COMPILER_NATIVE_TEMPLATE",e)&&c&&"template"===c.tag&&!c.props.some((e=>7===e.type&&Ct(e.name)))&&(c=c.children)):"?"===i[1]&&(c=Ot(e));if(c||(c=Vt(e,t)),h(c))for(let e=0;e<c.length;e++)Tt(s,c[e]);else Tt(s,c)}let i=!1;if(2!==t&&1!==t){const t="preserve"!==e.options.whitespace;for(let n=0;n<s.length;n++){const o=s[n];if(2===o.type)if(e.inPre)o.content=o.content.replace(/\r\n/g,"\n");else if(/[^\t\r\n\f ]/.test(o.content))t&&(o.content=o.content.replace(/[\t\r\n\f ]+/g," "));else{const e=s[n-1],r=s[n+1];!e||!r||t&&(3===e.type&&3===r.type||3===e.type&&1===r.type||1===e.type&&3===r.type||1===e.type&&1===r.type&&/[\r\n]/.test(o.content))?(i=!0,s[n]=null):o.content=" "}else 3!==o.type||e.options.comments||(i=!0,s[n]=null)}if(e.inPre&&o&&e.options.isPreTag(o.tag)){const e=s[0];e&&2===e.type&&(e.content=e.content.replace(/^\r?\n/,""))}}return i?s.filter(Boolean):s}function Tt(e,t){if(2===t.type){const n=jt(e);if(n&&2===n.type&&n.loc.end.offset===t.loc.start.offset)return n.content+=t.content,n.loc.end=t.loc.end,void(n.loc.source+=t.loc.source)}e.push(t)}function Et(e,t){Dt(e,9);const n=_t(e,3,t);return 0===e.source.length||Dt(e,3),n}function wt(e){const t=At(e);let n;const o=/--(\!)?>/.exec(e.source);if(o){n=e.source.slice(4,o.index);const t=e.source.slice(0,o.index);let r=1,s=0;for(;-1!==(s=t.indexOf("\x3c!--",r));)Dt(e,s-r+1),r=s+1;Dt(e,o.index+o[0].length-r+1)}else n=e.source.slice(4),Dt(e,e.source.length);return{type:3,content:n,loc:Bt(e,t)}}function Ot(e){const t=At(e),n="?"===e.source[1]?1:2;let o;const r=e.source.indexOf(">");return-1===r?(o=e.source.slice(n),Dt(e,e.source.length)):(o=e.source.slice(n,r),Dt(e,r+1)),{type:3,content:o,loc:Bt(e,t)}}function $t(e,t){const n=e.inPre,o=e.inVPre,r=jt(t),s=Mt(e,0,r),i=e.inPre&&!n,c=e.inVPre&&!o;if(s.isSelfClosing||e.options.isVoidTag(s.tag))return i&&(e.inPre=!1),c&&(e.inVPre=!1),s;t.push(s);const l=e.options.getTextMode(s,r),a=_t(e,l,t);t.pop();{const t=s.props.find((e=>6===e.type&&"inline-template"===e.name));if(t&&vt("COMPILER_INLINE_TEMPLATE",e)){const n=Bt(e,s.loc.end);t.value={type:2,content:n.source,loc:n}}}if(s.children=a,Jt(e.source,s.tag))Mt(e,1,r);else if(0===e.source.length&&"script"===s.tag.toLowerCase()){const e=a[0];e&&Ft(e.loc.source,"\x3c!--")}return s.loc=Bt(e,s.loc.start),i&&(e.inPre=!1),c&&(e.inVPre=!1),s}const Ct=e("if,else,else-if,for,slot");function Mt(e,t,n){const o=At(e),r=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(e.source),s=r[1],i=e.options.getNamespace(s,n);Dt(e,r[0].length),Ht(e);const c=At(e),l=e.source;e.options.isPreTag(s)&&(e.inPre=!0);let a=It(e,t);0===t&&!e.inVPre&&a.some((e=>7===e.type&&"pre"===e.name))&&(e.inVPre=!0,d(e,c),e.source=l,a=It(e,t).filter((e=>"v-pre"!==e.name)));let p=!1;if(0===e.source.length||(p=Ft(e.source,"/>"),Dt(e,p?2:1)),1===t)return;let u=0;return e.inVPre||("slot"===s?u=2:"template"===s?a.some((e=>7===e.type&&Ct(e.name)))&&(u=3):function(e,t,n){const o=n.options;if(o.isCustomElement(e))return!1;if("component"===e||/^[A-Z]/.test(e)||Be(e)||o.isBuiltInComponent&&o.isBuiltInComponent(e)||o.isNativeTag&&!o.isNativeTag(e))return!0;for(let r=0;r<t.length;r++){const e=t[r];if(6===e.type){if("is"===e.name&&e.value){if(e.value.content.startsWith("vue:"))return!0;if(vt("COMPILER_IS_ON_ELEMENT",n))return!0}}else{if("is"===e.name)return!0;if("bind"===e.name&&Xe(e.arg,"is")&&vt("COMPILER_IS_ON_ELEMENT",n))return!0}}}(s,a,e)&&(u=1)),{type:1,ns:i,tag:s,tagType:u,props:a,isSelfClosing:p,children:[],loc:Bt(e,o),codegenNode:void 0}}function It(e,t){const n=[],o=new Set;for(;e.source.length>0&&!Ft(e.source,">")&&!Ft(e.source,"/>");){if(Ft(e.source,"/")){Dt(e,1),Ht(e);continue}const r=Pt(e,o);6===r.type&&r.value&&"class"===r.name&&(r.value.content=r.value.content.replace(/\s+/g," ").trim()),0===t&&n.push(r),/^[^\t\r\n\f />]/.test(e.source),Ht(e)}return n}function Pt(e,t){const n=At(e),o=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(e.source)[0];t.has(o),t.add(o);{const e=/["'<]/g;let t;for(;t=e.exec(o););}let r;Dt(e,o.length),/^[\t\r\n\f ]*=/.test(e.source)&&(Ht(e),Dt(e,1),Ht(e),r=function(e){const t=At(e);let n;const o=e.source[0],r='"'===o||"'"===o;if(r){Dt(e,1);const t=e.source.indexOf(o);-1===t?n=Lt(e,e.source.length,4):(n=Lt(e,t,4),Dt(e,1))}else{const t=/^[^\t\r\n\f >]+/.exec(e.source);if(!t)return;const o=/["'<=`]/g;let r;for(;r=o.exec(t[0]););n=Lt(e,t[0].length,4)}return{content:n,isQuoted:r,loc:Bt(e,t)}}(e));const s=Bt(e,n);if(!e.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(o)){const t=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(o);let i,c=Ft(o,"."),l=t[1]||(c||Ft(o,":")?"bind":Ft(o,"@")?"on":"slot");if(t[2]){const r="slot"===l,s=o.lastIndexOf(t[2]),c=Bt(e,Wt(e,n,s),Wt(e,n,s+t[2].length+(r&&t[3]||"").length));let a=t[2],p=!0;a.startsWith("[")?(p=!1,a=a.endsWith("]")?a.slice(1,a.length-1):a.slice(1)):r&&(a+=t[3]||""),i={type:4,content:a,isStatic:p,constType:p?3:0,loc:c}}if(r&&r.isQuoted){const e=r.loc;e.start.offset++,e.start.column++,e.end=Ke(e.start,r.content),e.source=e.source.slice(1,-1)}const a=t[3]?t[3].slice(1).split("."):[];return c&&a.push("prop"),"bind"===l&&i&&a.includes("sync")&&vt("COMPILER_V_BIND_SYNC",e,0)&&(l="model",a.splice(a.indexOf("sync"),1)),{type:7,name:l,exp:r&&{type:4,content:r.content,isStatic:!1,constType:0,loc:r.loc},arg:i,modifiers:a,loc:s}}return!e.inVPre&&Ft(o,"v-"),{type:6,name:o,value:r&&{type:2,content:r.content,loc:r.loc},loc:s}}function Rt(e,t){const[n,o]=e.options.delimiters,r=e.source.indexOf(o,n.length);if(-1===r)return;const s=At(e);Dt(e,n.length);const i=At(e),c=At(e),l=r-n.length,a=e.source.slice(0,l),p=Lt(e,l,t),u=p.trim(),f=p.indexOf(u);f>0&&qe(i,a,f);return qe(c,a,l-(p.length-u.length-f)),Dt(e,o.length),{type:5,content:{type:4,isStatic:!1,constType:0,content:u,loc:Bt(e,i,c)},loc:Bt(e,s)}}function Vt(e,t){const n=3===t?["]]>"]:["<",e.options.delimiters[0]];let o=e.source.length;for(let s=0;s<n.length;s++){const t=e.source.indexOf(n[s],1);-1!==t&&o>t&&(o=t)}const r=At(e);return{type:2,content:Lt(e,o,t),loc:Bt(e,r)}}function Lt(e,t,n){const o=e.source.slice(0,t);return Dt(e,t),2!==n&&3!==n&&o.includes("&")?e.options.decodeEntities(o,4===n):o}function At(e){const{column:t,line:n,offset:o}=e;return{column:t,line:n,offset:o}}function Bt(e,t,n){return{start:t,end:n=n||At(e),source:e.originalSource.slice(t.offset,n.offset)}}function jt(e){return e[e.length-1]}function Ft(e,t){return e.startsWith(t)}function Dt(e,t){const{source:n}=e;qe(e,n,t),e.source=n.slice(t)}function Ht(e){const t=/^[\t\r\n\f ]+/.exec(e.source);t&&Dt(e,t[0].length)}function Wt(e,t,n){return Ke(t,e.originalSource.slice(t.offset,n),n)}function Ut(e,t,n){const o=e.source;switch(t){case 0:if(Ft(o,"</"))for(let e=n.length-1;e>=0;--e)if(Jt(o,n[e].tag))return!0;break;case 1:case 2:{const e=jt(n);if(e&&Jt(o,e.tag))return!0;break}case 3:if(Ft(o,"]]>"))return!0}return!o}function Jt(e,t){return Ft(e,"</")&&e.slice(2,2+t.length).toLowerCase()===t.toLowerCase()&&/[\t\r\n\f />]/.test(e[2+t.length]||">")}function zt(e,t){Kt(e,t,Gt(e,e.children[0]))}function Gt(e,t){const{children:n}=e;return 1===n.length&&1===t.type&&!rt(t)}function Kt(e,t,n=!1){const{children:o}=e,r=o.length;let s=0;for(let i=0;i<o.length;i++){const e=o[i];if(1===e.type&&0===e.tagType){const o=n?0:qt(e,t);if(o>0){if(o>=2){e.codegenNode.patchFlag="-1",e.codegenNode=t.hoist(e.codegenNode),s++;continue}}else{const n=e.codegenNode;if(13===n.type){const o=en(n);if((!o||512===o||1===o)&&Qt(e,t)>=2){const o=Xt(e);o&&(n.props=t.hoist(o))}n.dynamicProps&&(n.dynamicProps=t.hoist(n.dynamicProps))}}}if(1===e.type){const n=1===e.tagType;n&&t.scopes.vSlot++,Kt(e,t),n&&t.scopes.vSlot--}else if(11===e.type)Kt(e,t,1===e.children.length);else if(9===e.type)for(let n=0;n<e.branches.length;n++)Kt(e.branches[n],t,1===e.branches[n].children.length)}s&&t.transformHoist&&t.transformHoist(o,t,e),s&&s===r&&1===e.type&&0===e.tagType&&e.codegenNode&&13===e.codegenNode.type&&h(e.codegenNode.children)&&(e.codegenNode.children=t.hoist(Se(e.codegenNode.children)))}function qt(e,t){const{constantCache:n}=t;switch(e.type){case 1:if(0!==e.tagType)return 0;const o=n.get(e);if(void 0!==o)return o;const r=e.codegenNode;if(13!==r.type)return 0;if(r.isBlock&&"svg"!==e.tag&&"foreignObject"!==e.tag)return 0;if(en(r))return n.set(e,0),0;{let o=3;const s=Qt(e,t);if(0===s)return n.set(e,0),0;s<o&&(o=s);for(let r=0;r<e.children.length;r++){const s=qt(e.children[r],t);if(0===s)return n.set(e,0),0;s<o&&(o=s)}if(o>1)for(let r=0;r<e.props.length;r++){const s=e.props[r];if(7===s.type&&"bind"===s.name&&s.exp){const r=qt(s.exp,t);if(0===r)return n.set(e,0),0;r<o&&(o=r)}}if(r.isBlock){for(let t=0;t<e.props.length;t++){if(7===e.props[t].type)return n.set(e,0),0}t.removeHelper(V),t.removeHelper(it(t.inSSR,r.isComponent)),r.isBlock=!1,t.helper(st(t.inSSR,r.isComponent))}return n.set(e,o),o}case 2:case 3:return 3;case 9:case 11:case 10:default:return 0;case 5:case 12:return qt(e.content,t);case 4:return e.constType;case 8:let s=3;for(let n=0;n<e.children.length;n++){const o=e.children[n];if(m(o)||g(o))continue;const r=qt(o,t);if(0===r)return 0;r<s&&(s=r)}return s}}const Zt=new Set([X,ee,te,ne]);function Yt(e,t){if(14===e.type&&!m(e.callee)&&Zt.has(e.callee)){const n=e.arguments[0];if(4===n.type)return qt(n,t);if(14===n.type)return Yt(n,t)}return 0}function Qt(e,t){let n=3;const o=Xt(e);if(o&&15===o.type){const{properties:e}=o;for(let o=0;o<e.length;o++){const{key:r,value:s}=e[o],i=qt(r,t);if(0===i)return i;let c;if(i<n&&(n=i),c=4===s.type?qt(s,t):14===s.type?Yt(s,t):0,0===c)return c;c<n&&(n=c)}}return n}function Xt(e){const t=e.codegenNode;if(13===t.type)return t.props}function en(e){const t=e.patchFlag;return t?parseInt(t,10):void 0}function tn(e,{filename:t="",prefixIdentifiers:n=!1,hoistStatic:o=!1,cacheHandlers:r=!1,nodeTransforms:s=[],directiveTransforms:i={},transformHoist:c=null,isBuiltInComponent:p=a,isCustomElement:u=a,expressionPlugins:f=[],scopeId:d=null,slotted:h=!0,ssr:g=!1,inSSR:y=!1,ssrCssVars:v="",bindingMetadata:b=l,inline:S=!1,isTS:x=!1,onError:N=w,onWarn:_=O,compatConfig:E}){const $=t.replace(/\?.*$/,"").match(/([^/\\]+)\.\w+$/),C={selfName:$&&T(k($[1])),prefixIdentifiers:n,hoistStatic:o,cacheHandlers:r,nodeTransforms:s,directiveTransforms:i,transformHoist:c,isBuiltInComponent:p,isCustomElement:u,expressionPlugins:f,scopeId:d,slotted:h,ssr:g,inSSR:y,ssrCssVars:v,bindingMetadata:b,inline:S,isTS:x,onError:N,onWarn:_,compatConfig:E,root:e,helpers:new Map,components:new Set,directives:new Set,hoists:[],imports:[],constantCache:new Map,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:e,childIndex:0,inVOnce:!1,helper(e){const t=C.helpers.get(e)||0;return C.helpers.set(e,t+1),e},removeHelper(e){const t=C.helpers.get(e);if(t){const n=t-1;n?C.helpers.set(e,n):C.helpers.delete(e)}},helperString:e=>`_${me[C.helper(e)]}`,replaceNode(e){C.parent.children[C.childIndex]=C.currentNode=e},removeNode(e){const t=e?C.parent.children.indexOf(e):C.currentNode?C.childIndex:-1;e&&e!==C.currentNode?C.childIndex>t&&(C.childIndex--,C.onNodeRemoved()):(C.currentNode=null,C.onNodeRemoved()),C.parent.children.splice(t,1)},onNodeRemoved:()=>{},addIdentifiers(e){},removeIdentifiers(e){},hoist(e){m(e)&&(e=Ne(e)),C.hoists.push(e);const t=Ne(`_hoisted_${C.hoists.length}`,!1,e.loc,2);return t.hoisted=e,t},cache:(e,t=!1)=>$e(C.cached++,e,t)};return C.filters=new Set,C}function nn(e,t){const n=tn(e,t);on(e,n),t.hoistStatic&&zt(e,n),t.ssr||function(e,t){const{helper:n}=t,{children:o}=e;if(1===o.length){const n=o[0];if(Gt(e,n)&&n.codegenNode){const o=n.codegenNode;13===o.type&&ht(o,t),e.codegenNode=o}else e.codegenNode=n}else if(o.length>1){let o=64;e.codegenNode=be(t,n(C),void 0,e.children,o+"",void 0,void 0,!0,void 0,!1)}}(e,n),e.helpers=new Set([...n.helpers.keys()]),e.components=[...n.components],e.directives=[...n.directives],e.imports=n.imports,e.hoists=n.hoists,e.temps=n.temps,e.cached=n.cached,e.filters=[...n.filters]}function on(e,t){t.currentNode=e;const{nodeTransforms:n}=t,o=[];for(let s=0;s<n.length;s++){const r=n[s](e,t);if(r&&(h(r)?o.push(...r):o.push(r)),!t.currentNode)return;e=t.currentNode}switch(e.type){case 3:t.ssr||t.helper(F);break;case 5:t.ssr||t.helper(Y);break;case 9:for(let n=0;n<e.branches.length;n++)on(e.branches[n],t);break;case 10:case 11:case 1:case 0:!function(e,t){let n=0;const o=()=>{n--};for(;n<e.children.length;n++){const r=e.children[n];m(r)||(t.parent=e,t.childIndex=n,t.onNodeRemoved=o,on(r,t))}}(e,t)}t.currentNode=e;let r=o.length;for(;r--;)o[r]()}function rn(e,t){const n=m(e)?t=>t===e:t=>e.test(t);return(e,o)=>{if(1===e.type){const{props:r}=e;if(3===e.tagType&&r.some(nt))return;const s=[];for(let i=0;i<r.length;i++){const c=r[i];if(7===c.type&&n(c.name)){r.splice(i,1),i--;const n=t(e,c,o);n&&s.push(n)}}return s}}}const sn=e=>`${me[e]}: _${me[e]}`;function cn(e,{mode:t="function",prefixIdentifiers:n="module"===t,sourceMap:o=!1,filename:r="template.vue.html",scopeId:s=null,optimizeImports:i=!1,runtimeGlobalName:c="Vue",runtimeModuleName:l="vue",ssrRuntimeModuleName:a="vue/server-renderer",ssr:p=!1,isTS:u=!1,inSSR:f=!1}){const d={mode:t,prefixIdentifiers:n,sourceMap:o,filename:r,scopeId:s,optimizeImports:i,runtimeGlobalName:c,runtimeModuleName:l,ssrRuntimeModuleName:a,ssr:p,isTS:u,inSSR:f,source:e.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:!1,map:void 0,helper:e=>`_${me[e]}`,push(e,t){d.code+=e},indent(){h(++d.indentLevel)},deindent(e=!1){e?--d.indentLevel:h(--d.indentLevel)},newline(){h(d.indentLevel)}};function h(e){d.push("\n"+"  ".repeat(e))}return d}function ln(e,t={}){const n=cn(e,t);t.onContextCreated&&t.onContextCreated(n);const{mode:o,push:r,prefixIdentifiers:s,indent:i,deindent:c,newline:l,ssr:a}=n,p=Array.from(e.helpers),u=p.length>0,f=!s&&"module"!==o,d=n;!function(e,t){const{push:n,newline:o,runtimeGlobalName:r}=t,s=r,i=Array.from(e.helpers);if(i.length>0&&(n(`const _Vue = ${s}\n`),e.hoists.length)){n(`const { ${[B,j,F,D,H].filter((e=>i.includes(e))).map(sn).join(", ")} } = _Vue\n`)}(function(e,t){if(!e.length)return;t.pure=!0;const{push:n,newline:o}=t;o();for(let r=0;r<e.length;r++){const s=e[r];s&&(n(`const _hoisted_${r+1} = `),fn(s,t),o())}t.pure=!1})(e.hoists,t),o(),n("return ")}(e,d);if(r(`function ${a?"ssrRender":"render"}(${(a?["_ctx","_push","_parent","_attrs"]:["_ctx","_cache"]).join(", ")}) {`),i(),f&&(r("with (_ctx) {"),i(),u&&(r(`const { ${p.map(sn).join(", ")} } = _Vue`),r("\n"),l())),e.components.length&&(an(e.components,"component",n),(e.directives.length||e.temps>0)&&l()),e.directives.length&&(an(e.directives,"directive",n),e.temps>0&&l()),e.filters&&e.filters.length&&(l(),an(e.filters,"filter",n),l()),e.temps>0){r("let ");for(let t=0;t<e.temps;t++)r(`${t>0?", ":""}_temp${t}`)}return(e.components.length||e.directives.length||e.temps)&&(r("\n"),l()),a||r("return "),e.codegenNode?fn(e.codegenNode,n):r("null"),f&&(c(),r("}")),c(),r("}"),{ast:e,code:n.code,preamble:"",map:n.map?n.map.toJSON():void 0}}function an(e,t,{helper:n,push:o,newline:r,isTS:s}){const i=n("filter"===t?z:"component"===t?W:J);for(let c=0;c<e.length;c++){let n=e[c];const l=n.endsWith("__self");l&&(n=n.slice(0,-6)),o(`const ${ut(n,t)} = ${i}(${JSON.stringify(n)}${l?", true":""})${s?"!":""}`),c<e.length-1&&r()}}function pn(e,t){const n=e.length>3||!1;t.push("["),n&&t.indent(),un(e,t,n),n&&t.deindent(),t.push("]")}function un(e,t,n=!1,o=!0){const{push:r,newline:s}=t;for(let i=0;i<e.length;i++){const c=e[i];m(c)?r(c):h(c)?pn(c,t):fn(c,t),i<e.length-1&&(n?(o&&r(","),s()):o&&r(", "))}}function fn(e,t){if(m(e))t.push(e);else if(g(e))t.push(t.helper(e));else switch(e.type){case 1:case 9:case 11:case 12:fn(e.codegenNode,t);break;case 2:!function(e,t){t.push(JSON.stringify(e.content),e)}(e,t);break;case 4:dn(e,t);break;case 5:!function(e,t){const{push:n,helper:o,pure:r}=t;r&&n("/*#__PURE__*/");n(`${o(Y)}(`),fn(e.content,t),n(")")}(e,t);break;case 8:hn(e,t);break;case 3:!function(e,t){const{push:n,helper:o,pure:r}=t;r&&n("/*#__PURE__*/");n(`${o(F)}(${JSON.stringify(e.content)})`,e)}(e,t);break;case 13:!function(e,t){const{push:n,helper:o,pure:r}=t,{tag:s,props:i,children:c,patchFlag:l,dynamicProps:a,directives:p,isBlock:u,disableTracking:f,isComponent:d}=e;p&&n(o(G)+"(");u&&n(`(${o(V)}(${f?"true":""}), `);r&&n("/*#__PURE__*/");const h=u?it(t.inSSR,d):st(t.inSSR,d);n(o(h)+"(",e),un(function(e){let t=e.length;for(;t--&&null==e[t];);return e.slice(0,t+1).map((e=>e||"null"))}([s,i,c,l,a]),t),n(")"),u&&n(")");p&&(n(", "),fn(p,t),n(")"))}(e,t);break;case 14:!function(e,t){const{push:n,helper:o,pure:r}=t,s=m(e.callee)?e.callee:o(e.callee);r&&n("/*#__PURE__*/");n(s+"(",e),un(e.arguments,t),n(")")}(e,t);break;case 15:!function(e,t){const{push:n,indent:o,deindent:r,newline:s}=t,{properties:i}=e;if(!i.length)return void n("{}",e);const c=i.length>1||!1;n(c?"{":"{ "),c&&o();for(let l=0;l<i.length;l++){const{key:e,value:o}=i[l];mn(e,t),n(": "),fn(o,t),l<i.length-1&&(n(","),s())}c&&r(),n(c?"}":" }")}(e,t);break;case 17:!function(e,t){pn(e.elements,t)}(e,t);break;case 18:!function(e,t){const{push:n,indent:o,deindent:r}=t,{params:s,returns:i,body:c,newline:l,isSlot:a}=e;a&&n(`_${me[pe]}(`);n("(",e),h(s)?un(s,t):s&&fn(s,t);n(") => "),(l||c)&&(n("{"),o());i?(l&&n("return "),h(i)?pn(i,t):fn(i,t)):c&&fn(c,t);(l||c)&&(r(),n("}"));a&&(e.isNonScopedSlot&&n(", undefined, true"),n(")"))}(e,t);break;case 19:!function(e,t){const{test:n,consequent:o,alternate:r,newline:s}=e,{push:i,indent:c,deindent:l,newline:a}=t;if(4===n.type){const e=!Fe(n.content);e&&i("("),dn(n,t),e&&i(")")}else i("("),fn(n,t),i(")");s&&c(),t.indentLevel++,s||i(" "),i("? "),fn(o,t),t.indentLevel--,s&&a(),s||i(" "),i(": ");const p=19===r.type;p||t.indentLevel++;fn(r,t),p||t.indentLevel--;s&&l(!0)}(e,t);break;case 20:!function(e,t){const{push:n,helper:o,indent:r,deindent:s,newline:i}=t;n(`_cache[${e.index}] || (`),e.isVNode&&(r(),n(`${o(ce)}(-1),`),i());n(`_cache[${e.index}] = `),fn(e.value,t),e.isVNode&&(n(","),i(),n(`${o(ce)}(1),`),i(),n(`_cache[${e.index}]`),s());n(")")}(e,t);break;case 21:un(e.body,t,!0,!1)}}function dn(e,t){const{content:n,isStatic:o}=e;t.push(o?JSON.stringify(n):n,e)}function hn(e,t){for(let n=0;n<e.children.length;n++){const o=e.children[n];m(o)?t.push(o):fn(o,t)}}function mn(e,t){const{push:n}=t;if(8===e.type)n("["),hn(e,t),n("]");else if(e.isStatic){n(Fe(e.content)?e.content:JSON.stringify(e.content),e)}else n(`[${e.content}]`,e)}function gn(e,t,n=!1,o=[],r=Object.create(null)){}function yn(e,t,n){return!1}function vn(e,t){if(e&&("ObjectProperty"===e.type||"ArrayPattern"===e.type)){let e=t.length;for(;e--;){const n=t[e];if("AssignmentExpression"===n.type)return!0;if("ObjectProperty"!==n.type&&!n.type.endsWith("Pattern"))break}}return!1}function bn(e,t){for(const n of e.params)for(const e of xn(n))t(e)}function Sn(e,t){for(const n of e.body)if("VariableDeclaration"===n.type){if(n.declare)continue;for(const e of n.declarations)for(const n of xn(e.id))t(n)}else if("FunctionDeclaration"===n.type||"ClassDeclaration"===n.type){if(n.declare||!n.id)continue;t(n.id)}}function xn(e,t=[]){switch(e.type){case"Identifier":t.push(e);break;case"MemberExpression":let n=e;for(;"MemberExpression"===n.type;)n=n.object;t.push(n);break;case"ObjectPattern":for(const o of e.properties)xn("RestElement"===o.type?o.argument:o.value,t);break;case"ArrayPattern":e.elements.forEach((e=>{e&&xn(e,t)}));break;case"RestElement":xn(e.argument,t);break;case"AssignmentPattern":xn(e.left,t)}return t}const kn=e=>/Function(?:Expression|Declaration)$|Method$/.test(e.type),Nn=e=>e&&("ObjectProperty"===e.type||"ObjectMethod"===e.type)&&!e.computed,_n=(e,t)=>Nn(t)&&t.key===e,Tn=(e,t)=>{if(5===e.type)e.content=En(e.content,t);else if(1===e.type)for(let n=0;n<e.props.length;n++){const o=e.props[n];if(7===o.type&&"for"!==o.name){const e=o.exp,n=o.arg;!e||4!==e.type||"on"===o.name&&n||(o.exp=En(e,t,"slot"===o.name)),n&&4===n.type&&!n.isStatic&&(o.arg=En(n,t))}}};function En(e,t,n=!1,o=!1,r=Object.create(t.identifiers)){return e}function wn(e){return m(e)?e:4===e.type?e.content:e.children.map(wn).join("")}const On=rn(/^(if|else|else-if)$/,((e,t,n)=>$n(e,t,n,((e,t,o)=>{const r=n.parent.children;let s=r.indexOf(e),i=0;for(;s-- >=0;){const e=r[s];e&&9===e.type&&(i+=e.branches.length)}return()=>{if(o)e.codegenNode=Mn(t,i,n);else{const o=function(e){for(;;)if(19===e.type){if(19!==e.alternate.type)return e;e=e.alternate}else 20===e.type&&(e=e.value)}(e.codegenNode);o.alternate=Mn(t,i+e.branches.length-1,n)}}}))));function $n(e,t,n,o){if(!("else"===t.name||t.exp&&t.exp.content.trim())){t.exp=Ne("true",!1,t.exp?t.exp.loc:e.loc)}if("if"===t.name){const r=Cn(e,t),s={type:9,loc:e.loc,branches:[r]};if(n.replaceNode(s),o)return o(s,r,!0)}else{const r=n.parent.children;let s=r.indexOf(e);for(;s-- >=-1;){const i=r[s];if(i&&3===i.type)n.removeNode(i);else{if(!i||2!==i.type||i.content.trim().length){if(i&&9===i.type){n.removeNode();const r=Cn(e,t);i.branches.push(r);const s=o&&o(i,r,!1);on(r,n),s&&s(),n.currentNode=null}break}n.removeNode(i)}}}}function Cn(e,t){const n=3===e.tagType;return{type:10,loc:e.loc,condition:"else"===t.name?void 0:t.exp,children:n&&!Ye(e,"for")?e.children:[e],userKey:Qe(e,"key"),isTemplateIf:n}}function Mn(e,t,n){return e.condition?Oe(e.condition,In(e,t,n),Ee(n.helper(F),['""',"true"])):In(e,t,n)}function In(e,t,n){const{helper:o}=n,r=ke("key",Ne(`${t}`,!1,ye,2)),{children:s}=e,i=s[0];if(1!==s.length||1!==i.type){if(1===s.length&&11===i.type){const e=i.codegenNode;return at(e,r,n),e}{let t=64;return be(n,o(C),xe([r]),s,t+"",void 0,void 0,!0,!1,!1,e.loc)}}{const e=i.codegenNode,t=dt(e);return 13===t.type&&ht(t,n),at(t,r,n),e}}const Pn=rn("for",((e,t,n)=>{const{helper:o,removeHelper:r}=n;return Rn(e,t,n,(t=>{const s=Ee(o(K),[t.source]),i=ot(e),c=Ye(e,"memo"),l=Qe(e,"key"),a=l&&(6===l.type?Ne(l.value.content,!0):l.exp),p=l?ke("key",a):null,u=4===t.source.type&&t.source.constType>0,f=u?64:l?128:256;return t.codegenNode=be(n,o(C),void 0,s,f+"",void 0,void 0,!0,!u,!1,e.loc),()=>{let l;const{children:f}=t,d=1!==f.length||1!==f[0].type,h=rt(e)?e:i&&1===e.children.length&&rt(e.children[0])?e.children[0]:null;if(h?(l=h.codegenNode,i&&p&&at(l,p,n)):d?l=be(n,o(C),p?xe([p]):void 0,e.children,"64",void 0,void 0,!0,void 0,!1):(l=f[0].codegenNode,i&&p&&at(l,p,n),l.isBlock!==!u&&(l.isBlock?(r(V),r(it(n.inSSR,l.isComponent))):r(st(n.inSSR,l.isComponent))),l.isBlock=!u,l.isBlock?(o(V),o(it(n.inSSR,l.isComponent))):o(st(n.inSSR,l.isComponent))),c){const e=we(Fn(t.parseResult,[Ne("_cached")]));e.body=Ce([Te(["const _memo = (",c.exp,")"]),Te(["if (_cached",...a?[" && _cached.key === ",a]:[],` && ${n.helperString(he)}(_cached, _memo)) return _cached`]),Te(["const _item = ",l]),Ne("_item.memo = _memo"),Ne("return _item")]),s.arguments.push(e,Ne("_cache"),Ne(String(n.cached++)))}else s.arguments.push(we(Fn(t.parseResult),l,!0))}}))}));function Rn(e,t,n,o){if(!t.exp)return;const r=Bn(t.exp);if(!r)return;const{scopes:s}=n,{source:i,value:c,key:l,index:a}=r,p={type:11,loc:t.loc,source:i,valueAlias:c,keyAlias:l,objectIndexAlias:a,parseResult:r,children:ot(e)?e.children:[e]};n.replaceNode(p),s.vFor++;const u=o&&o(p);return()=>{s.vFor--,u&&u()}}const Vn=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Ln=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,An=/^\(|\)$/g;function Bn(e,t){const n=e.loc,o=e.content,r=o.match(Vn);if(!r)return;const[,s,i]=r,c={source:jn(n,i.trim(),o.indexOf(i,s.length)),value:void 0,key:void 0,index:void 0};let l=s.trim().replace(An,"").trim();const a=s.indexOf(l),p=l.match(Ln);if(p){l=l.replace(Ln,"").trim();const e=p[1].trim();let t;if(e&&(t=o.indexOf(e,a+l.length),c.key=jn(n,e,t)),p[2]){const r=p[2].trim();r&&(c.index=jn(n,r,o.indexOf(r,c.key?t+e.length:a+l.length)))}}return l&&(c.value=jn(n,l,a)),c}function jn(e,t,n){return Ne(t,!1,Ge(e,n,t.length))}function Fn({value:e,key:t,index:n},o=[]){return function(e){let t=e.length;for(;t--&&!e[t];);return e.slice(0,t+1).map(((e,t)=>e||Ne("_".repeat(t+1),!1)))}([e,t,n,...o])}const Dn=Ne("undefined",!1),Hn=(e,t)=>{if(1===e.type&&(1===e.tagType||3===e.tagType)){const n=Ye(e,"slot");if(n)return t.scopes.vSlot++,()=>{t.scopes.vSlot--}}},Wn=(e,t)=>{let n;if(ot(e)&&e.props.some(nt)&&(n=Ye(e,"for"))){const e=n.parseResult=Bn(n.exp);if(e){const{value:n,key:o,index:r}=e,{addIdentifiers:s,removeIdentifiers:i}=t;return n&&s(n),o&&s(o),r&&s(r),()=>{n&&i(n),o&&i(o),r&&i(r)}}}},Un=(e,t,n)=>we(e,t,!1,!0,t.length?t[0].loc:n);function Jn(e,t,n=Un){t.helper(pe);const{children:o,loc:r}=e,s=[],i=[];let c=t.scopes.vSlot>0||t.scopes.vFor>0;const l=Ye(e,"slot",!0);if(l){const{arg:e,exp:t}=l;e&&!Le(e)&&(c=!0),s.push(ke(e||Ne("default",!0),n(t,o,r)))}let a=!1,p=!1;const u=[],f=new Set;let d=0;for(let g=0;g<o.length;g++){const e=o[g];let r;if(!ot(e)||!(r=Ye(e,"slot",!0))){3!==e.type&&u.push(e);continue}if(l)break;a=!0;const{children:h,loc:m}=e,{arg:y=Ne("default",!0),exp:v}=r;let b;Le(y)?b=y?y.content:"default":c=!0;const S=n(v,h,m);let x,k,N;if(x=Ye(e,"if"))c=!0,i.push(Oe(x.exp,zn(y,S,d++),Dn));else if(k=Ye(e,/^else(-if)?$/,!0)){let e,t=g;for(;t--&&(e=o[t],3===e.type););if(e&&ot(e)&&Ye(e,"if")){o.splice(g,1),g--;let e=i[i.length-1];for(;19===e.alternate.type;)e=e.alternate;e.alternate=k.exp?Oe(k.exp,zn(y,S,d++),Dn):zn(y,S,d++)}}else if(N=Ye(e,"for")){c=!0;const e=N.parseResult||Bn(N.exp);e&&i.push(Ee(t.helper(K),[e.source,we(Fn(e),zn(y,S),!0)]))}else{if(b){if(f.has(b))continue;f.add(b),"default"===b&&(p=!0)}s.push(ke(y,S))}}if(!l){const e=(e,o)=>{const s=n(e,o,r);return t.compatConfig&&(s.isNonScopedSlot=!0),ke("default",s)};a?u.length&&u.some((e=>Kn(e)))&&(p||s.push(e(void 0,u))):s.push(e(void 0,o))}const h=c?2:Gn(e.children)?3:1;let m=xe(s.concat(ke("_",Ne(h+"",!1))),r);return i.length&&(m=Ee(t.helper(Z),[m,Se(i)])),{slots:m,hasDynamicSlots:c}}function zn(e,t,n){const o=[ke("name",e),ke("fn",t)];return null!=n&&o.push(ke("key",Ne(String(n),!0))),xe(o)}function Gn(e){for(let t=0;t<e.length;t++){const n=e[t];switch(n.type){case 1:if(2===n.tagType||Gn(n.children))return!0;break;case 9:if(Gn(n.branches))return!0;break;case 10:case 11:if(Gn(n.children))return!0}}return!1}function Kn(e){return 2!==e.type&&12!==e.type||(2===e.type?!!e.content.trim():Kn(e.content))}const qn=new WeakMap,Zn=(e,t)=>function(){if(1!==(e=t.currentNode).type||0!==e.tagType&&1!==e.tagType)return;const{tag:n,props:o}=e,r=1===e.tagType;let s=r?Yn(e,t):`"${n}"`;const i=y(s)&&s.callee===U;let c,l,a,p,u,f,d=0,h=i||s===M||s===I||!r&&("svg"===n||"foreignObject"===n);if(o.length>0){const n=Qn(e,t,void 0,r,i);c=n.props,d=n.patchFlag,u=n.dynamicPropNames;const o=n.directives;f=o&&o.length?Se(o.map((e=>to(e,t)))):void 0,n.shouldUseBlock&&(h=!0)}if(e.children.length>0){s===P&&(h=!0,d|=1024);if(r&&s!==M&&s!==P){const{slots:n,hasDynamicSlots:o}=Jn(e,t);l=n,o&&(d|=1024)}else if(1===e.children.length&&s!==M){const n=e.children[0],o=n.type,r=5===o||8===o;r&&0===qt(n,t)&&(d|=1),l=r||2===o?n:e.children}else l=e.children}0!==d&&(a=String(d),u&&u.length&&(p=function(e){let t="[";for(let n=0,o=e.length;n<o;n++)t+=JSON.stringify(e[n]),n<o-1&&(t+=", ");return t+"]"}(u))),e.codegenNode=be(t,s,c,l,a,p,f,!!h,!1,r,e.loc)};function Yn(e,t,n=!1){let{tag:o}=e;const r=no(o),s=Qe(e,"is");if(s)if(r||yt("COMPILER_IS_ON_ELEMENT",t)){const e=6===s.type?s.value&&Ne(s.value.content,!0):s.exp;if(e)return Ee(t.helper(U),[e])}else 6===s.type&&s.value.content.startsWith("vue:")&&(o=s.value.content.slice(4));const i=!r&&Ye(e,"is");if(i&&i.exp)return Ee(t.helper(U),[i.exp]);const c=Be(o)||t.isBuiltInComponent(o);return c?(n||t.helper(c),c):(t.helper(W),t.components.add(o),ut(o,"component"))}function Qn(e,t,n=e.props,o,r,s=!1){const{tag:i,loc:c,children:l}=e;let a=[];const p=[],u=[],d=l.length>0;let h=!1,m=0,y=!1,S=!1,x=!1,k=!1,N=!1,_=!1;const T=[],E=e=>{a.length&&(p.push(xe(Xn(a),c)),a=[]),e&&p.push(e)},w=({key:e,value:n})=>{if(Le(e)){const s=e.content,i=f(s);if(!i||o&&!r||"onclick"===s.toLowerCase()||"onUpdate:modelValue"===s||v(s)||(k=!0),i&&v(s)&&(_=!0),20===n.type||(4===n.type||8===n.type)&&qt(n,t)>0)return;"ref"===s?y=!0:"class"===s?S=!0:"style"===s?x=!0:"key"===s||T.includes(s)||T.push(s),!o||"class"!==s&&"style"!==s||T.includes(s)||T.push(s)}else N=!0};for(let f=0;f<n.length;f++){const r=n[f];if(6===r.type){const{loc:e,name:n,value:o}=r;let s=!0;if("ref"===n&&(y=!0,t.scopes.vFor>0&&a.push(ke(Ne("ref_for",!0),Ne("true")))),"is"===n&&(no(i)||o&&o.content.startsWith("vue:")||yt("COMPILER_IS_ON_ELEMENT",t)))continue;a.push(ke(Ne(n,!0,Ge(e,0,n.length)),Ne(o?o.content:"",s,o?o.loc:e)))}else{const{name:n,arg:l,exp:f,loc:m}=r,y="bind"===n,v="on"===n;if("slot"===n)continue;if("once"===n||"memo"===n)continue;if("is"===n||y&&Xe(l,"is")&&(no(i)||yt("COMPILER_IS_ON_ELEMENT",t)))continue;if(v&&s)continue;if((y&&Xe(l,"key")||v&&d&&Xe(l,"vue:before-update"))&&(h=!0),y&&Xe(l,"ref")&&t.scopes.vFor>0&&a.push(ke(Ne("ref_for",!0),Ne("true"))),!l&&(y||v)){if(N=!0,f)if(y){if(E(),yt("COMPILER_V_BIND_OBJECT_ORDER",t)){p.unshift(f);continue}p.push(f)}else E({type:14,loc:m,callee:t.helper(oe),arguments:o?[f]:[f,"true"]});continue}const S=t.directiveTransforms[n];if(S){const{props:n,needRuntime:o}=S(r,e,t);!s&&n.forEach(w),v&&l&&!Le(l)?E(xe(n,c)):a.push(...n),o&&(u.push(r),g(o)&&qn.set(r,o))}else b(n)||(u.push(r),d&&(h=!0))}}let O;if(p.length?(E(),O=p.length>1?Ee(t.helper(Q),p,c):p[0]):a.length&&(O=xe(Xn(a),c)),N?m|=16:(S&&!o&&(m|=2),x&&!o&&(m|=4),T.length&&(m|=8),k&&(m|=32)),h||0!==m&&32!==m||!(y||_||u.length>0)||(m|=512),!t.inSSR&&O)switch(O.type){case 15:let e=-1,n=-1,o=!1;for(let t=0;t<O.properties.length;t++){const r=O.properties[t].key;Le(r)?"class"===r.content?e=t:"style"===r.content&&(n=t):r.isHandlerKey||(o=!0)}const r=O.properties[e],s=O.properties[n];o?O=Ee(t.helper(te),[O]):(r&&!Le(r.value)&&(r.value=Ee(t.helper(X),[r.value])),s&&(x||4===s.value.type&&"["===s.value.content.trim()[0]||17===s.value.type)&&(s.value=Ee(t.helper(ee),[s.value])));break;case 14:break;default:O=Ee(t.helper(te),[Ee(t.helper(ne),[O])])}return{props:O,directives:u,patchFlag:m,dynamicPropNames:T,shouldUseBlock:h}}function Xn(e){const t=new Map,n=[];for(let o=0;o<e.length;o++){const r=e[o];if(8===r.key.type||!r.key.isStatic){n.push(r);continue}const s=r.key.content,i=t.get(s);i?("style"===s||"class"===s||f(s))&&eo(i,r):(t.set(s,r),n.push(r))}return n}function eo(e,t){17===e.value.type?e.value.elements.push(t.value):e.value=Se([e.value,t.value],e.loc)}function to(e,t){const n=[],o=qn.get(e);o?n.push(t.helperString(o)):(t.helper(J),t.directives.add(e.name),n.push(ut(e.name,"directive")));const{loc:r}=e;if(e.exp&&n.push(e.exp),e.arg&&(e.exp||n.push("void 0"),n.push(e.arg)),Object.keys(e.modifiers).length){e.arg||(e.exp||n.push("void 0"),n.push("void 0"));const t=Ne("true",!1,r);n.push(xe(e.modifiers.map((e=>ke(e,t))),r))}return Se(n,e.loc)}function no(e){return"component"===e||"Component"===e}const oo=(e,t)=>{if(rt(e)){const{children:n,loc:o}=e,{slotName:r,slotProps:s}=ro(e,t),i=[t.prefixIdentifiers?"_ctx.$slots":"$slots",r,"{}","undefined","true"];let c=2;s&&(i[2]=s,c=3),n.length&&(i[3]=we([],n,!1,!1,o),c=4),t.scopeId&&!t.slotted&&(c=5),i.splice(c),e.codegenNode=Ee(t.helper(q),i,o)}};function ro(e,t){let n,o='"default"';const r=[];for(let s=0;s<e.props.length;s++){const t=e.props[s];6===t.type?t.value&&("name"===t.name?o=JSON.stringify(t.value.content):(t.name=k(t.name),r.push(t))):"bind"===t.name&&Xe(t.arg,"name")?t.exp&&(o=t.exp):("bind"===t.name&&t.arg&&Le(t.arg)&&(t.arg.content=k(t.arg.content)),r.push(t))}if(r.length>0){const{props:o,directives:s}=Qn(e,t,r,!1,!1);n=o}return{slotName:o,slotProps:n}}const so=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,io=(e,t,n,o)=>{const{loc:r,modifiers:s,arg:i}=e;let c;if(4===i.type)if(i.isStatic){let e=i.content;e.startsWith("vue:")&&(e=`vnode-${e.slice(4)}`);c=Ne(0!==t.tagType||e.startsWith("vnode")||!/[A-Z]/.test(e)?E(k(e)):`on:${e}`,!0,i.loc)}else c=Te([`${n.helperString(ie)}(`,i,")"]);else c=i,c.children.unshift(`${n.helperString(ie)}(`),c.children.push(")");let l=e.exp;l&&!l.content.trim()&&(l=void 0);let a=n.cacheHandlers&&!l&&!n.inVOnce;if(l){const e=ze(l.content),t=!(e||so.test(l.content)),n=l.content.includes(";");(t||a&&e)&&(l=Te([`${t?"$event":"(...args)"} => ${n?"{":"("}`,l,n?"}":")"]))}let p={props:[ke(c,l||Ne("() => {}",!1,r))]};return o&&(p=o(p)),a&&(p.props[0].value=n.cache(p.props[0].value)),p.props.forEach((e=>e.key.isHandlerKey=!0)),p},co=(e,t,n)=>{const{exp:o,modifiers:r,loc:s}=e,i=e.arg;return 4!==i.type?(i.children.unshift("("),i.children.push(') || ""')):i.isStatic||(i.content=`${i.content} || ""`),r.includes("camel")&&(4===i.type?i.content=i.isStatic?k(i.content):`${n.helperString(re)}(${i.content})`:(i.children.unshift(`${n.helperString(re)}(`),i.children.push(")"))),n.inSSR||(r.includes("prop")&&lo(i,"."),r.includes("attr")&&lo(i,"^")),!o||4===o.type&&!o.content.trim()?{props:[ke(i,Ne("",!0,s))]}:{props:[ke(i,o)]}},lo=(e,t)=>{4===e.type?e.content=e.isStatic?t+e.content:`\`${t}\${${e.content}}\``:(e.children.unshift(`'${t}' + (`),e.children.push(")"))},ao=(e,t)=>{if(0===e.type||1===e.type||11===e.type||10===e.type)return()=>{const n=e.children;let o,r=!1;for(let e=0;e<n.length;e++){const t=n[e];if(tt(t)){r=!0;for(let r=e+1;r<n.length;r++){const s=n[r];if(!tt(s)){o=void 0;break}o||(o=n[e]=Te([t],t.loc)),o.children.push(" + ",s),n.splice(r,1),r--}}}if(r&&(1!==n.length||0!==e.type&&(1!==e.type||0!==e.tagType||e.props.find((e=>7===e.type&&!t.directiveTransforms[e.name]))||"template"===e.tag)))for(let e=0;e<n.length;e++){const o=n[e];if(tt(o)||8===o.type){const r=[];2===o.type&&" "===o.content||r.push(o),t.ssr||0!==qt(o,t)||r.push("1"),n[e]={type:12,content:o,loc:o.loc,codegenNode:Ee(t.helper(D),r)}}}}},po=new WeakSet,uo=(e,t)=>{if(1===e.type&&Ye(e,"once",!0)){if(po.has(e)||t.inVOnce)return;return po.add(e),t.inVOnce=!0,t.helper(ce),()=>{t.inVOnce=!1;const e=t.currentNode;e.codegenNode&&(e.codegenNode=t.cache(e.codegenNode,!0))}}},fo=(e,t,n)=>{const{exp:o,arg:r}=e;if(!o)return ho();const s=o.loc.source,i=4===o.type?o.content:s,c=n.bindingMetadata[s];if("props"===c||"props-aliased"===c)return ho();if(!i.trim()||!ze(i))return ho();const l=r||Ne("modelValue",!0),a=r?Le(r)?`onUpdate:${k(r.content)}`:Te(['"onUpdate:" + ',r]):"onUpdate:modelValue";let p;p=Te([`${n.isTS?"($event: any)":"$event"} => ((`,o,") = $event)"]);const u=[ke(l,e.exp),ke(a,p)];if(e.modifiers.length&&1===t.tagType){const t=e.modifiers.map((e=>(Fe(e)?e:JSON.stringify(e))+": true")).join(", "),n=r?Le(r)?`${r.content}Modifiers`:Te([r,' + "Modifiers"']):"modelModifiers";u.push(ke(n,Ne(`{ ${t} }`,!1,e.loc,2)))}return ho(u)};function ho(e=[]){return{props:e}}const mo=/[\w).+\-_$\]]/,go=(e,t)=>{yt("COMPILER_FILTER",t)&&(5===e.type&&yo(e.content,t),1===e.type&&e.props.forEach((e=>{7===e.type&&"for"!==e.name&&e.exp&&yo(e.exp,t)})))};function yo(e,t){if(4===e.type)vo(e,t);else for(let n=0;n<e.children.length;n++){const o=e.children[n];"object"==typeof o&&(4===o.type?vo(o,t):8===o.type?yo(e,t):5===o.type&&yo(o.content,t))}}function vo(e,t){const n=e.content;let o,r,s,i,c=!1,l=!1,a=!1,p=!1,u=0,f=0,d=0,h=0,m=[];for(s=0;s<n.length;s++)if(r=o,o=n.charCodeAt(s),c)39===o&&92!==r&&(c=!1);else if(l)34===o&&92!==r&&(l=!1);else if(a)96===o&&92!==r&&(a=!1);else if(p)47===o&&92!==r&&(p=!1);else if(124!==o||124===n.charCodeAt(s+1)||124===n.charCodeAt(s-1)||u||f||d){switch(o){case 34:l=!0;break;case 39:c=!0;break;case 96:a=!0;break;case 40:d++;break;case 41:d--;break;case 91:f++;break;case 93:f--;break;case 123:u++;break;case 125:u--}if(47===o){let e,t=s-1;for(;t>=0&&(e=n.charAt(t)," "===e);t--);e&&mo.test(e)||(p=!0)}}else void 0===i?(h=s+1,i=n.slice(0,s).trim()):g();function g(){m.push(n.slice(h,s).trim()),h=s+1}if(void 0===i?i=n.slice(0,s).trim():0!==h&&g(),m.length){for(s=0;s<m.length;s++)i=bo(i,m[s],t);e.content=i}}function bo(e,t,n){n.helper(z);const o=t.indexOf("(");if(o<0)return n.filters.add(t),`${ut(t,"filter")}(${e})`;{const r=t.slice(0,o),s=t.slice(o+1);return n.filters.add(r),`${ut(r,"filter")}(${e}${")"!==s?","+s:s}`}}const So=new WeakSet,xo=(e,t)=>{if(1===e.type){const n=Ye(e,"memo");if(!n||So.has(e))return;return So.add(e),()=>{const o=e.codegenNode||t.currentNode.codegenNode;o&&13===o.type&&(1!==e.tagType&&ht(o,t),e.codegenNode=Ee(t.helper(de),[n.exp,we(void 0,o),"_cache",String(t.cached++)]))}}};function ko(e){return[[uo,On,xo,Pn,go,oo,Zn,Hn,ao],{on:io,bind:co,model:fo}]}function No(e,t={}){const n=t.onError||w,o="module"===t.mode;!0===t.prefixIdentifiers?n($(47)):o&&n($(48));t.cacheHandlers&&n($(49)),t.scopeId&&!o&&n($(50));const r=m(e)?Nt(e,t):e,[s,i]=ko();return nn(r,d({},t,{prefixIdentifiers:false,nodeTransforms:[...s,...t.nodeTransforms||[]],directiveTransforms:d({},i,t.directiveTransforms||{})})),ln(r,d({},t,{prefixIdentifiers:false}))}const _o=()=>({props:[]}),To=Symbol(""),Eo=Symbol(""),wo=Symbol(""),Oo=Symbol(""),$o=Symbol(""),Co=Symbol(""),Mo=Symbol(""),Io=Symbol(""),Po=Symbol(""),Ro=Symbol("");let Vo;ge({[To]:"vModelRadio",[Eo]:"vModelCheckbox",[wo]:"vModelText",[Oo]:"vModelSelect",[$o]:"vModelDynamic",[Co]:"withModifiers",[Mo]:"withKeys",[Io]:"vShow",[Po]:"Transition",[Ro]:"TransitionGroup"});const Lo=e("style,iframe,script,noscript",!0),Ao={isVoidTag:c,isNativeTag:e=>s(e)||i(e),isPreTag:e=>"pre"===e,decodeEntities:function(e,t=!1){return Vo||(Vo=document.createElement("div")),t?(Vo.innerHTML=`<div foo="${e.replace(/"/g,"&quot;")}">`,Vo.children[0].getAttribute("foo")):(Vo.innerHTML=e,Vo.textContent)},isBuiltInComponent:e=>Ae(e,"Transition")?Po:Ae(e,"TransitionGroup")?Ro:void 0,getNamespace(e,t){let n=t?t.ns:0;if(t&&2===n)if("annotation-xml"===t.tag){if("svg"===e)return 1;t.props.some((e=>6===e.type&&"encoding"===e.name&&null!=e.value&&("text/html"===e.value.content||"application/xhtml+xml"===e.value.content)))&&(n=0)}else/^m(?:[ions]|text)$/.test(t.tag)&&"mglyph"!==e&&"malignmark"!==e&&(n=0);else t&&1===n&&("foreignObject"!==t.tag&&"desc"!==t.tag&&"title"!==t.tag||(n=0));if(0===n){if("svg"===e)return 1;if("math"===e)return 2}return n},getTextMode({tag:e,ns:t}){if(0===t){if("textarea"===e||"title"===e)return 1;if(Lo(e))return 2}return 0}},Bo=e=>{1===e.type&&e.props.forEach(((t,n)=>{6===t.type&&"style"===t.name&&t.value&&(e.props[n]={type:7,name:"bind",arg:Ne("style",!0,t.loc),exp:jo(t.value.content,t.loc),modifiers:[],loc:t.loc})}))},jo=(e,t)=>{const s=function(e){const t={};return e.replace(r,"").split(n).forEach((e=>{if(e){const n=e.split(o);n.length>1&&(t[n[0].trim()]=n[1].trim())}})),t}(e);return Ne(JSON.stringify(s),!1,t,3)};function Fo(e,t){return $(e,t)}const Do=e("passive,once,capture"),Ho=e("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),Wo=e("left,right"),Uo=e("onkeyup,onkeydown,onkeypress",!0),Jo=(e,t)=>Le(e)&&"onclick"===e.content.toLowerCase()?Ne(t,!0):4!==e.type?Te(["(",e,`) === "onClick" ? "${t}" : (`,e,")"]):e,zo=(e,t)=>{1!==e.type||0!==e.tagType||"script"!==e.tag&&"style"!==e.tag||t.removeNode()},Go=[Bo],Ko={cloak:_o,html:(e,t,n)=>{const{exp:o,loc:r}=e;return t.children.length&&(t.children.length=0),{props:[ke(Ne("innerHTML",!0,r),o||Ne("",!0))]}},text:(e,t,n)=>{const{exp:o,loc:r}=e;return t.children.length&&(t.children.length=0),{props:[ke(Ne("textContent",!0),o?qt(o,n)>0?o:Ee(n.helperString(Y),[o],r):Ne("",!0))]}},model:(e,t,n)=>{const o=fo(e,t,n);if(!o.props.length||1===t.tagType)return o;const{tag:r}=t,s=n.isCustomElement(r);if("input"===r||"textarea"===r||"select"===r||s){let e=wo,i=!1;if("input"===r||s){const n=Qe(t,"type");if(n){if(7===n.type)e=$o;else if(n.value)switch(n.value.content){case"radio":e=To;break;case"checkbox":e=Eo;break;case"file":i=!0}}else et(t)&&(e=$o)}else"select"===r&&(e=Oo);i||(o.needRuntime=n.helper(e))}return o.props=o.props.filter((e=>!(4===e.key.type&&"modelValue"===e.key.content))),o},on:(e,t,n)=>io(e,t,n,(t=>{const{modifiers:o}=e;if(!o.length)return t;let{key:r,value:s}=t.props[0];const{keyModifiers:i,nonKeyModifiers:c,eventOptionModifiers:l}=((e,t,n,o)=>{const r=[],s=[],i=[];for(let c=0;c<t.length;c++){const o=t[c];"native"===o&&vt("COMPILER_V_ON_NATIVE",n)||Do(o)?i.push(o):Wo(o)?Le(e)?Uo(e.content)?r.push(o):s.push(o):(r.push(o),s.push(o)):Ho(o)?s.push(o):r.push(o)}return{keyModifiers:r,nonKeyModifiers:s,eventOptionModifiers:i}})(r,o,n);if(c.includes("right")&&(r=Jo(r,"onContextmenu")),c.includes("middle")&&(r=Jo(r,"onMouseup")),c.length&&(s=Ee(n.helper(Co),[s,JSON.stringify(c)])),!i.length||Le(r)&&!Uo(r.content)||(s=Ee(n.helper(Mo),[s,JSON.stringify(i)])),l.length){const e=l.map(T).join("");r=Le(r)?Ne(`${r.content}${e}`,!0):Te(["(",r,`) + "${e}"`])}return{props:[ke(r,s)]}})),show:(e,t,n)=>({props:[],needRuntime:n.helper(Io)})};function qo(e,t={}){return No(e,d({},Ao,t,{nodeTransforms:[zo,...Go,...t.nodeTransforms||[]],directiveTransforms:d({},Ko,t.directiveTransforms||{}),transformHoist:null}))}function Zo(e,t={}){return Nt(e,d({},Ao,t))}export{R as BASE_TRANSITION,re as CAMELIZE,se as CAPITALIZE,L as CREATE_BLOCK,F as CREATE_COMMENT,A as CREATE_ELEMENT_BLOCK,j as CREATE_ELEMENT_VNODE,Z as CREATE_SLOTS,H as CREATE_STATIC,D as CREATE_TEXT,B as CREATE_VNODE,Ko as DOMDirectiveTransforms,Go as DOMNodeTransforms,C as FRAGMENT,ne as GUARD_REACTIVE_PROPS,he as IS_MEMO_SAME,fe as IS_REF,P as KEEP_ALIVE,Q as MERGE_PROPS,X as NORMALIZE_CLASS,te as NORMALIZE_PROPS,ee as NORMALIZE_STYLE,V as OPEN_BLOCK,ae as POP_SCOPE_ID,le as PUSH_SCOPE_ID,K as RENDER_LIST,q as RENDER_SLOT,W as RESOLVE_COMPONENT,J as RESOLVE_DIRECTIVE,U as RESOLVE_DYNAMIC_COMPONENT,z as RESOLVE_FILTER,ce as SET_BLOCK_TRACKING,I as SUSPENSE,M as TELEPORT,Y as TO_DISPLAY_STRING,oe as TO_HANDLERS,ie as TO_HANDLER_KEY,Po as TRANSITION,Ro as TRANSITION_GROUP,ue as UNREF,Eo as V_MODEL_CHECKBOX,$o as V_MODEL_DYNAMIC,To as V_MODEL_RADIO,Oo as V_MODEL_SELECT,wo as V_MODEL_TEXT,Mo as V_ON_WITH_KEYS,Co as V_ON_WITH_MODIFIERS,Io as V_SHOW,pe as WITH_CTX,G as WITH_DIRECTIVES,de as WITH_MEMO,Ke as advancePositionWithClone,qe as advancePositionWithMutation,Ze as assert,No as baseCompile,Nt as baseParse,to as buildDirectiveArgs,Qn as buildProps,Jn as buildSlots,vt as checkCompatEnabled,qo as compile,Se as createArrayExpression,Pe as createAssignmentExpression,Ce as createBlockStatement,$e as createCacheExpression,Ee as createCallExpression,$ as createCompilerError,Te as createCompoundExpression,Oe as createConditionalExpression,Fo as createDOMCompilerError,Fn as createForLoopParams,we as createFunctionExpression,Ie as createIfStatement,_e as createInterpolation,xe as createObjectExpression,ke as createObjectProperty,Ve as createReturnStatement,ve as createRoot,Re as createSequenceExpression,Ne as createSimpleExpression,rn as createStructuralDirectiveTransform,Me as createTemplateLiteral,tn as createTransformContext,be as createVNodeCall,xn as extractIdentifiers,Ye as findDir,Qe as findProp,ln as generate,t as generateCodeFrame,ko as getBaseTransformPreset,qt as getConstantType,Ge as getInnerRange,dt as getMemoedVNodeCall,it as getVNodeBlockHelper,st as getVNodeHelper,et as hasDynamicKeyVBind,ft as hasScopeRef,me as helperNameMap,at as injectProp,Ae as isBuiltInType,Be as isCoreComponent,kn as isFunctionType,vn as isInDestructureAssignment,ze as isMemberExpression,Ue as isMemberExpressionBrowser,Je as isMemberExpressionNode,yn as isReferencedIdentifier,Fe as isSimpleIdentifier,rt as isSlotOutlet,Xe as isStaticArgOf,Le as isStaticExp,Nn as isStaticProperty,_n as isStaticPropertyKey,ot as isTemplateNode,tt as isText,nt as isVSlot,ye as locStub,ht as makeBlock,_o as noopDirectiveTransform,Zo as parse,Ao as parserOptions,En as processExpression,Rn as processFor,$n as processIf,ro as processSlotOutlet,ge as registerRuntimeHelpers,Yn as resolveComponentType,wn as stringifyExpression,ut as toValidAssetId,Hn as trackSlotScopes,Wn as trackVForSlotScopes,nn as transform,co as transformBind,Zn as transformElement,Tn as transformExpression,fo as transformModel,io as transformOn,Bo as transformStyle,on as traverseNode,Sn as walkBlockDeclarations,bn as walkFunctionParams,gn as walkIdentifiers,bt as warnDeprecation};
¹/dist/compiler-dom.cjs.jsÆ 3¿'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compilerCore = require('@vue/compiler-core');
var shared = require('@vue/shared');

const V_MODEL_RADIO = Symbol(`vModelRadio` );
const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );
const V_MODEL_TEXT = Symbol(`vModelText` );
const V_MODEL_SELECT = Symbol(`vModelSelect` );
const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );
const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );
const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );
const V_SHOW = Symbol(`vShow` );
const TRANSITION = Symbol(`Transition` );
const TRANSITION_GROUP = Symbol(`TransitionGroup` );
compilerCore.registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

var namedCharacterReferences = {
	GT: ">",
	gt: ">",
	LT: "<",
	lt: "<",
	"ac;": "âˆ¾",
	"af;": "â¡",
	AMP: "&",
	amp: "&",
	"ap;": "â‰ˆ",
	"DD;": "â……",
	"dd;": "â…†",
	deg: "Â°",
	"ee;": "â…‡",
	"eg;": "âªš",
	"el;": "âª™",
	ETH: "Ã",
	eth: "Ã°",
	"gE;": "â‰§",
	"ge;": "â‰¥",
	"Gg;": "â‹™",
	"gg;": "â‰«",
	"gl;": "â‰·",
	"GT;": ">",
	"Gt;": "â‰«",
	"gt;": ">",
	"ic;": "â£",
	"ii;": "â…ˆ",
	"Im;": "â„‘",
	"in;": "âˆˆ",
	"it;": "â¢",
	"lE;": "â‰¦",
	"le;": "â‰¤",
	"lg;": "â‰¶",
	"Ll;": "â‹˜",
	"ll;": "â‰ª",
	"LT;": "<",
	"Lt;": "â‰ª",
	"lt;": "<",
	"mp;": "âˆ“",
	"Mu;": "Îœ",
	"mu;": "Î¼",
	"ne;": "â‰ ",
	"ni;": "âˆ‹",
	not: "Â¬",
	"Nu;": "Î",
	"nu;": "Î½",
	"Or;": "â©”",
	"or;": "âˆ¨",
	"oS;": "â“ˆ",
	"Pi;": "Î ",
	"pi;": "Ï€",
	"pm;": "Â±",
	"Pr;": "âª»",
	"pr;": "â‰º",
	"Re;": "â„œ",
	REG: "Â®",
	reg: "Â®",
	"rx;": "â„ž",
	"Sc;": "âª¼",
	"sc;": "â‰»",
	shy: "Â­",
	uml: "Â¨",
	"wp;": "â„˜",
	"wr;": "â‰€",
	"Xi;": "Îž",
	"xi;": "Î¾",
	yen: "Â¥",
	"acd;": "âˆ¿",
	"acE;": "âˆ¾Ì³",
	"Acy;": "Ð",
	"acy;": "Ð°",
	"Afr;": "ð”„",
	"afr;": "ð”ž",
	"AMP;": "&",
	"amp;": "&",
	"And;": "â©“",
	"and;": "âˆ§",
	"ang;": "âˆ ",
	"apE;": "â©°",
	"ape;": "â‰Š",
	"ast;": "*",
	Auml: "Ã„",
	auml: "Ã¤",
	"Bcy;": "Ð‘",
	"bcy;": "Ð±",
	"Bfr;": "ð”…",
	"bfr;": "ð”Ÿ",
	"bne;": "=âƒ¥",
	"bot;": "âŠ¥",
	"Cap;": "â‹’",
	"cap;": "âˆ©",
	cent: "Â¢",
	"Cfr;": "â„­",
	"cfr;": "ð” ",
	"Chi;": "Î§",
	"chi;": "Ï‡",
	"cir;": "â—‹",
	COPY: "Â©",
	copy: "Â©",
	"Cup;": "â‹“",
	"cup;": "âˆª",
	"Dcy;": "Ð”",
	"dcy;": "Ð´",
	"deg;": "Â°",
	"Del;": "âˆ‡",
	"Dfr;": "ð”‡",
	"dfr;": "ð”¡",
	"die;": "Â¨",
	"div;": "Ã·",
	"Dot;": "Â¨",
	"dot;": "Ë™",
	"Ecy;": "Ð­",
	"ecy;": "Ñ",
	"Efr;": "ð”ˆ",
	"efr;": "ð”¢",
	"egs;": "âª–",
	"ell;": "â„“",
	"els;": "âª•",
	"ENG;": "ÅŠ",
	"eng;": "Å‹",
	"Eta;": "Î—",
	"eta;": "Î·",
	"ETH;": "Ã",
	"eth;": "Ã°",
	Euml: "Ã‹",
	euml: "Ã«",
	"Fcy;": "Ð¤",
	"fcy;": "Ñ„",
	"Ffr;": "ð”‰",
	"ffr;": "ð”£",
	"gap;": "âª†",
	"Gcy;": "Ð“",
	"gcy;": "Ð³",
	"gEl;": "âªŒ",
	"gel;": "â‹›",
	"geq;": "â‰¥",
	"ges;": "â©¾",
	"Gfr;": "ð”Š",
	"gfr;": "ð”¤",
	"ggg;": "â‹™",
	"gla;": "âª¥",
	"glE;": "âª’",
	"glj;": "âª¤",
	"gnE;": "â‰©",
	"gne;": "âªˆ",
	"Hat;": "^",
	"Hfr;": "â„Œ",
	"hfr;": "ð”¥",
	"Icy;": "Ð˜",
	"icy;": "Ð¸",
	"iff;": "â‡”",
	"Ifr;": "â„‘",
	"ifr;": "ð”¦",
	"Int;": "âˆ¬",
	"int;": "âˆ«",
	Iuml: "Ã",
	iuml: "Ã¯",
	"Jcy;": "Ð™",
	"jcy;": "Ð¹",
	"Jfr;": "ð”",
	"jfr;": "ð”§",
	"Kcy;": "Ðš",
	"kcy;": "Ðº",
	"Kfr;": "ð”Ž",
	"kfr;": "ð”¨",
	"lap;": "âª…",
	"lat;": "âª«",
	"Lcy;": "Ð›",
	"lcy;": "Ð»",
	"lEg;": "âª‹",
	"leg;": "â‹š",
	"leq;": "â‰¤",
	"les;": "â©½",
	"Lfr;": "ð”",
	"lfr;": "ð”©",
	"lgE;": "âª‘",
	"lnE;": "â‰¨",
	"lne;": "âª‡",
	"loz;": "â—Š",
	"lrm;": "â€Ž",
	"Lsh;": "â†°",
	"lsh;": "â†°",
	macr: "Â¯",
	"Map;": "â¤…",
	"map;": "â†¦",
	"Mcy;": "Ðœ",
	"mcy;": "Ð¼",
	"Mfr;": "ð”",
	"mfr;": "ð”ª",
	"mho;": "â„§",
	"mid;": "âˆ£",
	"nap;": "â‰‰",
	nbsp: "Â ",
	"Ncy;": "Ð",
	"ncy;": "Ð½",
	"Nfr;": "ð”‘",
	"nfr;": "ð”«",
	"ngE;": "â‰§Ì¸",
	"nge;": "â‰±",
	"nGg;": "â‹™Ì¸",
	"nGt;": "â‰«âƒ’",
	"ngt;": "â‰¯",
	"nis;": "â‹¼",
	"niv;": "âˆ‹",
	"nlE;": "â‰¦Ì¸",
	"nle;": "â‰°",
	"nLl;": "â‹˜Ì¸",
	"nLt;": "â‰ªâƒ’",
	"nlt;": "â‰®",
	"Not;": "â«¬",
	"not;": "Â¬",
	"npr;": "âŠ€",
	"nsc;": "âŠ",
	"num;": "#",
	"Ocy;": "Ðž",
	"ocy;": "Ð¾",
	"Ofr;": "ð”’",
	"ofr;": "ð”¬",
	"ogt;": "â§",
	"ohm;": "Î©",
	"olt;": "â§€",
	"ord;": "â©",
	ordf: "Âª",
	ordm: "Âº",
	"orv;": "â©›",
	Ouml: "Ã–",
	ouml: "Ã¶",
	"par;": "âˆ¥",
	para: "Â¶",
	"Pcy;": "ÐŸ",
	"pcy;": "Ð¿",
	"Pfr;": "ð”“",
	"pfr;": "ð”­",
	"Phi;": "Î¦",
	"phi;": "Ï†",
	"piv;": "Ï–",
	"prE;": "âª³",
	"pre;": "âª¯",
	"Psi;": "Î¨",
	"psi;": "Ïˆ",
	"Qfr;": "ð””",
	"qfr;": "ð”®",
	QUOT: "\"",
	quot: "\"",
	"Rcy;": "Ð ",
	"rcy;": "Ñ€",
	"REG;": "Â®",
	"reg;": "Â®",
	"Rfr;": "â„œ",
	"rfr;": "ð”¯",
	"Rho;": "Î¡",
	"rho;": "Ï",
	"rlm;": "â€",
	"Rsh;": "â†±",
	"rsh;": "â†±",
	"scE;": "âª´",
	"sce;": "âª°",
	"Scy;": "Ð¡",
	"scy;": "Ñ",
	sect: "Â§",
	"Sfr;": "ð”–",
	"sfr;": "ð”°",
	"shy;": "Â­",
	"sim;": "âˆ¼",
	"smt;": "âªª",
	"sol;": "/",
	"squ;": "â–¡",
	"Sub;": "â‹",
	"sub;": "âŠ‚",
	"Sum;": "âˆ‘",
	"sum;": "âˆ‘",
	"Sup;": "â‹‘",
	"sup;": "âŠƒ",
	sup1: "Â¹",
	sup2: "Â²",
	sup3: "Â³",
	"Tab;": "\t",
	"Tau;": "Î¤",
	"tau;": "Ï„",
	"Tcy;": "Ð¢",
	"tcy;": "Ñ‚",
	"Tfr;": "ð”—",
	"tfr;": "ð”±",
	"top;": "âŠ¤",
	"Ucy;": "Ð£",
	"ucy;": "Ñƒ",
	"Ufr;": "ð”˜",
	"ufr;": "ð”²",
	"uml;": "Â¨",
	Uuml: "Ãœ",
	uuml: "Ã¼",
	"Vcy;": "Ð’",
	"vcy;": "Ð²",
	"Vee;": "â‹",
	"vee;": "âˆ¨",
	"Vfr;": "ð”™",
	"vfr;": "ð”³",
	"Wfr;": "ð”š",
	"wfr;": "ð”´",
	"Xfr;": "ð”›",
	"xfr;": "ð”µ",
	"Ycy;": "Ð«",
	"ycy;": "Ñ‹",
	"yen;": "Â¥",
	"Yfr;": "ð”œ",
	"yfr;": "ð”¶",
	yuml: "Ã¿",
	"Zcy;": "Ð—",
	"zcy;": "Ð·",
	"Zfr;": "â„¨",
	"zfr;": "ð”·",
	"zwj;": "â€",
	Acirc: "Ã‚",
	acirc: "Ã¢",
	acute: "Â´",
	AElig: "Ã†",
	aelig: "Ã¦",
	"andd;": "â©œ",
	"andv;": "â©š",
	"ange;": "â¦¤",
	"Aopf;": "ð”¸",
	"aopf;": "ð•’",
	"apid;": "â‰‹",
	"apos;": "'",
	Aring: "Ã…",
	aring: "Ã¥",
	"Ascr;": "ð’œ",
	"ascr;": "ð’¶",
	"Auml;": "Ã„",
	"auml;": "Ã¤",
	"Barv;": "â«§",
	"bbrk;": "âŽµ",
	"Beta;": "Î’",
	"beta;": "Î²",
	"beth;": "â„¶",
	"bNot;": "â«­",
	"bnot;": "âŒ",
	"Bopf;": "ð”¹",
	"bopf;": "ð•“",
	"boxH;": "â•",
	"boxh;": "â”€",
	"boxV;": "â•‘",
	"boxv;": "â”‚",
	"Bscr;": "â„¬",
	"bscr;": "ð’·",
	"bsim;": "âˆ½",
	"bsol;": "\\",
	"bull;": "â€¢",
	"bump;": "â‰Ž",
	"caps;": "âˆ©ï¸€",
	"Cdot;": "ÄŠ",
	"cdot;": "Ä‹",
	cedil: "Â¸",
	"cent;": "Â¢",
	"CHcy;": "Ð§",
	"chcy;": "Ñ‡",
	"circ;": "Ë†",
	"cirE;": "â§ƒ",
	"cire;": "â‰—",
	"comp;": "âˆ",
	"cong;": "â‰…",
	"Copf;": "â„‚",
	"copf;": "ð•”",
	"COPY;": "Â©",
	"copy;": "Â©",
	"Cscr;": "ð’ž",
	"cscr;": "ð’¸",
	"csub;": "â«",
	"csup;": "â«",
	"cups;": "âˆªï¸€",
	"Darr;": "â†¡",
	"dArr;": "â‡“",
	"darr;": "â†“",
	"dash;": "â€",
	"dHar;": "â¥¥",
	"diam;": "â‹„",
	"DJcy;": "Ð‚",
	"djcy;": "Ñ’",
	"Dopf;": "ð”»",
	"dopf;": "ð••",
	"Dscr;": "ð’Ÿ",
	"dscr;": "ð’¹",
	"DScy;": "Ð…",
	"dscy;": "Ñ•",
	"dsol;": "â§¶",
	"dtri;": "â–¿",
	"DZcy;": "Ð",
	"dzcy;": "ÑŸ",
	"ecir;": "â‰–",
	Ecirc: "ÃŠ",
	ecirc: "Ãª",
	"Edot;": "Ä–",
	"eDot;": "â‰‘",
	"edot;": "Ä—",
	"emsp;": "â€ƒ",
	"ensp;": "â€‚",
	"Eopf;": "ð”¼",
	"eopf;": "ð•–",
	"epar;": "â‹•",
	"epsi;": "Îµ",
	"Escr;": "â„°",
	"escr;": "â„¯",
	"Esim;": "â©³",
	"esim;": "â‰‚",
	"Euml;": "Ã‹",
	"euml;": "Ã«",
	"euro;": "â‚¬",
	"excl;": "!",
	"flat;": "â™­",
	"fnof;": "Æ’",
	"Fopf;": "ð”½",
	"fopf;": "ð•—",
	"fork;": "â‹”",
	"Fscr;": "â„±",
	"fscr;": "ð’»",
	"Gdot;": "Ä ",
	"gdot;": "Ä¡",
	"geqq;": "â‰§",
	"gesl;": "â‹›ï¸€",
	"GJcy;": "Ðƒ",
	"gjcy;": "Ñ“",
	"gnap;": "âªŠ",
	"gneq;": "âªˆ",
	"Gopf;": "ð”¾",
	"gopf;": "ð•˜",
	"Gscr;": "ð’¢",
	"gscr;": "â„Š",
	"gsim;": "â‰³",
	"gtcc;": "âª§",
	"gvnE;": "â‰©ï¸€",
	"half;": "Â½",
	"hArr;": "â‡”",
	"harr;": "â†”",
	"hbar;": "â„",
	"Hopf;": "â„",
	"hopf;": "ð•™",
	"Hscr;": "â„‹",
	"hscr;": "ð’½",
	Icirc: "ÃŽ",
	icirc: "Ã®",
	"Idot;": "Ä°",
	"IEcy;": "Ð•",
	"iecy;": "Ðµ",
	iexcl: "Â¡",
	"imof;": "âŠ·",
	"IOcy;": "Ð",
	"iocy;": "Ñ‘",
	"Iopf;": "ð•€",
	"iopf;": "ð•š",
	"Iota;": "Î™",
	"iota;": "Î¹",
	"Iscr;": "â„",
	"iscr;": "ð’¾",
	"isin;": "âˆˆ",
	"Iuml;": "Ã",
	"iuml;": "Ã¯",
	"Jopf;": "ð•",
	"jopf;": "ð•›",
	"Jscr;": "ð’¥",
	"jscr;": "ð’¿",
	"KHcy;": "Ð¥",
	"khcy;": "Ñ…",
	"KJcy;": "ÐŒ",
	"kjcy;": "Ñœ",
	"Kopf;": "ð•‚",
	"kopf;": "ð•œ",
	"Kscr;": "ð’¦",
	"kscr;": "ð“€",
	"Lang;": "âŸª",
	"lang;": "âŸ¨",
	laquo: "Â«",
	"Larr;": "â†ž",
	"lArr;": "â‡",
	"larr;": "â†",
	"late;": "âª­",
	"lcub;": "{",
	"ldca;": "â¤¶",
	"ldsh;": "â†²",
	"leqq;": "â‰¦",
	"lesg;": "â‹šï¸€",
	"lHar;": "â¥¢",
	"LJcy;": "Ð‰",
	"ljcy;": "Ñ™",
	"lnap;": "âª‰",
	"lneq;": "âª‡",
	"Lopf;": "ð•ƒ",
	"lopf;": "ð•",
	"lozf;": "â§«",
	"lpar;": "(",
	"Lscr;": "â„’",
	"lscr;": "ð“",
	"lsim;": "â‰²",
	"lsqb;": "[",
	"ltcc;": "âª¦",
	"ltri;": "â—ƒ",
	"lvnE;": "â‰¨ï¸€",
	"macr;": "Â¯",
	"male;": "â™‚",
	"malt;": "âœ ",
	micro: "Âµ",
	"mlcp;": "â«›",
	"mldr;": "â€¦",
	"Mopf;": "ð•„",
	"mopf;": "ð•ž",
	"Mscr;": "â„³",
	"mscr;": "ð“‚",
	"nang;": "âˆ âƒ’",
	"napE;": "â©°Ì¸",
	"nbsp;": "Â ",
	"ncap;": "â©ƒ",
	"ncup;": "â©‚",
	"ngeq;": "â‰±",
	"nges;": "â©¾Ì¸",
	"ngtr;": "â‰¯",
	"nGtv;": "â‰«Ì¸",
	"nisd;": "â‹º",
	"NJcy;": "ÐŠ",
	"njcy;": "Ñš",
	"nldr;": "â€¥",
	"nleq;": "â‰°",
	"nles;": "â©½Ì¸",
	"nLtv;": "â‰ªÌ¸",
	"nmid;": "âˆ¤",
	"Nopf;": "â„•",
	"nopf;": "ð•Ÿ",
	"npar;": "âˆ¦",
	"npre;": "âª¯Ì¸",
	"nsce;": "âª°Ì¸",
	"Nscr;": "ð’©",
	"nscr;": "ð“ƒ",
	"nsim;": "â‰",
	"nsub;": "âŠ„",
	"nsup;": "âŠ…",
	"ntgl;": "â‰¹",
	"ntlg;": "â‰¸",
	"nvap;": "â‰âƒ’",
	"nvge;": "â‰¥âƒ’",
	"nvgt;": ">âƒ’",
	"nvle;": "â‰¤âƒ’",
	"nvlt;": "<âƒ’",
	"oast;": "âŠ›",
	"ocir;": "âŠš",
	Ocirc: "Ã”",
	ocirc: "Ã´",
	"odiv;": "â¨¸",
	"odot;": "âŠ™",
	"ogon;": "Ë›",
	"oint;": "âˆ®",
	"omid;": "â¦¶",
	"Oopf;": "ð•†",
	"oopf;": "ð• ",
	"opar;": "â¦·",
	"ordf;": "Âª",
	"ordm;": "Âº",
	"oror;": "â©–",
	"Oscr;": "ð’ª",
	"oscr;": "â„´",
	"osol;": "âŠ˜",
	"Ouml;": "Ã–",
	"ouml;": "Ã¶",
	"para;": "Â¶",
	"part;": "âˆ‚",
	"perp;": "âŠ¥",
	"phiv;": "Ï•",
	"plus;": "+",
	"Popf;": "â„™",
	"popf;": "ð•¡",
	pound: "Â£",
	"prap;": "âª·",
	"prec;": "â‰º",
	"prnE;": "âªµ",
	"prod;": "âˆ",
	"prop;": "âˆ",
	"Pscr;": "ð’«",
	"pscr;": "ð“…",
	"qint;": "â¨Œ",
	"Qopf;": "â„š",
	"qopf;": "ð•¢",
	"Qscr;": "ð’¬",
	"qscr;": "ð“†",
	"QUOT;": "\"",
	"quot;": "\"",
	"race;": "âˆ½Ì±",
	"Rang;": "âŸ«",
	"rang;": "âŸ©",
	raquo: "Â»",
	"Rarr;": "â† ",
	"rArr;": "â‡’",
	"rarr;": "â†’",
	"rcub;": "}",
	"rdca;": "â¤·",
	"rdsh;": "â†³",
	"real;": "â„œ",
	"rect;": "â–­",
	"rHar;": "â¥¤",
	"rhov;": "Ï±",
	"ring;": "Ëš",
	"Ropf;": "â„",
	"ropf;": "ð•£",
	"rpar;": ")",
	"Rscr;": "â„›",
	"rscr;": "ð“‡",
	"rsqb;": "]",
	"rtri;": "â–¹",
	"scap;": "âª¸",
	"scnE;": "âª¶",
	"sdot;": "â‹…",
	"sect;": "Â§",
	"semi;": ";",
	"sext;": "âœ¶",
	"SHcy;": "Ð¨",
	"shcy;": "Ñˆ",
	"sime;": "â‰ƒ",
	"simg;": "âªž",
	"siml;": "âª",
	"smid;": "âˆ£",
	"smte;": "âª¬",
	"solb;": "â§„",
	"Sopf;": "ð•Š",
	"sopf;": "ð•¤",
	"spar;": "âˆ¥",
	"Sqrt;": "âˆš",
	"squf;": "â–ª",
	"Sscr;": "ð’®",
	"sscr;": "ð“ˆ",
	"Star;": "â‹†",
	"star;": "â˜†",
	"subE;": "â«…",
	"sube;": "âŠ†",
	"succ;": "â‰»",
	"sung;": "â™ª",
	"sup1;": "Â¹",
	"sup2;": "Â²",
	"sup3;": "Â³",
	"supE;": "â«†",
	"supe;": "âŠ‡",
	szlig: "ÃŸ",
	"tbrk;": "âŽ´",
	"tdot;": "âƒ›",
	THORN: "Ãž",
	thorn: "Ã¾",
	times: "Ã—",
	"tint;": "âˆ­",
	"toea;": "â¤¨",
	"Topf;": "ð•‹",
	"topf;": "ð•¥",
	"tosa;": "â¤©",
	"trie;": "â‰œ",
	"Tscr;": "ð’¯",
	"tscr;": "ð“‰",
	"TScy;": "Ð¦",
	"tscy;": "Ñ†",
	"Uarr;": "â†Ÿ",
	"uArr;": "â‡‘",
	"uarr;": "â†‘",
	Ucirc: "Ã›",
	ucirc: "Ã»",
	"uHar;": "â¥£",
	"Uopf;": "ð•Œ",
	"uopf;": "ð•¦",
	"Upsi;": "Ï’",
	"upsi;": "Ï…",
	"Uscr;": "ð’°",
	"uscr;": "ð“Š",
	"utri;": "â–µ",
	"Uuml;": "Ãœ",
	"uuml;": "Ã¼",
	"vArr;": "â‡•",
	"varr;": "â†•",
	"Vbar;": "â««",
	"vBar;": "â«¨",
	"Vert;": "â€–",
	"vert;": "|",
	"Vopf;": "ð•",
	"vopf;": "ð•§",
	"Vscr;": "ð’±",
	"vscr;": "ð“‹",
	"Wopf;": "ð•Ž",
	"wopf;": "ð•¨",
	"Wscr;": "ð’²",
	"wscr;": "ð“Œ",
	"xcap;": "â‹‚",
	"xcup;": "â‹ƒ",
	"xmap;": "âŸ¼",
	"xnis;": "â‹»",
	"Xopf;": "ð•",
	"xopf;": "ð•©",
	"Xscr;": "ð’³",
	"xscr;": "ð“",
	"xvee;": "â‹",
	"YAcy;": "Ð¯",
	"yacy;": "Ñ",
	"YIcy;": "Ð‡",
	"yicy;": "Ñ—",
	"Yopf;": "ð•",
	"yopf;": "ð•ª",
	"Yscr;": "ð’´",
	"yscr;": "ð“Ž",
	"YUcy;": "Ð®",
	"yucy;": "ÑŽ",
	"Yuml;": "Å¸",
	"yuml;": "Ã¿",
	"Zdot;": "Å»",
	"zdot;": "Å¼",
	"Zeta;": "Î–",
	"zeta;": "Î¶",
	"ZHcy;": "Ð–",
	"zhcy;": "Ð¶",
	"Zopf;": "â„¤",
	"zopf;": "ð•«",
	"Zscr;": "ð’µ",
	"zscr;": "ð“",
	"zwnj;": "â€Œ",
	Aacute: "Ã",
	aacute: "Ã¡",
	"Acirc;": "Ã‚",
	"acirc;": "Ã¢",
	"acute;": "Â´",
	"AElig;": "Ã†",
	"aelig;": "Ã¦",
	Agrave: "Ã€",
	agrave: "Ã ",
	"aleph;": "â„µ",
	"Alpha;": "Î‘",
	"alpha;": "Î±",
	"Amacr;": "Ä€",
	"amacr;": "Ä",
	"amalg;": "â¨¿",
	"angle;": "âˆ ",
	"angrt;": "âˆŸ",
	"angst;": "Ã…",
	"Aogon;": "Ä„",
	"aogon;": "Ä…",
	"Aring;": "Ã…",
	"aring;": "Ã¥",
	"asymp;": "â‰ˆ",
	Atilde: "Ãƒ",
	atilde: "Ã£",
	"awint;": "â¨‘",
	"bcong;": "â‰Œ",
	"bdquo;": "â€ž",
	"bepsi;": "Ï¶",
	"blank;": "â£",
	"blk12;": "â–’",
	"blk14;": "â–‘",
	"blk34;": "â–“",
	"block;": "â–ˆ",
	"boxDL;": "â•—",
	"boxDl;": "â•–",
	"boxdL;": "â••",
	"boxdl;": "â”",
	"boxDR;": "â•”",
	"boxDr;": "â•“",
	"boxdR;": "â•’",
	"boxdr;": "â”Œ",
	"boxHD;": "â•¦",
	"boxHd;": "â•¤",
	"boxhD;": "â•¥",
	"boxhd;": "â”¬",
	"boxHU;": "â•©",
	"boxHu;": "â•§",
	"boxhU;": "â•¨",
	"boxhu;": "â”´",
	"boxUL;": "â•",
	"boxUl;": "â•œ",
	"boxuL;": "â•›",
	"boxul;": "â”˜",
	"boxUR;": "â•š",
	"boxUr;": "â•™",
	"boxuR;": "â•˜",
	"boxur;": "â””",
	"boxVH;": "â•¬",
	"boxVh;": "â•«",
	"boxvH;": "â•ª",
	"boxvh;": "â”¼",
	"boxVL;": "â•£",
	"boxVl;": "â•¢",
	"boxvL;": "â•¡",
	"boxvl;": "â”¤",
	"boxVR;": "â• ",
	"boxVr;": "â•Ÿ",
	"boxvR;": "â•ž",
	"boxvr;": "â”œ",
	"Breve;": "Ë˜",
	"breve;": "Ë˜",
	brvbar: "Â¦",
	"bsemi;": "â",
	"bsime;": "â‹",
	"bsolb;": "â§…",
	"bumpE;": "âª®",
	"bumpe;": "â‰",
	"caret;": "â",
	"caron;": "Ë‡",
	"ccaps;": "â©",
	Ccedil: "Ã‡",
	ccedil: "Ã§",
	"Ccirc;": "Äˆ",
	"ccirc;": "Ä‰",
	"ccups;": "â©Œ",
	"cedil;": "Â¸",
	"check;": "âœ“",
	"clubs;": "â™£",
	"Colon;": "âˆ·",
	"colon;": ":",
	"comma;": ",",
	"crarr;": "â†µ",
	"Cross;": "â¨¯",
	"cross;": "âœ—",
	"csube;": "â«‘",
	"csupe;": "â«’",
	"ctdot;": "â‹¯",
	"cuepr;": "â‹ž",
	"cuesc;": "â‹Ÿ",
	"cupor;": "â©…",
	curren: "Â¤",
	"cuvee;": "â‹Ž",
	"cuwed;": "â‹",
	"cwint;": "âˆ±",
	"Dashv;": "â«¤",
	"dashv;": "âŠ£",
	"dblac;": "Ë",
	"ddarr;": "â‡Š",
	"Delta;": "Î”",
	"delta;": "Î´",
	"dharl;": "â‡ƒ",
	"dharr;": "â‡‚",
	"diams;": "â™¦",
	"disin;": "â‹²",
	divide: "Ã·",
	"doteq;": "â‰",
	"dtdot;": "â‹±",
	"dtrif;": "â–¾",
	"duarr;": "â‡µ",
	"duhar;": "â¥¯",
	Eacute: "Ã‰",
	eacute: "Ã©",
	"Ecirc;": "ÃŠ",
	"ecirc;": "Ãª",
	"eDDot;": "â©·",
	"efDot;": "â‰’",
	Egrave: "Ãˆ",
	egrave: "Ã¨",
	"Emacr;": "Ä’",
	"emacr;": "Ä“",
	"empty;": "âˆ…",
	"Eogon;": "Ä˜",
	"eogon;": "Ä™",
	"eplus;": "â©±",
	"epsiv;": "Ïµ",
	"eqsim;": "â‰‚",
	"Equal;": "â©µ",
	"equiv;": "â‰¡",
	"erarr;": "â¥±",
	"erDot;": "â‰“",
	"esdot;": "â‰",
	"exist;": "âˆƒ",
	"fflig;": "ï¬€",
	"filig;": "ï¬",
	"fjlig;": "fj",
	"fllig;": "ï¬‚",
	"fltns;": "â–±",
	"forkv;": "â«™",
	frac12: "Â½",
	frac14: "Â¼",
	frac34: "Â¾",
	"frasl;": "â„",
	"frown;": "âŒ¢",
	"Gamma;": "Î“",
	"gamma;": "Î³",
	"Gcirc;": "Äœ",
	"gcirc;": "Ä",
	"gescc;": "âª©",
	"gimel;": "â„·",
	"gneqq;": "â‰©",
	"gnsim;": "â‹§",
	"grave;": "`",
	"gsime;": "âªŽ",
	"gsiml;": "âª",
	"gtcir;": "â©º",
	"gtdot;": "â‹—",
	"Hacek;": "Ë‡",
	"harrw;": "â†­",
	"Hcirc;": "Ä¤",
	"hcirc;": "Ä¥",
	"hoarr;": "â‡¿",
	Iacute: "Ã",
	iacute: "Ã­",
	"Icirc;": "ÃŽ",
	"icirc;": "Ã®",
	"iexcl;": "Â¡",
	Igrave: "ÃŒ",
	igrave: "Ã¬",
	"iiint;": "âˆ­",
	"iiota;": "â„©",
	"IJlig;": "Ä²",
	"ijlig;": "Ä³",
	"Imacr;": "Äª",
	"imacr;": "Ä«",
	"image;": "â„‘",
	"imath;": "Ä±",
	"imped;": "Æµ",
	"infin;": "âˆž",
	"Iogon;": "Ä®",
	"iogon;": "Ä¯",
	"iprod;": "â¨¼",
	iquest: "Â¿",
	"isinE;": "â‹¹",
	"isins;": "â‹´",
	"isinv;": "âˆˆ",
	"Iukcy;": "Ð†",
	"iukcy;": "Ñ–",
	"Jcirc;": "Ä´",
	"jcirc;": "Äµ",
	"jmath;": "È·",
	"Jukcy;": "Ð„",
	"jukcy;": "Ñ”",
	"Kappa;": "Îš",
	"kappa;": "Îº",
	"lAarr;": "â‡š",
	"langd;": "â¦‘",
	"laquo;": "Â«",
	"larrb;": "â‡¤",
	"lates;": "âª­ï¸€",
	"lBarr;": "â¤Ž",
	"lbarr;": "â¤Œ",
	"lbbrk;": "â²",
	"lbrke;": "â¦‹",
	"lceil;": "âŒˆ",
	"ldquo;": "â€œ",
	"lescc;": "âª¨",
	"lhard;": "â†½",
	"lharu;": "â†¼",
	"lhblk;": "â–„",
	"llarr;": "â‡‡",
	"lltri;": "â—º",
	"lneqq;": "â‰¨",
	"lnsim;": "â‹¦",
	"loang;": "âŸ¬",
	"loarr;": "â‡½",
	"lobrk;": "âŸ¦",
	"lopar;": "â¦…",
	"lrarr;": "â‡†",
	"lrhar;": "â‡‹",
	"lrtri;": "âŠ¿",
	"lsime;": "âª",
	"lsimg;": "âª",
	"lsquo;": "â€˜",
	"ltcir;": "â©¹",
	"ltdot;": "â‹–",
	"ltrie;": "âŠ´",
	"ltrif;": "â—‚",
	"mdash;": "â€”",
	"mDDot;": "âˆº",
	"micro;": "Âµ",
	middot: "Â·",
	"minus;": "âˆ’",
	"mumap;": "âŠ¸",
	"nabla;": "âˆ‡",
	"napid;": "â‰‹Ì¸",
	"napos;": "Å‰",
	"natur;": "â™®",
	"nbump;": "â‰ŽÌ¸",
	"ncong;": "â‰‡",
	"ndash;": "â€“",
	"neArr;": "â‡—",
	"nearr;": "â†—",
	"nedot;": "â‰Ì¸",
	"nesim;": "â‰‚Ì¸",
	"ngeqq;": "â‰§Ì¸",
	"ngsim;": "â‰µ",
	"nhArr;": "â‡Ž",
	"nharr;": "â†®",
	"nhpar;": "â«²",
	"nlArr;": "â‡",
	"nlarr;": "â†š",
	"nleqq;": "â‰¦Ì¸",
	"nless;": "â‰®",
	"nlsim;": "â‰´",
	"nltri;": "â‹ª",
	"notin;": "âˆ‰",
	"notni;": "âˆŒ",
	"npart;": "âˆ‚Ì¸",
	"nprec;": "âŠ€",
	"nrArr;": "â‡",
	"nrarr;": "â†›",
	"nrtri;": "â‹«",
	"nsime;": "â‰„",
	"nsmid;": "âˆ¤",
	"nspar;": "âˆ¦",
	"nsubE;": "â«…Ì¸",
	"nsube;": "âŠˆ",
	"nsucc;": "âŠ",
	"nsupE;": "â«†Ì¸",
	"nsupe;": "âŠ‰",
	Ntilde: "Ã‘",
	ntilde: "Ã±",
	"numsp;": "â€‡",
	"nvsim;": "âˆ¼âƒ’",
	"nwArr;": "â‡–",
	"nwarr;": "â†–",
	Oacute: "Ã“",
	oacute: "Ã³",
	"Ocirc;": "Ã”",
	"ocirc;": "Ã´",
	"odash;": "âŠ",
	"OElig;": "Å’",
	"oelig;": "Å“",
	"ofcir;": "â¦¿",
	Ograve: "Ã’",
	ograve: "Ã²",
	"ohbar;": "â¦µ",
	"olarr;": "â†º",
	"olcir;": "â¦¾",
	"oline;": "â€¾",
	"Omacr;": "ÅŒ",
	"omacr;": "Å",
	"Omega;": "Î©",
	"omega;": "Ï‰",
	"operp;": "â¦¹",
	"oplus;": "âŠ•",
	"orarr;": "â†»",
	"order;": "â„´",
	Oslash: "Ã˜",
	oslash: "Ã¸",
	Otilde: "Ã•",
	otilde: "Ãµ",
	"ovbar;": "âŒ½",
	"parsl;": "â«½",
	"phone;": "â˜Ž",
	"plusb;": "âŠž",
	"pluse;": "â©²",
	plusmn: "Â±",
	"pound;": "Â£",
	"prcue;": "â‰¼",
	"Prime;": "â€³",
	"prime;": "â€²",
	"prnap;": "âª¹",
	"prsim;": "â‰¾",
	"quest;": "?",
	"rAarr;": "â‡›",
	"radic;": "âˆš",
	"rangd;": "â¦’",
	"range;": "â¦¥",
	"raquo;": "Â»",
	"rarrb;": "â‡¥",
	"rarrc;": "â¤³",
	"rarrw;": "â†",
	"ratio;": "âˆ¶",
	"RBarr;": "â¤",
	"rBarr;": "â¤",
	"rbarr;": "â¤",
	"rbbrk;": "â³",
	"rbrke;": "â¦Œ",
	"rceil;": "âŒ‰",
	"rdquo;": "â€",
	"reals;": "â„",
	"rhard;": "â‡",
	"rharu;": "â‡€",
	"rlarr;": "â‡„",
	"rlhar;": "â‡Œ",
	"rnmid;": "â«®",
	"roang;": "âŸ­",
	"roarr;": "â‡¾",
	"robrk;": "âŸ§",
	"ropar;": "â¦†",
	"rrarr;": "â‡‰",
	"rsquo;": "â€™",
	"rtrie;": "âŠµ",
	"rtrif;": "â–¸",
	"sbquo;": "â€š",
	"sccue;": "â‰½",
	"Scirc;": "Åœ",
	"scirc;": "Å",
	"scnap;": "âªº",
	"scsim;": "â‰¿",
	"sdotb;": "âŠ¡",
	"sdote;": "â©¦",
	"seArr;": "â‡˜",
	"searr;": "â†˜",
	"setmn;": "âˆ–",
	"sharp;": "â™¯",
	"Sigma;": "Î£",
	"sigma;": "Ïƒ",
	"simeq;": "â‰ƒ",
	"simgE;": "âª ",
	"simlE;": "âªŸ",
	"simne;": "â‰†",
	"slarr;": "â†",
	"smile;": "âŒ£",
	"smtes;": "âª¬ï¸€",
	"sqcap;": "âŠ“",
	"sqcup;": "âŠ”",
	"sqsub;": "âŠ",
	"sqsup;": "âŠ",
	"srarr;": "â†’",
	"starf;": "â˜…",
	"strns;": "Â¯",
	"subnE;": "â«‹",
	"subne;": "âŠŠ",
	"supnE;": "â«Œ",
	"supne;": "âŠ‹",
	"swArr;": "â‡™",
	"swarr;": "â†™",
	"szlig;": "ÃŸ",
	"Theta;": "Î˜",
	"theta;": "Î¸",
	"thkap;": "â‰ˆ",
	"THORN;": "Ãž",
	"thorn;": "Ã¾",
	"Tilde;": "âˆ¼",
	"tilde;": "Ëœ",
	"times;": "Ã—",
	"TRADE;": "â„¢",
	"trade;": "â„¢",
	"trisb;": "â§",
	"TSHcy;": "Ð‹",
	"tshcy;": "Ñ›",
	"twixt;": "â‰¬",
	Uacute: "Ãš",
	uacute: "Ãº",
	"Ubrcy;": "ÐŽ",
	"ubrcy;": "Ñž",
	"Ucirc;": "Ã›",
	"ucirc;": "Ã»",
	"udarr;": "â‡…",
	"udhar;": "â¥®",
	Ugrave: "Ã™",
	ugrave: "Ã¹",
	"uharl;": "â†¿",
	"uharr;": "â†¾",
	"uhblk;": "â–€",
	"ultri;": "â—¸",
	"Umacr;": "Åª",
	"umacr;": "Å«",
	"Union;": "â‹ƒ",
	"Uogon;": "Å²",
	"uogon;": "Å³",
	"uplus;": "âŠŽ",
	"upsih;": "Ï’",
	"UpTee;": "âŠ¥",
	"Uring;": "Å®",
	"uring;": "Å¯",
	"urtri;": "â—¹",
	"utdot;": "â‹°",
	"utrif;": "â–´",
	"uuarr;": "â‡ˆ",
	"varpi;": "Ï–",
	"vBarv;": "â«©",
	"VDash;": "âŠ«",
	"Vdash;": "âŠ©",
	"vDash;": "âŠ¨",
	"vdash;": "âŠ¢",
	"veeeq;": "â‰š",
	"vltri;": "âŠ²",
	"vnsub;": "âŠ‚âƒ’",
	"vnsup;": "âŠƒâƒ’",
	"vprop;": "âˆ",
	"vrtri;": "âŠ³",
	"Wcirc;": "Å´",
	"wcirc;": "Åµ",
	"Wedge;": "â‹€",
	"wedge;": "âˆ§",
	"xcirc;": "â—¯",
	"xdtri;": "â–½",
	"xhArr;": "âŸº",
	"xharr;": "âŸ·",
	"xlArr;": "âŸ¸",
	"xlarr;": "âŸµ",
	"xodot;": "â¨€",
	"xrArr;": "âŸ¹",
	"xrarr;": "âŸ¶",
	"xutri;": "â–³",
	Yacute: "Ã",
	yacute: "Ã½",
	"Ycirc;": "Å¶",
	"ycirc;": "Å·",
	"Aacute;": "Ã",
	"aacute;": "Ã¡",
	"Abreve;": "Ä‚",
	"abreve;": "Äƒ",
	"Agrave;": "Ã€",
	"agrave;": "Ã ",
	"andand;": "â©•",
	"angmsd;": "âˆ¡",
	"angsph;": "âˆ¢",
	"apacir;": "â©¯",
	"approx;": "â‰ˆ",
	"Assign;": "â‰”",
	"Atilde;": "Ãƒ",
	"atilde;": "Ã£",
	"barvee;": "âŠ½",
	"Barwed;": "âŒ†",
	"barwed;": "âŒ…",
	"becaus;": "âˆµ",
	"bernou;": "â„¬",
	"bigcap;": "â‹‚",
	"bigcup;": "â‹ƒ",
	"bigvee;": "â‹",
	"bkarow;": "â¤",
	"bottom;": "âŠ¥",
	"bowtie;": "â‹ˆ",
	"boxbox;": "â§‰",
	"bprime;": "â€µ",
	"brvbar;": "Â¦",
	"bullet;": "â€¢",
	"Bumpeq;": "â‰Ž",
	"bumpeq;": "â‰",
	"Cacute;": "Ä†",
	"cacute;": "Ä‡",
	"capand;": "â©„",
	"capcap;": "â©‹",
	"capcup;": "â©‡",
	"capdot;": "â©€",
	"Ccaron;": "ÄŒ",
	"ccaron;": "Ä",
	"Ccedil;": "Ã‡",
	"ccedil;": "Ã§",
	"circeq;": "â‰—",
	"cirmid;": "â«¯",
	"Colone;": "â©´",
	"colone;": "â‰”",
	"commat;": "@",
	"compfn;": "âˆ˜",
	"Conint;": "âˆ¯",
	"conint;": "âˆ®",
	"coprod;": "âˆ",
	"copysr;": "â„—",
	"cularr;": "â†¶",
	"CupCap;": "â‰",
	"cupcap;": "â©†",
	"cupcup;": "â©Š",
	"cupdot;": "âŠ",
	"curarr;": "â†·",
	"curren;": "Â¤",
	"cylcty;": "âŒ­",
	"Dagger;": "â€¡",
	"dagger;": "â€ ",
	"daleth;": "â„¸",
	"Dcaron;": "ÄŽ",
	"dcaron;": "Ä",
	"dfisht;": "â¥¿",
	"divide;": "Ã·",
	"divonx;": "â‹‡",
	"dlcorn;": "âŒž",
	"dlcrop;": "âŒ",
	"dollar;": "$",
	"DotDot;": "âƒœ",
	"drcorn;": "âŒŸ",
	"drcrop;": "âŒŒ",
	"Dstrok;": "Ä",
	"dstrok;": "Ä‘",
	"Eacute;": "Ã‰",
	"eacute;": "Ã©",
	"easter;": "â©®",
	"Ecaron;": "Äš",
	"ecaron;": "Ä›",
	"ecolon;": "â‰•",
	"Egrave;": "Ãˆ",
	"egrave;": "Ã¨",
	"egsdot;": "âª˜",
	"elsdot;": "âª—",
	"emptyv;": "âˆ…",
	"emsp13;": "â€„",
	"emsp14;": "â€…",
	"eparsl;": "â§£",
	"eqcirc;": "â‰–",
	"equals;": "=",
	"equest;": "â‰Ÿ",
	"Exists;": "âˆƒ",
	"female;": "â™€",
	"ffilig;": "ï¬ƒ",
	"ffllig;": "ï¬„",
	"ForAll;": "âˆ€",
	"forall;": "âˆ€",
	"frac12;": "Â½",
	"frac13;": "â…“",
	"frac14;": "Â¼",
	"frac15;": "â…•",
	"frac16;": "â…™",
	"frac18;": "â…›",
	"frac23;": "â…”",
	"frac25;": "â…–",
	"frac34;": "Â¾",
	"frac35;": "â…—",
	"frac38;": "â…œ",
	"frac45;": "â…˜",
	"frac56;": "â…š",
	"frac58;": "â…",
	"frac78;": "â…ž",
	"gacute;": "Çµ",
	"Gammad;": "Ïœ",
	"gammad;": "Ï",
	"Gbreve;": "Äž",
	"gbreve;": "ÄŸ",
	"Gcedil;": "Ä¢",
	"gesdot;": "âª€",
	"gesles;": "âª”",
	"gtlPar;": "â¦•",
	"gtrarr;": "â¥¸",
	"gtrdot;": "â‹—",
	"gtrsim;": "â‰³",
	"hairsp;": "â€Š",
	"hamilt;": "â„‹",
	"HARDcy;": "Ðª",
	"hardcy;": "ÑŠ",
	"hearts;": "â™¥",
	"hellip;": "â€¦",
	"hercon;": "âŠ¹",
	"homtht;": "âˆ»",
	"horbar;": "â€•",
	"hslash;": "â„",
	"Hstrok;": "Ä¦",
	"hstrok;": "Ä§",
	"hybull;": "âƒ",
	"hyphen;": "â€",
	"Iacute;": "Ã",
	"iacute;": "Ã­",
	"Igrave;": "ÃŒ",
	"igrave;": "Ã¬",
	"iiiint;": "â¨Œ",
	"iinfin;": "â§œ",
	"incare;": "â„…",
	"inodot;": "Ä±",
	"intcal;": "âŠº",
	"iquest;": "Â¿",
	"isinsv;": "â‹³",
	"Itilde;": "Ä¨",
	"itilde;": "Ä©",
	"Jsercy;": "Ðˆ",
	"jsercy;": "Ñ˜",
	"kappav;": "Ï°",
	"Kcedil;": "Ä¶",
	"kcedil;": "Ä·",
	"kgreen;": "Ä¸",
	"Lacute;": "Ä¹",
	"lacute;": "Äº",
	"lagran;": "â„’",
	"Lambda;": "Î›",
	"lambda;": "Î»",
	"langle;": "âŸ¨",
	"larrfs;": "â¤",
	"larrhk;": "â†©",
	"larrlp;": "â†«",
	"larrpl;": "â¤¹",
	"larrtl;": "â†¢",
	"lAtail;": "â¤›",
	"latail;": "â¤™",
	"lbrace;": "{",
	"lbrack;": "[",
	"Lcaron;": "Ä½",
	"lcaron;": "Ä¾",
	"Lcedil;": "Ä»",
	"lcedil;": "Ä¼",
	"ldquor;": "â€ž",
	"lesdot;": "â©¿",
	"lesges;": "âª“",
	"lfisht;": "â¥¼",
	"lfloor;": "âŒŠ",
	"lharul;": "â¥ª",
	"llhard;": "â¥«",
	"Lmidot;": "Ä¿",
	"lmidot;": "Å€",
	"lmoust;": "âŽ°",
	"loplus;": "â¨­",
	"lowast;": "âˆ—",
	"lowbar;": "_",
	"lparlt;": "â¦“",
	"lrhard;": "â¥­",
	"lsaquo;": "â€¹",
	"lsquor;": "â€š",
	"Lstrok;": "Å",
	"lstrok;": "Å‚",
	"lthree;": "â‹‹",
	"ltimes;": "â‹‰",
	"ltlarr;": "â¥¶",
	"ltrPar;": "â¦–",
	"mapsto;": "â†¦",
	"marker;": "â–®",
	"mcomma;": "â¨©",
	"midast;": "*",
	"midcir;": "â«°",
	"middot;": "Â·",
	"minusb;": "âŠŸ",
	"minusd;": "âˆ¸",
	"mnplus;": "âˆ“",
	"models;": "âŠ§",
	"mstpos;": "âˆ¾",
	"Nacute;": "Åƒ",
	"nacute;": "Å„",
	"nbumpe;": "â‰Ì¸",
	"Ncaron;": "Å‡",
	"ncaron;": "Åˆ",
	"Ncedil;": "Å…",
	"ncedil;": "Å†",
	"nearhk;": "â¤¤",
	"nequiv;": "â‰¢",
	"nesear;": "â¤¨",
	"nexist;": "âˆ„",
	"nltrie;": "â‹¬",
	"notinE;": "â‹¹Ì¸",
	"nparsl;": "â«½âƒ¥",
	"nprcue;": "â‹ ",
	"nrarrc;": "â¤³Ì¸",
	"nrarrw;": "â†Ì¸",
	"nrtrie;": "â‹­",
	"nsccue;": "â‹¡",
	"nsimeq;": "â‰„",
	"Ntilde;": "Ã‘",
	"ntilde;": "Ã±",
	"numero;": "â„–",
	"nVDash;": "âŠ¯",
	"nVdash;": "âŠ®",
	"nvDash;": "âŠ­",
	"nvdash;": "âŠ¬",
	"nvHarr;": "â¤„",
	"nvlArr;": "â¤‚",
	"nvrArr;": "â¤ƒ",
	"nwarhk;": "â¤£",
	"nwnear;": "â¤§",
	"Oacute;": "Ã“",
	"oacute;": "Ã³",
	"Odblac;": "Å",
	"odblac;": "Å‘",
	"odsold;": "â¦¼",
	"Ograve;": "Ã’",
	"ograve;": "Ã²",
	"ominus;": "âŠ–",
	"origof;": "âŠ¶",
	"Oslash;": "Ã˜",
	"oslash;": "Ã¸",
	"Otilde;": "Ã•",
	"otilde;": "Ãµ",
	"Otimes;": "â¨·",
	"otimes;": "âŠ—",
	"parsim;": "â«³",
	"percnt;": "%",
	"period;": ".",
	"permil;": "â€°",
	"phmmat;": "â„³",
	"planck;": "â„",
	"plankv;": "â„",
	"plusdo;": "âˆ”",
	"plusdu;": "â¨¥",
	"plusmn;": "Â±",
	"preceq;": "âª¯",
	"primes;": "â„™",
	"prnsim;": "â‹¨",
	"propto;": "âˆ",
	"prurel;": "âŠ°",
	"puncsp;": "â€ˆ",
	"qprime;": "â—",
	"Racute;": "Å”",
	"racute;": "Å•",
	"rangle;": "âŸ©",
	"rarrap;": "â¥µ",
	"rarrfs;": "â¤ž",
	"rarrhk;": "â†ª",
	"rarrlp;": "â†¬",
	"rarrpl;": "â¥…",
	"Rarrtl;": "â¤–",
	"rarrtl;": "â†£",
	"rAtail;": "â¤œ",
	"ratail;": "â¤š",
	"rbrace;": "}",
	"rbrack;": "]",
	"Rcaron;": "Å˜",
	"rcaron;": "Å™",
	"Rcedil;": "Å–",
	"rcedil;": "Å—",
	"rdquor;": "â€",
	"rfisht;": "â¥½",
	"rfloor;": "âŒ‹",
	"rharul;": "â¥¬",
	"rmoust;": "âŽ±",
	"roplus;": "â¨®",
	"rpargt;": "â¦”",
	"rsaquo;": "â€º",
	"rsquor;": "â€™",
	"rthree;": "â‹Œ",
	"rtimes;": "â‹Š",
	"Sacute;": "Åš",
	"sacute;": "Å›",
	"Scaron;": "Å ",
	"scaron;": "Å¡",
	"Scedil;": "Åž",
	"scedil;": "ÅŸ",
	"scnsim;": "â‹©",
	"searhk;": "â¤¥",
	"seswar;": "â¤©",
	"sfrown;": "âŒ¢",
	"SHCHcy;": "Ð©",
	"shchcy;": "Ñ‰",
	"sigmaf;": "Ï‚",
	"sigmav;": "Ï‚",
	"simdot;": "â©ª",
	"smashp;": "â¨³",
	"SOFTcy;": "Ð¬",
	"softcy;": "ÑŒ",
	"solbar;": "âŒ¿",
	"spades;": "â™ ",
	"sqcaps;": "âŠ“ï¸€",
	"sqcups;": "âŠ”ï¸€",
	"sqsube;": "âŠ‘",
	"sqsupe;": "âŠ’",
	"Square;": "â–¡",
	"square;": "â–¡",
	"squarf;": "â–ª",
	"ssetmn;": "âˆ–",
	"ssmile;": "âŒ£",
	"sstarf;": "â‹†",
	"subdot;": "âª½",
	"Subset;": "â‹",
	"subset;": "âŠ‚",
	"subsim;": "â«‡",
	"subsub;": "â«•",
	"subsup;": "â«“",
	"succeq;": "âª°",
	"supdot;": "âª¾",
	"Supset;": "â‹‘",
	"supset;": "âŠƒ",
	"supsim;": "â«ˆ",
	"supsub;": "â«”",
	"supsup;": "â«–",
	"swarhk;": "â¤¦",
	"swnwar;": "â¤ª",
	"target;": "âŒ–",
	"Tcaron;": "Å¤",
	"tcaron;": "Å¥",
	"Tcedil;": "Å¢",
	"tcedil;": "Å£",
	"telrec;": "âŒ•",
	"there4;": "âˆ´",
	"thetav;": "Ï‘",
	"thinsp;": "â€‰",
	"thksim;": "âˆ¼",
	"timesb;": "âŠ ",
	"timesd;": "â¨°",
	"topbot;": "âŒ¶",
	"topcir;": "â«±",
	"tprime;": "â€´",
	"tridot;": "â—¬",
	"Tstrok;": "Å¦",
	"tstrok;": "Å§",
	"Uacute;": "Ãš",
	"uacute;": "Ãº",
	"Ubreve;": "Å¬",
	"ubreve;": "Å­",
	"Udblac;": "Å°",
	"udblac;": "Å±",
	"ufisht;": "â¥¾",
	"Ugrave;": "Ã™",
	"ugrave;": "Ã¹",
	"ulcorn;": "âŒœ",
	"ulcrop;": "âŒ",
	"urcorn;": "âŒ",
	"urcrop;": "âŒŽ",
	"Utilde;": "Å¨",
	"utilde;": "Å©",
	"vangrt;": "â¦œ",
	"varphi;": "Ï•",
	"varrho;": "Ï±",
	"Vdashl;": "â«¦",
	"veebar;": "âŠ»",
	"vellip;": "â‹®",
	"Verbar;": "â€–",
	"verbar;": "|",
	"vsubnE;": "â«‹ï¸€",
	"vsubne;": "âŠŠï¸€",
	"vsupnE;": "â«Œï¸€",
	"vsupne;": "âŠ‹ï¸€",
	"Vvdash;": "âŠª",
	"wedbar;": "â©Ÿ",
	"wedgeq;": "â‰™",
	"weierp;": "â„˜",
	"wreath;": "â‰€",
	"xoplus;": "â¨",
	"xotime;": "â¨‚",
	"xsqcup;": "â¨†",
	"xuplus;": "â¨„",
	"xwedge;": "â‹€",
	"Yacute;": "Ã",
	"yacute;": "Ã½",
	"Zacute;": "Å¹",
	"zacute;": "Åº",
	"Zcaron;": "Å½",
	"zcaron;": "Å¾",
	"zeetrf;": "â„¨",
	"alefsym;": "â„µ",
	"angrtvb;": "âŠ¾",
	"angzarr;": "â¼",
	"asympeq;": "â‰",
	"backsim;": "âˆ½",
	"Because;": "âˆµ",
	"because;": "âˆµ",
	"bemptyv;": "â¦°",
	"between;": "â‰¬",
	"bigcirc;": "â—¯",
	"bigodot;": "â¨€",
	"bigstar;": "â˜…",
	"bnequiv;": "â‰¡âƒ¥",
	"boxplus;": "âŠž",
	"Cayleys;": "â„­",
	"Cconint;": "âˆ°",
	"ccupssm;": "â©",
	"Cedilla;": "Â¸",
	"cemptyv;": "â¦²",
	"cirscir;": "â§‚",
	"coloneq;": "â‰”",
	"congdot;": "â©­",
	"cudarrl;": "â¤¸",
	"cudarrr;": "â¤µ",
	"cularrp;": "â¤½",
	"curarrm;": "â¤¼",
	"dbkarow;": "â¤",
	"ddagger;": "â€¡",
	"ddotseq;": "â©·",
	"demptyv;": "â¦±",
	"Diamond;": "â‹„",
	"diamond;": "â‹„",
	"digamma;": "Ï",
	"dotplus;": "âˆ”",
	"DownTee;": "âŠ¤",
	"dwangle;": "â¦¦",
	"Element;": "âˆˆ",
	"Epsilon;": "Î•",
	"epsilon;": "Îµ",
	"eqcolon;": "â‰•",
	"equivDD;": "â©¸",
	"gesdoto;": "âª‚",
	"gtquest;": "â©¼",
	"gtrless;": "â‰·",
	"harrcir;": "â¥ˆ",
	"Implies;": "â‡’",
	"intprod;": "â¨¼",
	"isindot;": "â‹µ",
	"larrbfs;": "â¤Ÿ",
	"larrsim;": "â¥³",
	"lbrksld;": "â¦",
	"lbrkslu;": "â¦",
	"ldrdhar;": "â¥§",
	"LeftTee;": "âŠ£",
	"lesdoto;": "âª",
	"lessdot;": "â‹–",
	"lessgtr;": "â‰¶",
	"lesssim;": "â‰²",
	"lotimes;": "â¨´",
	"lozenge;": "â—Š",
	"ltquest;": "â©»",
	"luruhar;": "â¥¦",
	"maltese;": "âœ ",
	"minusdu;": "â¨ª",
	"napprox;": "â‰‰",
	"natural;": "â™®",
	"nearrow;": "â†—",
	"NewLine;": "\n",
	"nexists;": "âˆ„",
	"NoBreak;": "â ",
	"notinva;": "âˆ‰",
	"notinvb;": "â‹·",
	"notinvc;": "â‹¶",
	"NotLess;": "â‰®",
	"notniva;": "âˆŒ",
	"notnivb;": "â‹¾",
	"notnivc;": "â‹½",
	"npolint;": "â¨”",
	"npreceq;": "âª¯Ì¸",
	"nsqsube;": "â‹¢",
	"nsqsupe;": "â‹£",
	"nsubset;": "âŠ‚âƒ’",
	"nsucceq;": "âª°Ì¸",
	"nsupset;": "âŠƒâƒ’",
	"nvinfin;": "â§ž",
	"nvltrie;": "âŠ´âƒ’",
	"nvrtrie;": "âŠµâƒ’",
	"nwarrow;": "â†–",
	"olcross;": "â¦»",
	"Omicron;": "ÎŸ",
	"omicron;": "Î¿",
	"orderof;": "â„´",
	"orslope;": "â©—",
	"OverBar;": "â€¾",
	"pertenk;": "â€±",
	"planckh;": "â„Ž",
	"pluscir;": "â¨¢",
	"plussim;": "â¨¦",
	"plustwo;": "â¨§",
	"precsim;": "â‰¾",
	"Product;": "âˆ",
	"quatint;": "â¨–",
	"questeq;": "â‰Ÿ",
	"rarrbfs;": "â¤ ",
	"rarrsim;": "â¥´",
	"rbrksld;": "â¦Ž",
	"rbrkslu;": "â¦",
	"rdldhar;": "â¥©",
	"realine;": "â„›",
	"rotimes;": "â¨µ",
	"ruluhar;": "â¥¨",
	"searrow;": "â†˜",
	"simplus;": "â¨¤",
	"simrarr;": "â¥²",
	"subedot;": "â«ƒ",
	"submult;": "â«",
	"subplus;": "âª¿",
	"subrarr;": "â¥¹",
	"succsim;": "â‰¿",
	"supdsub;": "â«˜",
	"supedot;": "â«„",
	"suphsol;": "âŸ‰",
	"suphsub;": "â«—",
	"suplarr;": "â¥»",
	"supmult;": "â«‚",
	"supplus;": "â«€",
	"swarrow;": "â†™",
	"topfork;": "â«š",
	"triplus;": "â¨¹",
	"tritime;": "â¨»",
	"UpArrow;": "â†‘",
	"Uparrow;": "â‡‘",
	"uparrow;": "â†‘",
	"Upsilon;": "Î¥",
	"upsilon;": "Ï…",
	"uwangle;": "â¦§",
	"vzigzag;": "â¦š",
	"zigrarr;": "â‡",
	"andslope;": "â©˜",
	"angmsdaa;": "â¦¨",
	"angmsdab;": "â¦©",
	"angmsdac;": "â¦ª",
	"angmsdad;": "â¦«",
	"angmsdae;": "â¦¬",
	"angmsdaf;": "â¦­",
	"angmsdag;": "â¦®",
	"angmsdah;": "â¦¯",
	"angrtvbd;": "â¦",
	"approxeq;": "â‰Š",
	"awconint;": "âˆ³",
	"backcong;": "â‰Œ",
	"barwedge;": "âŒ…",
	"bbrktbrk;": "âŽ¶",
	"bigoplus;": "â¨",
	"bigsqcup;": "â¨†",
	"biguplus;": "â¨„",
	"bigwedge;": "â‹€",
	"boxminus;": "âŠŸ",
	"boxtimes;": "âŠ ",
	"bsolhsub;": "âŸˆ",
	"capbrcup;": "â©‰",
	"circledR;": "Â®",
	"circledS;": "â“ˆ",
	"cirfnint;": "â¨",
	"clubsuit;": "â™£",
	"cupbrcap;": "â©ˆ",
	"curlyvee;": "â‹Ž",
	"cwconint;": "âˆ²",
	"DDotrahd;": "â¤‘",
	"doteqdot;": "â‰‘",
	"DotEqual;": "â‰",
	"dotminus;": "âˆ¸",
	"drbkarow;": "â¤",
	"dzigrarr;": "âŸ¿",
	"elinters;": "â§",
	"emptyset;": "âˆ…",
	"eqvparsl;": "â§¥",
	"fpartint;": "â¨",
	"geqslant;": "â©¾",
	"gesdotol;": "âª„",
	"gnapprox;": "âªŠ",
	"hksearow;": "â¤¥",
	"hkswarow;": "â¤¦",
	"imagline;": "â„",
	"imagpart;": "â„‘",
	"infintie;": "â§",
	"integers;": "â„¤",
	"Integral;": "âˆ«",
	"intercal;": "âŠº",
	"intlarhk;": "â¨—",
	"laemptyv;": "â¦´",
	"ldrushar;": "â¥‹",
	"leqslant;": "â©½",
	"lesdotor;": "âªƒ",
	"LessLess;": "âª¡",
	"llcorner;": "âŒž",
	"lnapprox;": "âª‰",
	"lrcorner;": "âŒŸ",
	"lurdshar;": "â¥Š",
	"mapstoup;": "â†¥",
	"multimap;": "âŠ¸",
	"naturals;": "â„•",
	"ncongdot;": "â©­Ì¸",
	"NotEqual;": "â‰ ",
	"notindot;": "â‹µÌ¸",
	"NotTilde;": "â‰",
	"otimesas;": "â¨¶",
	"parallel;": "âˆ¥",
	"PartialD;": "âˆ‚",
	"plusacir;": "â¨£",
	"pointint;": "â¨•",
	"Precedes;": "â‰º",
	"precneqq;": "âªµ",
	"precnsim;": "â‹¨",
	"profalar;": "âŒ®",
	"profline;": "âŒ’",
	"profsurf;": "âŒ“",
	"raemptyv;": "â¦³",
	"realpart;": "â„œ",
	"RightTee;": "âŠ¢",
	"rppolint;": "â¨’",
	"rtriltri;": "â§Ž",
	"scpolint;": "â¨“",
	"setminus;": "âˆ–",
	"shortmid;": "âˆ£",
	"smeparsl;": "â§¤",
	"sqsubset;": "âŠ",
	"sqsupset;": "âŠ",
	"subseteq;": "âŠ†",
	"Succeeds;": "â‰»",
	"succneqq;": "âª¶",
	"succnsim;": "â‹©",
	"SuchThat;": "âˆ‹",
	"Superset;": "âŠƒ",
	"supseteq;": "âŠ‡",
	"thetasym;": "Ï‘",
	"thicksim;": "âˆ¼",
	"timesbar;": "â¨±",
	"triangle;": "â–µ",
	"triminus;": "â¨º",
	"trpezium;": "â¢",
	"Uarrocir;": "â¥‰",
	"ulcorner;": "âŒœ",
	"UnderBar;": "_",
	"urcorner;": "âŒ",
	"varkappa;": "Ï°",
	"varsigma;": "Ï‚",
	"vartheta;": "Ï‘",
	"backprime;": "â€µ",
	"backsimeq;": "â‹",
	"Backslash;": "âˆ–",
	"bigotimes;": "â¨‚",
	"CenterDot;": "Â·",
	"centerdot;": "Â·",
	"checkmark;": "âœ“",
	"CircleDot;": "âŠ™",
	"complexes;": "â„‚",
	"Congruent;": "â‰¡",
	"Coproduct;": "âˆ",
	"dotsquare;": "âŠ¡",
	"DoubleDot;": "Â¨",
	"DownArrow;": "â†“",
	"Downarrow;": "â‡“",
	"downarrow;": "â†“",
	"DownBreve;": "Ì‘",
	"gtrapprox;": "âª†",
	"gtreqless;": "â‹›",
	"gvertneqq;": "â‰©ï¸€",
	"heartsuit;": "â™¥",
	"HumpEqual;": "â‰",
	"LeftArrow;": "â†",
	"Leftarrow;": "â‡",
	"leftarrow;": "â†",
	"LeftFloor;": "âŒŠ",
	"lesseqgtr;": "â‹š",
	"LessTilde;": "â‰²",
	"lvertneqq;": "â‰¨ï¸€",
	"Mellintrf;": "â„³",
	"MinusPlus;": "âˆ“",
	"ngeqslant;": "â©¾Ì¸",
	"nleqslant;": "â©½Ì¸",
	"NotCupCap;": "â‰­",
	"NotExists;": "âˆ„",
	"NotSubset;": "âŠ‚âƒ’",
	"nparallel;": "âˆ¦",
	"nshortmid;": "âˆ¤",
	"nsubseteq;": "âŠˆ",
	"nsupseteq;": "âŠ‰",
	"OverBrace;": "âž",
	"pitchfork;": "â‹”",
	"PlusMinus;": "Â±",
	"rationals;": "â„š",
	"spadesuit;": "â™ ",
	"subseteqq;": "â«…",
	"subsetneq;": "âŠŠ",
	"supseteqq;": "â«†",
	"supsetneq;": "âŠ‹",
	"Therefore;": "âˆ´",
	"therefore;": "âˆ´",
	"ThinSpace;": "â€‰",
	"triangleq;": "â‰œ",
	"TripleDot;": "âƒ›",
	"UnionPlus;": "âŠŽ",
	"varpropto;": "âˆ",
	"Bernoullis;": "â„¬",
	"circledast;": "âŠ›",
	"CirclePlus;": "âŠ•",
	"complement;": "âˆ",
	"curlywedge;": "â‹",
	"eqslantgtr;": "âª–",
	"EqualTilde;": "â‰‚",
	"Fouriertrf;": "â„±",
	"gtreqqless;": "âªŒ",
	"ImaginaryI;": "â…ˆ",
	"Laplacetrf;": "â„’",
	"LeftVector;": "â†¼",
	"lessapprox;": "âª…",
	"lesseqqgtr;": "âª‹",
	"Lleftarrow;": "â‡š",
	"lmoustache;": "âŽ°",
	"longmapsto;": "âŸ¼",
	"mapstodown;": "â†§",
	"mapstoleft;": "â†¤",
	"nLeftarrow;": "â‡",
	"nleftarrow;": "â†š",
	"NotElement;": "âˆ‰",
	"NotGreater;": "â‰¯",
	"nsubseteqq;": "â«…Ì¸",
	"nsupseteqq;": "â«†Ì¸",
	"precapprox;": "âª·",
	"Proportion;": "âˆ·",
	"RightArrow;": "â†’",
	"Rightarrow;": "â‡’",
	"rightarrow;": "â†’",
	"RightFloor;": "âŒ‹",
	"rmoustache;": "âŽ±",
	"sqsubseteq;": "âŠ‘",
	"sqsupseteq;": "âŠ’",
	"subsetneqq;": "â«‹",
	"succapprox;": "âª¸",
	"supsetneqq;": "â«Œ",
	"ThickSpace;": "âŸâ€Š",
	"TildeEqual;": "â‰ƒ",
	"TildeTilde;": "â‰ˆ",
	"UnderBrace;": "âŸ",
	"UpArrowBar;": "â¤’",
	"UpTeeArrow;": "â†¥",
	"upuparrows;": "â‡ˆ",
	"varepsilon;": "Ïµ",
	"varnothing;": "âˆ…",
	"backepsilon;": "Ï¶",
	"blacksquare;": "â–ª",
	"circledcirc;": "âŠš",
	"circleddash;": "âŠ",
	"CircleMinus;": "âŠ–",
	"CircleTimes;": "âŠ—",
	"curlyeqprec;": "â‹ž",
	"curlyeqsucc;": "â‹Ÿ",
	"diamondsuit;": "â™¦",
	"eqslantless;": "âª•",
	"Equilibrium;": "â‡Œ",
	"expectation;": "â„°",
	"GreaterLess;": "â‰·",
	"LeftCeiling;": "âŒˆ",
	"LessGreater;": "â‰¶",
	"MediumSpace;": "âŸ",
	"NotLessLess;": "â‰ªÌ¸",
	"NotPrecedes;": "âŠ€",
	"NotSucceeds;": "âŠ",
	"NotSuperset;": "âŠƒâƒ’",
	"nRightarrow;": "â‡",
	"nrightarrow;": "â†›",
	"OverBracket;": "âŽ´",
	"preccurlyeq;": "â‰¼",
	"precnapprox;": "âª¹",
	"quaternions;": "â„",
	"RightVector;": "â‡€",
	"Rrightarrow;": "â‡›",
	"RuleDelayed;": "â§´",
	"SmallCircle;": "âˆ˜",
	"SquareUnion;": "âŠ”",
	"straightphi;": "Ï•",
	"SubsetEqual;": "âŠ†",
	"succcurlyeq;": "â‰½",
	"succnapprox;": "âªº",
	"thickapprox;": "â‰ˆ",
	"UpDownArrow;": "â†•",
	"Updownarrow;": "â‡•",
	"updownarrow;": "â†•",
	"VerticalBar;": "âˆ£",
	"blacklozenge;": "â§«",
	"DownArrowBar;": "â¤“",
	"DownTeeArrow;": "â†§",
	"ExponentialE;": "â…‡",
	"exponentiale;": "â…‡",
	"GreaterEqual;": "â‰¥",
	"GreaterTilde;": "â‰³",
	"HilbertSpace;": "â„‹",
	"HumpDownHump;": "â‰Ž",
	"Intersection;": "â‹‚",
	"LeftArrowBar;": "â‡¤",
	"LeftTeeArrow;": "â†¤",
	"LeftTriangle;": "âŠ²",
	"LeftUpVector;": "â†¿",
	"NotCongruent;": "â‰¢",
	"NotHumpEqual;": "â‰Ì¸",
	"NotLessEqual;": "â‰°",
	"NotLessTilde;": "â‰´",
	"Proportional;": "âˆ",
	"RightCeiling;": "âŒ‰",
	"risingdotseq;": "â‰“",
	"RoundImplies;": "â¥°",
	"ShortUpArrow;": "â†‘",
	"SquareSubset;": "âŠ",
	"triangledown;": "â–¿",
	"triangleleft;": "â—ƒ",
	"UnderBracket;": "âŽµ",
	"varsubsetneq;": "âŠŠï¸€",
	"varsupsetneq;": "âŠ‹ï¸€",
	"VerticalLine;": "|",
	"ApplyFunction;": "â¡",
	"bigtriangleup;": "â–³",
	"blacktriangle;": "â–´",
	"DifferentialD;": "â…†",
	"divideontimes;": "â‹‡",
	"DoubleLeftTee;": "â«¤",
	"DoubleUpArrow;": "â‡‘",
	"fallingdotseq;": "â‰’",
	"hookleftarrow;": "â†©",
	"leftarrowtail;": "â†¢",
	"leftharpoonup;": "â†¼",
	"LeftTeeVector;": "â¥š",
	"LeftVectorBar;": "â¥’",
	"LessFullEqual;": "â‰¦",
	"LongLeftArrow;": "âŸµ",
	"Longleftarrow;": "âŸ¸",
	"longleftarrow;": "âŸµ",
	"looparrowleft;": "â†«",
	"measuredangle;": "âˆ¡",
	"NotEqualTilde;": "â‰‚Ì¸",
	"NotTildeEqual;": "â‰„",
	"NotTildeTilde;": "â‰‰",
	"ntriangleleft;": "â‹ª",
	"Poincareplane;": "â„Œ",
	"PrecedesEqual;": "âª¯",
	"PrecedesTilde;": "â‰¾",
	"RightArrowBar;": "â‡¥",
	"RightTeeArrow;": "â†¦",
	"RightTriangle;": "âŠ³",
	"RightUpVector;": "â†¾",
	"shortparallel;": "âˆ¥",
	"smallsetminus;": "âˆ–",
	"SucceedsEqual;": "âª°",
	"SucceedsTilde;": "â‰¿",
	"SupersetEqual;": "âŠ‡",
	"triangleright;": "â–¹",
	"UpEquilibrium;": "â¥®",
	"upharpoonleft;": "â†¿",
	"varsubsetneqq;": "â«‹ï¸€",
	"varsupsetneqq;": "â«Œï¸€",
	"VerticalTilde;": "â‰€",
	"VeryThinSpace;": "â€Š",
	"curvearrowleft;": "â†¶",
	"DiacriticalDot;": "Ë™",
	"doublebarwedge;": "âŒ†",
	"DoubleRightTee;": "âŠ¨",
	"downdownarrows;": "â‡Š",
	"DownLeftVector;": "â†½",
	"GreaterGreater;": "âª¢",
	"hookrightarrow;": "â†ª",
	"HorizontalLine;": "â”€",
	"InvisibleComma;": "â£",
	"InvisibleTimes;": "â¢",
	"LeftDownVector;": "â‡ƒ",
	"leftleftarrows;": "â‡‡",
	"LeftRightArrow;": "â†”",
	"Leftrightarrow;": "â‡”",
	"leftrightarrow;": "â†”",
	"leftthreetimes;": "â‹‹",
	"LessSlantEqual;": "â©½",
	"LongRightArrow;": "âŸ¶",
	"Longrightarrow;": "âŸ¹",
	"longrightarrow;": "âŸ¶",
	"looparrowright;": "â†¬",
	"LowerLeftArrow;": "â†™",
	"NestedLessLess;": "â‰ª",
	"NotGreaterLess;": "â‰¹",
	"NotLessGreater;": "â‰¸",
	"NotSubsetEqual;": "âŠˆ",
	"NotVerticalBar;": "âˆ¤",
	"nshortparallel;": "âˆ¦",
	"ntriangleright;": "â‹«",
	"OpenCurlyQuote;": "â€˜",
	"ReverseElement;": "âˆ‹",
	"rightarrowtail;": "â†£",
	"rightharpoonup;": "â‡€",
	"RightTeeVector;": "â¥›",
	"RightVectorBar;": "â¥“",
	"ShortDownArrow;": "â†“",
	"ShortLeftArrow;": "â†",
	"SquareSuperset;": "âŠ",
	"TildeFullEqual;": "â‰…",
	"trianglelefteq;": "âŠ´",
	"upharpoonright;": "â†¾",
	"UpperLeftArrow;": "â†–",
	"ZeroWidthSpace;": "â€‹",
	"bigtriangledown;": "â–½",
	"circlearrowleft;": "â†º",
	"CloseCurlyQuote;": "â€™",
	"ContourIntegral;": "âˆ®",
	"curvearrowright;": "â†·",
	"DoubleDownArrow;": "â‡“",
	"DoubleLeftArrow;": "â‡",
	"downharpoonleft;": "â‡ƒ",
	"DownRightVector;": "â‡",
	"leftharpoondown;": "â†½",
	"leftrightarrows;": "â‡†",
	"LeftRightVector;": "â¥Ž",
	"LeftTriangleBar;": "â§",
	"LeftUpTeeVector;": "â¥ ",
	"LeftUpVectorBar;": "â¥˜",
	"LowerRightArrow;": "â†˜",
	"nLeftrightarrow;": "â‡Ž",
	"nleftrightarrow;": "â†®",
	"NotGreaterEqual;": "â‰±",
	"NotGreaterTilde;": "â‰µ",
	"NotHumpDownHump;": "â‰ŽÌ¸",
	"NotLeftTriangle;": "â‹ª",
	"NotSquareSubset;": "âŠÌ¸",
	"ntrianglelefteq;": "â‹¬",
	"OverParenthesis;": "âœ",
	"RightDownVector;": "â‡‚",
	"rightleftarrows;": "â‡„",
	"rightsquigarrow;": "â†",
	"rightthreetimes;": "â‹Œ",
	"ShortRightArrow;": "â†’",
	"straightepsilon;": "Ïµ",
	"trianglerighteq;": "âŠµ",
	"UpperRightArrow;": "â†—",
	"vartriangleleft;": "âŠ²",
	"circlearrowright;": "â†»",
	"DiacriticalAcute;": "Â´",
	"DiacriticalGrave;": "`",
	"DiacriticalTilde;": "Ëœ",
	"DoubleRightArrow;": "â‡’",
	"DownArrowUpArrow;": "â‡µ",
	"downharpoonright;": "â‡‚",
	"EmptySmallSquare;": "â—»",
	"GreaterEqualLess;": "â‹›",
	"GreaterFullEqual;": "â‰§",
	"LeftAngleBracket;": "âŸ¨",
	"LeftUpDownVector;": "â¥‘",
	"LessEqualGreater;": "â‹š",
	"NonBreakingSpace;": "Â ",
	"NotPrecedesEqual;": "âª¯Ì¸",
	"NotRightTriangle;": "â‹«",
	"NotSucceedsEqual;": "âª°Ì¸",
	"NotSucceedsTilde;": "â‰¿Ì¸",
	"NotSupersetEqual;": "âŠ‰",
	"ntrianglerighteq;": "â‹­",
	"rightharpoondown;": "â‡",
	"rightrightarrows;": "â‡‰",
	"RightTriangleBar;": "â§",
	"RightUpTeeVector;": "â¥œ",
	"RightUpVectorBar;": "â¥”",
	"twoheadleftarrow;": "â†ž",
	"UnderParenthesis;": "â",
	"UpArrowDownArrow;": "â‡…",
	"vartriangleright;": "âŠ³",
	"blacktriangledown;": "â–¾",
	"blacktriangleleft;": "â—‚",
	"DoubleUpDownArrow;": "â‡•",
	"DoubleVerticalBar;": "âˆ¥",
	"DownLeftTeeVector;": "â¥ž",
	"DownLeftVectorBar;": "â¥–",
	"FilledSmallSquare;": "â—¼",
	"GreaterSlantEqual;": "â©¾",
	"LeftDoubleBracket;": "âŸ¦",
	"LeftDownTeeVector;": "â¥¡",
	"LeftDownVectorBar;": "â¥™",
	"leftrightharpoons;": "â‡‹",
	"LeftTriangleEqual;": "âŠ´",
	"NegativeThinSpace;": "â€‹",
	"NotGreaterGreater;": "â‰«Ì¸",
	"NotLessSlantEqual;": "â©½Ì¸",
	"NotNestedLessLess;": "âª¡Ì¸",
	"NotReverseElement;": "âˆŒ",
	"NotSquareSuperset;": "âŠÌ¸",
	"NotTildeFullEqual;": "â‰‡",
	"RightAngleBracket;": "âŸ©",
	"rightleftharpoons;": "â‡Œ",
	"RightUpDownVector;": "â¥",
	"SquareSubsetEqual;": "âŠ‘",
	"twoheadrightarrow;": "â† ",
	"VerticalSeparator;": "â˜",
	"blacktriangleright;": "â–¸",
	"DownRightTeeVector;": "â¥Ÿ",
	"DownRightVectorBar;": "â¥—",
	"LongLeftRightArrow;": "âŸ·",
	"Longleftrightarrow;": "âŸº",
	"longleftrightarrow;": "âŸ·",
	"NegativeThickSpace;": "â€‹",
	"NotLeftTriangleBar;": "â§Ì¸",
	"PrecedesSlantEqual;": "â‰¼",
	"ReverseEquilibrium;": "â‡‹",
	"RightDoubleBracket;": "âŸ§",
	"RightDownTeeVector;": "â¥",
	"RightDownVectorBar;": "â¥•",
	"RightTriangleEqual;": "âŠµ",
	"SquareIntersection;": "âŠ“",
	"SucceedsSlantEqual;": "â‰½",
	"DoubleLongLeftArrow;": "âŸ¸",
	"DownLeftRightVector;": "â¥",
	"LeftArrowRightArrow;": "â‡†",
	"leftrightsquigarrow;": "â†­",
	"NegativeMediumSpace;": "â€‹",
	"NotGreaterFullEqual;": "â‰§Ì¸",
	"NotRightTriangleBar;": "â§Ì¸",
	"RightArrowLeftArrow;": "â‡„",
	"SquareSupersetEqual;": "âŠ’",
	"CapitalDifferentialD;": "â……",
	"DoubleLeftRightArrow;": "â‡”",
	"DoubleLongRightArrow;": "âŸ¹",
	"EmptyVerySmallSquare;": "â–«",
	"NestedGreaterGreater;": "â‰«",
	"NotDoubleVerticalBar;": "âˆ¦",
	"NotGreaterSlantEqual;": "â©¾Ì¸",
	"NotLeftTriangleEqual;": "â‹¬",
	"NotSquareSubsetEqual;": "â‹¢",
	"OpenCurlyDoubleQuote;": "â€œ",
	"ReverseUpEquilibrium;": "â¥¯",
	"CloseCurlyDoubleQuote;": "â€",
	"DoubleContourIntegral;": "âˆ¯",
	"FilledVerySmallSquare;": "â–ª",
	"NegativeVeryThinSpace;": "â€‹",
	"NotPrecedesSlantEqual;": "â‹ ",
	"NotRightTriangleEqual;": "â‹­",
	"NotSucceedsSlantEqual;": "â‹¡",
	"DiacriticalDoubleAcute;": "Ë",
	"NotSquareSupersetEqual;": "â‹£",
	"NotNestedGreaterGreater;": "âª¢Ì¸",
	"ClockwiseContourIntegral;": "âˆ²",
	"DoubleLongLeftRightArrow;": "âŸº",
	"CounterClockwiseContourIntegral;": "âˆ³"
};

// lazy compute this to make this file tree-shakable for browser
let maxCRNameLength;
const decodeHtml = (rawText, asAttr) => {
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (!head || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value = undefined;
            if (/[0-9a-z]/i.test(rawText[1])) {
                if (!maxCRNameLength) {
                    maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
                }
                for (let length = maxCRNameLength; !value && length > 0; --length) {
                    name = rawText.slice(1, 1 + length);
                    value = namedCharacterReferences[name];
                }
                if (value) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test(rawText[name.length + 1] || '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (!body) {
                decodedText += head[0];
                advance(head[0].length);
            }
            else {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = CCR_REPLACEMENTS[cp] || cp;
                }
                decodedText += String.fromCodePoint(cp);
                advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178
};

const isRawTextContainer = /*#__PURE__*/ shared.makeMap('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: shared.isVoidTag,
    isNativeTag: tag => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: (tag) => {
        if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
        }
        else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* TextModes.RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* TextModes.RAWTEXT */;
            }
        }
        return 0 /* TextModes.DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* NodeTypes.DIRECTIVE */,
                    name: `bind`,
                    arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = shared.parseStringStyle(cssText);
    return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return compilerCore.createCompilerError(code, loc, DOMErrorMessages );
}
const DOMErrorMessages = {
    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp
                ? compilerCore.getConstantType(exp, context) > 0
                    ? exp
                    : compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc)
                : compilerCore.createSimpleExpression('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = compilerCore.transformModel(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = compilerCore.findProp(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = compilerCore.findProp(node, `type`);
            if (type) {
                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if (compilerCore.hasDynamicKeyVBind(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ shared.makeMap(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ shared.makeMap(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ shared.makeMap('left,right');
const isKeyboardEvent = /*#__PURE__*/ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if (compilerCore.isStaticExp(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? compilerCore.createSimpleExpression(event, true)
        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
            ? compilerCore.createCompoundExpression([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return compilerCore.transformOn(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join('');
            key = compilerCore.isStaticExp(key)
                ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [compilerCore.createObjectProperty(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const transformTransition = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (!node.children.length) {
                    return;
                }
                // warn multiple transition children
                if (hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
                // check if it's s single child w/ v-show
                // if yes, inject "persisted: true" to the transition props
                const child = node.children[0];
                if (child.type === 1 /* NodeTypes.ELEMENT */) {
                    for (const p of child.props) {
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {
                            node.props.push({
                                type: 6 /* NodeTypes.ATTRIBUTE */,
                                name: 'persisted',
                                value: undefined,
                                loc: node.loc
                            });
                        }
                    }
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&
        !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* NodeTypes.FOR */ ||
        (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));
}

/**
 * This module is Node-only.
 */
/**
 * Regex for replacing placeholders for embedded constant variables
 * (e.g. import URL string constants generated by compiler-sfc)
 */
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
/**
 * Turn eligible hoisted static trees into stringified static nodes, e.g.
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 *
 * A single static vnode can contain stringified content for **multiple**
 * consecutive nodes (element and plain text), called a "chunk".
 * `@vue/runtime-dom` will create the content via innerHTML in a hidden
 * container element and insert all the nodes in place. The call must also
 * provide the number of nodes contained in the chunk so that during hydration
 * we can know how many nodes the static vnode should adopt.
 *
 * The optimization scans a children list that contains hoisted nodes, and
 * tries to find the largest chunk of consecutive hoisted nodes before running
 * into a non-hoisted node or the end of the list. A chunk is then converted
 * into a single static vnode and replaces the hoisted expression of the first
 * node in the chunk. Other nodes in the chunk are considered "merged" and
 * therefore removed from both the hoist list and the children array.
 *
 * This optimization is only performed in Node.js.
 */
const stringifyStatic = (children, context, parent) => {
    // bail stringification for slot content
    if (context.scopes.vSlot > 0) {
        return;
    }
    let nc = 0; // current node count
    let ec = 0; // current element with binding count
    const currentChunk = [];
    const stringifyCurrentChunk = (currentIndex) => {
        if (nc >= 20 /* StringifyThresholds.NODE_COUNT */ ||
            ec >= 5 /* StringifyThresholds.ELEMENT_WITH_BINDING_COUNT */) {
            // combine all currently eligible nodes into a single static vnode call
            const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
                JSON.stringify(currentChunk.map(node => stringifyNode(node, context)).join('')).replace(expReplaceRE, `" + $1 + "`),
                // the 2nd argument indicates the number of DOM nodes this static vnode
                // will insert / hydrate
                String(currentChunk.length)
            ]);
            // replace the first node's hoisted expression with the static vnode call
            replaceHoist(currentChunk[0], staticCall, context);
            if (currentChunk.length > 1) {
                for (let i = 1; i < currentChunk.length; i++) {
                    // for the merged nodes, set their hoisted expression to null
                    replaceHoist(currentChunk[i], null, context);
                }
                // also remove merged nodes from children
                const deleteCount = currentChunk.length - 1;
                children.splice(currentIndex - currentChunk.length + 1, deleteCount);
                return deleteCount;
            }
        }
        return 0;
    };
    let i = 0;
    for (; i < children.length; i++) {
        const child = children[i];
        const hoisted = getHoistedNode(child);
        if (hoisted) {
            // presence of hoisted means child must be a stringifiable node
            const node = child;
            const result = analyzeNode(node);
            if (result) {
                // node is stringifiable, record state
                nc += result[0];
                ec += result[1];
                currentChunk.push(node);
                continue;
            }
        }
        // we only reach here if we ran into a node that is not stringifiable
        // check if currently analyzed nodes meet criteria for stringification.
        // adjust iteration index
        i -= stringifyCurrentChunk(i);
        // reset state
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
    }
    // in case the last node was also stringifiable
    stringifyCurrentChunk(i);
};
const getHoistedNode = (node) => ((node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */) ||
    node.type == 12 /* NodeTypes.TEXT_CALL */) &&
    node.codegenNode &&
    node.codegenNode.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
    node.codegenNode.hoisted;
const dataAriaRE = /^(data|aria)-/;
const isStringifiableAttr = (name, ns) => {
    return ((ns === 0 /* DOMNamespaces.HTML */
        ? shared.isKnownHtmlAttr(name)
        : ns === 1 /* DOMNamespaces.SVG */
            ? shared.isKnownSvgAttr(name)
            : false) || dataAriaRE.test(name));
};
const replaceHoist = (node, replacement, context) => {
    const hoistToReplace = node.codegenNode.hoisted;
    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
};
const isNonStringifiable = /*#__PURE__*/ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
/**
 * for a hoisted node, analyze it and return:
 * - false: bailed (contains non-stringifiable props or runtime constant)
 * - [nc, ec] where
 *   - nc is the number of nodes inside
 *   - ec is the number of element with bindings inside
 */
function analyzeNode(node) {
    if (node.type === 1 /* NodeTypes.ELEMENT */ && isNonStringifiable(node.tag)) {
        return false;
    }
    if (node.type === 12 /* NodeTypes.TEXT_CALL */) {
        return [1, 0];
    }
    let nc = 1; // node count
    let ec = node.props.length > 0 ? 1 : 0; // element w/ binding count
    let bailed = false;
    const bail = () => {
        bailed = true;
        return false;
    };
    // TODO: check for cases where using innerHTML will result in different
    // output compared to imperative node insertions.
    // probably only need to check for most common case
    // i.e. non-phrasing-content tags inside `<p>`
    function walk(node) {
        for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            // bail on non-attr bindings
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                !isStringifiableAttr(p.name, node.ns)) {
                return bail();
            }
            if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind') {
                // bail on non-attr bindings
                if (p.arg &&
                    (p.arg.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ ||
                        (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))) {
                    return bail();
                }
                if (p.exp &&
                    (p.exp.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ ||
                        p.exp.constType < 3 /* ConstantTypes.CAN_STRINGIFY */)) {
                    return bail();
                }
            }
        }
        for (let i = 0; i < node.children.length; i++) {
            nc++;
            const child = node.children[i];
            if (child.type === 1 /* NodeTypes.ELEMENT */) {
                if (child.props.length > 0) {
                    ec++;
                }
                walk(child);
                if (bailed) {
                    return false;
                }
            }
        }
        return true;
    }
    return walk(node) ? [nc, ec] : false;
}
function stringifyNode(node, context) {
    if (shared.isString(node)) {
        return node;
    }
    if (shared.isSymbol(node)) {
        return ``;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            return stringifyElement(node, context);
        case 2 /* NodeTypes.TEXT */:
            return shared.escapeHtml(node.content);
        case 3 /* NodeTypes.COMMENT */:
            return `<!--${shared.escapeHtml(node.content)}-->`;
        case 5 /* NodeTypes.INTERPOLATION */:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            return shared.escapeHtml(evaluateConstant(node));
        case 12 /* NodeTypes.TEXT_CALL */:
            return stringifyNode(node.content, context);
        default:
            // static trees will not contain if/for nodes
            return '';
    }
}
function stringifyElement(node, context) {
    let res = `<${node.tag}`;
    let innerHTML = '';
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            res += ` ${p.name}`;
            if (p.value) {
                res += `="${shared.escapeHtml(p.value.content)}"`;
            }
        }
        else if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
            if (p.name === 'bind') {
                const exp = p.exp;
                if (exp.content[0] === '_') {
                    // internally generated string constant references
                    // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
                    res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
                    continue;
                }
                // #6568
                if (shared.isBooleanAttr(p.arg.content) &&
                    exp.content === 'false') {
                    continue;
                }
                // constant v-bind, e.g. :foo="1"
                let evaluated = evaluateConstant(exp);
                if (evaluated != null) {
                    const arg = p.arg && p.arg.content;
                    if (arg === 'class') {
                        evaluated = shared.normalizeClass(evaluated);
                    }
                    else if (arg === 'style') {
                        evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
                    }
                    res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
                }
            }
            else if (p.name === 'html') {
                // #5439 v-html with constant value
                // not sure why would anyone do this but it can happen
                innerHTML = evaluateConstant(p.exp);
            }
            else if (p.name === 'text') {
                innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p.exp)));
            }
        }
    }
    if (context.scopeId) {
        res += ` ${context.scopeId}`;
    }
    res += `>`;
    if (innerHTML) {
        res += innerHTML;
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            res += stringifyNode(node.children[i], context);
        }
    }
    if (!shared.isVoidTag(node.tag)) {
        res += `</${node.tag}>`;
    }
    return res;
}
// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transforms/transformExpression)
function evaluateConstant(exp) {
    if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        return new Function(`return ${exp.content}`)();
    }
    else {
        // compound
        let res = ``;
        exp.children.forEach(c => {
            if (shared.isString(c) || shared.isSymbol(c)) {
                return;
            }
            if (c.type === 2 /* NodeTypes.TEXT */) {
                res += c.content;
            }
            else if (c.type === 5 /* NodeTypes.INTERPOLATION */) {
                res += shared.toDisplayString(evaluateConstant(c.content));
            }
            else {
                res += evaluateConstant(c);
            }
        });
        return res;
    }
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...([transformTransition] )
];
const DOMDirectiveTransforms = {
    cloak: compilerCore.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: stringifyStatic
    }));
}
function parse(template, options = {}) {
    return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
}

exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
exports.DOMNodeTransforms = DOMNodeTransforms;
exports.TRANSITION = TRANSITION;
exports.TRANSITION_GROUP = TRANSITION_GROUP;
exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
exports.V_MODEL_RADIO = V_MODEL_RADIO;
exports.V_MODEL_SELECT = V_MODEL_SELECT;
exports.V_MODEL_TEXT = V_MODEL_TEXT;
exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
exports.V_SHOW = V_SHOW;
exports.compile = compile;
exports.createDOMCompilerError = createDOMCompilerError;
exports.parse = parse;
exports.parserOptions = parserOptions;
exports.transformStyle = transformStyle;
Object.keys(compilerCore).forEach(function(k) {
  if (k !== 'default') exports[k] = compilerCore[k];
});
¨/LICENSEÅCThe MIT License (MIT)

Copyright (c) 2018-present, Yuxi (Evan) You

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
·/dist/compiler-dom.d.tsÅcimport { CodegenResult } from '@vue/compiler-core';
import { CompilerError } from '@vue/compiler-core';
import { CompilerOptions } from '@vue/compiler-core';
import { DirectiveTransform } from '@vue/compiler-core';
import { NodeTransform } from '@vue/compiler-core';
import { ParserOptions } from '@vue/compiler-core';
import { RootNode } from '@vue/compiler-core';
import { SourceLocation } from '@vue/compiler-core';

export declare function compile(template: string, options?: CompilerOptions): CodegenResult;

export declare function createDOMCompilerError(code: DOMErrorCodes, loc?: SourceLocation): DOMCompilerError;

declare interface DOMCompilerError extends CompilerError {
    code: DOMErrorCodes;
}

export declare const DOMDirectiveTransforms: Record<string, DirectiveTransform>;

export declare const enum DOMErrorCodes {
    X_V_HTML_NO_EXPRESSION = 51,
    X_V_HTML_WITH_CHILDREN = 52,
    X_V_TEXT_NO_EXPRESSION = 53,
    X_V_TEXT_WITH_CHILDREN = 54,
    X_V_MODEL_ON_INVALID_ELEMENT = 55,
    X_V_MODEL_ARG_ON_ELEMENT = 56,
    X_V_MODEL_ON_FILE_INPUT_ELEMENT = 57,
    X_V_MODEL_UNNECESSARY_VALUE = 58,
    X_V_SHOW_NO_EXPRESSION = 59,
    X_TRANSITION_INVALID_CHILDREN = 60,
    X_IGNORED_SIDE_EFFECT_TAG = 61,
    __EXTEND_POINT__ = 62
}

export declare const DOMNodeTransforms: NodeTransform[];

export declare function parse(template: string, options?: ParserOptions): RootNode;

export declare const parserOptions: ParserOptions;

export declare const transformStyle: NodeTransform;

export declare const TRANSITION: unique symbol;

export declare const TRANSITION_GROUP: unique symbol;

export declare const V_MODEL_CHECKBOX: unique symbol;

export declare const V_MODEL_DYNAMIC: unique symbol;

export declare const V_MODEL_RADIO: unique symbol;

export declare const V_MODEL_SELECT: unique symbol;

export declare const V_MODEL_TEXT: unique symbol;

export declare const V_ON_WITH_KEYS: unique symbol;

export declare const V_ON_WITH_MODIFIERS: unique symbol;

export declare const V_SHOW: unique symbol;


export * from "@vue/compiler-core";

export { }
Ù!/dist/compiler-dom.global.prod.jsÅÞCvar VueCompilerDOM=function(e){"use strict";function t(e,t){const n=Object.create(null),o=e.split(",");for(let r=0;r<o.length;r++)n[o[r]]=!0;return t?e=>!!n[e.toLowerCase()]:e=>!!n[e]}const n=/;(?![^(]*\))/g,o=/:([^]+)/,r=/\/\*.*?\*\//gs;const s=t("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"),i=t("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"),c=t("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"),l={},a=()=>{},p=()=>!1,u=/^on[^a-z]/,f=e=>u.test(e),d=Object.assign,h=Array.isArray,m=e=>"string"==typeof e,g=e=>"symbol"==typeof e,y=e=>null!==e&&"object"==typeof e,v=t(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),S=t("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),b=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},E=/-(\w)/g,N=b((e=>e.replace(E,((e,t)=>t?t.toUpperCase():"")))),_=/\B([A-Z])/g,x=b((e=>e.replace(_,"-$1").toLowerCase())),T=b((e=>e.charAt(0).toUpperCase()+e.slice(1))),k=b((e=>e?`on${T(e)}`:""));function O(e){throw e}function C(e){}function I(e,t,n,o){const r=new SyntaxError(String(e));return r.code=e,r.loc=t,r}const M=Symbol(""),R=Symbol(""),P=Symbol(""),w=Symbol(""),$=Symbol(""),L=Symbol(""),V=Symbol(""),A=Symbol(""),D=Symbol(""),B=Symbol(""),F=Symbol(""),j=Symbol(""),H=Symbol(""),W=Symbol(""),K=Symbol(""),U=Symbol(""),J=Symbol(""),G=Symbol(""),z=Symbol(""),Y=Symbol(""),Z=Symbol(""),q=Symbol(""),X=Symbol(""),Q=Symbol(""),ee=Symbol(""),te=Symbol(""),ne=Symbol(""),oe=Symbol(""),re=Symbol(""),se=Symbol(""),ie=Symbol(""),ce=Symbol(""),le=Symbol(""),ae=Symbol(""),pe=Symbol(""),ue=Symbol(""),fe=Symbol(""),de=Symbol(""),he=Symbol(""),me={[M]:"Fragment",[R]:"Teleport",[P]:"Suspense",[w]:"KeepAlive",[$]:"BaseTransition",[L]:"openBlock",[V]:"createBlock",[A]:"createElementBlock",[D]:"createVNode",[B]:"createElementVNode",[F]:"createCommentVNode",[j]:"createTextVNode",[H]:"createStaticVNode",[W]:"resolveComponent",[K]:"resolveDynamicComponent",[U]:"resolveDirective",[J]:"resolveFilter",[G]:"withDirectives",[z]:"renderList",[Y]:"renderSlot",[Z]:"createSlots",[q]:"toDisplayString",[X]:"mergeProps",[Q]:"normalizeClass",[ee]:"normalizeStyle",[te]:"normalizeProps",[ne]:"guardReactiveProps",[oe]:"toHandlers",[re]:"camelize",[se]:"capitalize",[ie]:"toHandlerKey",[ce]:"setBlockTracking",[le]:"pushScopeId",[ae]:"popScopeId",[pe]:"withCtx",[ue]:"unref",[fe]:"isRef",[de]:"withMemo",[he]:"isMemoSame"};function ge(e){Object.getOwnPropertySymbols(e).forEach((t=>{me[t]=e[t]}))}const ye={source:"",start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function ve(e,t=ye){return{type:0,children:e,helpers:new Set,components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc:t}}function Se(e,t,n,o,r,s,i,c=!1,l=!1,a=!1,p=ye){return e&&(c?(e.helper(L),e.helper(Qe(e.inSSR,a))):e.helper(Xe(e.inSSR,a)),i&&e.helper(G)),{type:13,tag:t,props:n,children:o,patchFlag:r,dynamicProps:s,directives:i,isBlock:c,disableTracking:l,isComponent:a,loc:p}}function be(e,t=ye){return{type:17,loc:t,elements:e}}function Ee(e,t=ye){return{type:15,loc:t,properties:e}}function Ne(e,t){return{type:16,loc:ye,key:m(e)?_e(e,!0):e,value:t}}function _e(e,t=!1,n=ye,o=0){return{type:4,loc:n,content:e,isStatic:t,constType:t?3:o}}function xe(e,t=ye){return{type:8,loc:t,children:e}}function Te(e,t=[],n=ye){return{type:14,loc:n,callee:e,arguments:t}}function ke(e,t,n=!1,o=!1,r=ye){return{type:18,params:e,returns:t,newline:n,isSlot:o,loc:r}}function Oe(e,t,n,o=!0){return{type:19,test:e,consequent:t,alternate:n,newline:o,loc:ye}}function Ce(e,t,n=!1){return{type:20,index:e,value:t,isVNode:n,loc:ye}}function Ie(e){return{type:21,body:e,loc:ye}}const Me=e=>4===e.type&&e.isStatic,Re=(e,t)=>e===t||e===x(t);function Pe(e){return Re(e,"Teleport")?R:Re(e,"Suspense")?P:Re(e,"KeepAlive")?w:Re(e,"BaseTransition")?$:void 0}const we=/^\d|[^\$\w]/,$e=e=>!we.test(e),Le=/[A-Za-z_$\xA0-\uFFFF]/,Ve=/[\.\?\w$\xA0-\uFFFF]/,Ae=/\s+[.[]\s*|\s*[.[]\s+/g,De=e=>{e=e.trim().replace(Ae,(e=>e.trim()));let t=0,n=[],o=0,r=0,s=null;for(let i=0;i<e.length;i++){const c=e.charAt(i);switch(t){case 0:if("["===c)n.push(t),t=1,o++;else if("("===c)n.push(t),t=2,r++;else if(!(0===i?Le:Ve).test(c))return!1;break;case 1:"'"===c||'"'===c||"`"===c?(n.push(t),t=3,s=c):"["===c?o++:"]"===c&&(--o||(t=n.pop()));break;case 2:if("'"===c||'"'===c||"`"===c)n.push(t),t=3,s=c;else if("("===c)r++;else if(")"===c){if(i===e.length-1)return!1;--r||(t=n.pop())}break;case 3:c===s&&(t=n.pop(),s=null)}}return!o&&!r},Be=a,Fe=De;function je(e,t,n){const o={source:e.source.slice(t,t+n),start:He(e.start,e.source,t),end:e.end};return null!=n&&(o.end=He(e.start,e.source,t+n)),o}function He(e,t,n=t.length){return We(d({},e),t,n)}function We(e,t,n=t.length){let o=0,r=-1;for(let s=0;s<n;s++)10===t.charCodeAt(s)&&(o++,r=s);return e.offset+=n,e.line+=o,e.column=-1===r?e.column+n:n-r,e}function Ke(e,t,n=!1){for(let o=0;o<e.props.length;o++){const r=e.props[o];if(7===r.type&&(n||r.exp)&&(m(t)?r.name===t:t.test(r.name)))return r}}function Ue(e,t,n=!1,o=!1){for(let r=0;r<e.props.length;r++){const s=e.props[r];if(6===s.type){if(n)continue;if(s.name===t&&(s.value||o))return s}else if("bind"===s.name&&(s.exp||o)&&Je(s.arg,t))return s}}function Je(e,t){return!(!e||!Me(e)||e.content!==t)}function Ge(e){return e.props.some((e=>!(7!==e.type||"bind"!==e.name||e.arg&&4===e.arg.type&&e.arg.isStatic)))}function ze(e){return 5===e.type||2===e.type}function Ye(e){return 7===e.type&&"slot"===e.name}function Ze(e){return 1===e.type&&3===e.tagType}function qe(e){return 1===e.type&&2===e.tagType}function Xe(e,t){return e||t?D:B}function Qe(e,t){return e||t?V:A}const et=new Set([te,ne]);function tt(e,t=[]){if(e&&!m(e)&&14===e.type){const n=e.callee;if(!m(n)&&et.has(n))return tt(e.arguments[0],t.concat(e))}return[e,t]}function nt(e,t,n){let o,r,s=13===e.type?e.props:e.arguments[2],i=[];if(s&&!m(s)&&14===s.type){const e=tt(s);s=e[0],i=e[1],r=i[i.length-1]}if(null==s||m(s))o=Ee([t]);else if(14===s.type){const e=s.arguments[0];m(e)||15!==e.type?s.callee===oe?o=Te(n.helper(X),[Ee([t]),s]):s.arguments.unshift(Ee([t])):ot(t,e)||e.properties.unshift(t),!o&&(o=s)}else 15===s.type?(ot(t,s)||s.properties.unshift(t),o=s):(o=Te(n.helper(X),[Ee([t]),s]),r&&r.callee===ne&&(r=i[i.length-2]));13===e.type?r?r.arguments[0]=o:e.props=o:r?r.arguments[0]=o:e.arguments[2]=o}function ot(e,t){let n=!1;if(4===e.key.type){const o=e.key.content;n=t.properties.some((e=>4===e.key.type&&e.key.content===o))}return n}function rt(e,t){return`_${t}_${e.replace(/[^\w]/g,((t,n)=>"-"===t?"_":e.charCodeAt(n).toString()))}`}function st(e){return 14===e.type&&e.callee===de?e.arguments[1].returns:e}function it(e,{helper:t,removeHelper:n,inSSR:o}){e.isBlock||(e.isBlock=!0,n(Xe(o,e.isComponent)),t(L),t(Qe(o,e.isComponent)))}const ct={COMPILER_IS_ON_ELEMENT:{message:'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',link:"https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"},COMPILER_V_BIND_SYNC:{message:e=>`.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e}.sync\` should be changed to \`v-model:${e}\`.`,link:"https://v3-migration.vuejs.org/breaking-changes/v-model.html"},COMPILER_V_BIND_PROP:{message:".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."},COMPILER_V_BIND_OBJECT_ORDER:{message:'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',link:"https://v3-migration.vuejs.org/breaking-changes/v-bind.html"},COMPILER_V_ON_NATIVE:{message:".native modifier for v-on has been removed as is no longer necessary.",link:"https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"},COMPILER_V_IF_V_FOR_PRECEDENCE:{message:"v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",link:"https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"},COMPILER_NATIVE_TEMPLATE:{message:"<template> with no special directives will render as a native template element instead of its inner content in Vue 3."},COMPILER_INLINE_TEMPLATE:{message:'"inline-template" has been removed in Vue 3.',link:"https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"},COMPILER_FILTER:{message:'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',link:"https://v3-migration.vuejs.org/breaking-changes/filters.html"}};function lt(e,t){const n=t.options?t.options.compatConfig:t.compatConfig,o=n&&n[e];return"MODE"===e?o||3:o}function at(e,t){const n=lt("MODE",t),o=lt(e,t);return 3===n?!0===o:!1!==o}function pt(e,t,n,...o){return at(e,t)}const ut=/&(gt|lt|amp|apos|quot);/g,ft={gt:">",lt:"<",amp:"&",apos:"'",quot:'"'},dt={delimiters:["{{","}}"],getNamespace:()=>0,getTextMode:()=>0,isVoidTag:p,isPreTag:p,isCustomElement:p,decodeEntities:e=>e.replace(ut,((e,t)=>ft[t])),onError:O,onWarn:C,comments:!1};function ht(e,t={}){const n=function(e,t){const n=d({},dt);let o;for(o in t)n[o]=void 0===t[o]?dt[o]:t[o];return{options:n,column:1,line:1,offset:0,originalSource:e,source:e,inPre:!1,inVPre:!1,onWarn:n.onWarn}}(e,t),o=Ct(n);return ve(mt(n,0,[]),It(n,o))}function mt(e,t,n){const o=Mt(n),r=o?o.ns:0,s=[];for(;!Lt(e,t,n);){const i=e.source;let c;if(0===t||1===t)if(!e.inVPre&&Rt(i,e.options.delimiters[0]))c=Tt(e,t);else if(0===t&&"<"===i[0])if(1===i.length);else if("!"===i[1])c=Rt(i,"\x3c!--")?vt(e):Rt(i,"<!DOCTYPE")?St(e):Rt(i,"<![CDATA[")&&0!==r?yt(e,n):St(e);else if("/"===i[1])if(2===i.length);else{if(">"===i[2]){Pt(e,3);continue}if(/[a-z]/i.test(i[2])){Nt(e,1,o);continue}c=St(e)}else/[a-z]/i.test(i[1])?(c=bt(e,n),at("COMPILER_NATIVE_TEMPLATE",e)&&c&&"template"===c.tag&&!c.props.some((e=>7===e.type&&Et(e.name)))&&(c=c.children)):"?"===i[1]&&(c=St(e));if(c||(c=kt(e,t)),h(c))for(let e=0;e<c.length;e++)gt(s,c[e]);else gt(s,c)}let i=!1;if(2!==t&&1!==t){const t="preserve"!==e.options.whitespace;for(let n=0;n<s.length;n++){const o=s[n];if(2===o.type)if(e.inPre)o.content=o.content.replace(/\r\n/g,"\n");else if(/[^\t\r\n\f ]/.test(o.content))t&&(o.content=o.content.replace(/[\t\r\n\f ]+/g," "));else{const e=s[n-1],r=s[n+1];!e||!r||t&&(3===e.type&&3===r.type||3===e.type&&1===r.type||1===e.type&&3===r.type||1===e.type&&1===r.type&&/[\r\n]/.test(o.content))?(i=!0,s[n]=null):o.content=" "}else 3!==o.type||e.options.comments||(i=!0,s[n]=null)}if(e.inPre&&o&&e.options.isPreTag(o.tag)){const e=s[0];e&&2===e.type&&(e.content=e.content.replace(/^\r?\n/,""))}}return i?s.filter(Boolean):s}function gt(e,t){if(2===t.type){const n=Mt(e);if(n&&2===n.type&&n.loc.end.offset===t.loc.start.offset)return n.content+=t.content,n.loc.end=t.loc.end,void(n.loc.source+=t.loc.source)}e.push(t)}function yt(e,t){Pt(e,9);const n=mt(e,3,t);return 0===e.source.length||Pt(e,3),n}function vt(e){const t=Ct(e);let n;const o=/--(\!)?>/.exec(e.source);if(o){n=e.source.slice(4,o.index);const t=e.source.slice(0,o.index);let r=1,s=0;for(;-1!==(s=t.indexOf("\x3c!--",r));)Pt(e,s-r+1),r=s+1;Pt(e,o.index+o[0].length-r+1)}else n=e.source.slice(4),Pt(e,e.source.length);return{type:3,content:n,loc:It(e,t)}}function St(e){const t=Ct(e),n="?"===e.source[1]?1:2;let o;const r=e.source.indexOf(">");return-1===r?(o=e.source.slice(n),Pt(e,e.source.length)):(o=e.source.slice(n,r),Pt(e,r+1)),{type:3,content:o,loc:It(e,t)}}function bt(e,t){const n=e.inPre,o=e.inVPre,r=Mt(t),s=Nt(e,0,r),i=e.inPre&&!n,c=e.inVPre&&!o;if(s.isSelfClosing||e.options.isVoidTag(s.tag))return i&&(e.inPre=!1),c&&(e.inVPre=!1),s;t.push(s);const l=e.options.getTextMode(s,r),a=mt(e,l,t);t.pop();{const t=s.props.find((e=>6===e.type&&"inline-template"===e.name));if(t&&pt("COMPILER_INLINE_TEMPLATE",e)){const n=It(e,s.loc.end);t.value={type:2,content:n.source,loc:n}}}if(s.children=a,Vt(e.source,s.tag))Nt(e,1,r);else if(0===e.source.length&&"script"===s.tag.toLowerCase()){const e=a[0];e&&Rt(e.loc.source,"\x3c!--")}return s.loc=It(e,s.loc.start),i&&(e.inPre=!1),c&&(e.inVPre=!1),s}const Et=t("if,else,else-if,for,slot");function Nt(e,t,n){const o=Ct(e),r=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(e.source),s=r[1],i=e.options.getNamespace(s,n);Pt(e,r[0].length),wt(e);const c=Ct(e),l=e.source;e.options.isPreTag(s)&&(e.inPre=!0);let a=_t(e,t);0===t&&!e.inVPre&&a.some((e=>7===e.type&&"pre"===e.name))&&(e.inVPre=!0,d(e,c),e.source=l,a=_t(e,t).filter((e=>"v-pre"!==e.name)));let p=!1;if(0===e.source.length||(p=Rt(e.source,"/>"),Pt(e,p?2:1)),1===t)return;let u=0;return e.inVPre||("slot"===s?u=2:"template"===s?a.some((e=>7===e.type&&Et(e.name)))&&(u=3):function(e,t,n){const o=n.options;if(o.isCustomElement(e))return!1;if("component"===e||/^[A-Z]/.test(e)||Pe(e)||o.isBuiltInComponent&&o.isBuiltInComponent(e)||o.isNativeTag&&!o.isNativeTag(e))return!0;for(let r=0;r<t.length;r++){const e=t[r];if(6===e.type){if("is"===e.name&&e.value){if(e.value.content.startsWith("vue:"))return!0;if(pt("COMPILER_IS_ON_ELEMENT",n))return!0}}else{if("is"===e.name)return!0;if("bind"===e.name&&Je(e.arg,"is")&&pt("COMPILER_IS_ON_ELEMENT",n))return!0}}}(s,a,e)&&(u=1)),{type:1,ns:i,tag:s,tagType:u,props:a,isSelfClosing:p,children:[],loc:It(e,o),codegenNode:void 0}}function _t(e,t){const n=[],o=new Set;for(;e.source.length>0&&!Rt(e.source,">")&&!Rt(e.source,"/>");){if(Rt(e.source,"/")){Pt(e,1),wt(e);continue}const r=xt(e,o);6===r.type&&r.value&&"class"===r.name&&(r.value.content=r.value.content.replace(/\s+/g," ").trim()),0===t&&n.push(r),/^[^\t\r\n\f />]/.test(e.source),wt(e)}return n}function xt(e,t){const n=Ct(e),o=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(e.source)[0];t.has(o),t.add(o);{const e=/["'<]/g;let t;for(;t=e.exec(o););}let r;Pt(e,o.length),/^[\t\r\n\f ]*=/.test(e.source)&&(wt(e),Pt(e,1),wt(e),r=function(e){const t=Ct(e);let n;const o=e.source[0],r='"'===o||"'"===o;if(r){Pt(e,1);const t=e.source.indexOf(o);-1===t?n=Ot(e,e.source.length,4):(n=Ot(e,t,4),Pt(e,1))}else{const t=/^[^\t\r\n\f >]+/.exec(e.source);if(!t)return;const o=/["'<=`]/g;let r;for(;r=o.exec(t[0]););n=Ot(e,t[0].length,4)}return{content:n,isQuoted:r,loc:It(e,t)}}(e));const s=It(e,n);if(!e.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(o)){const t=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(o);let i,c=Rt(o,"."),l=t[1]||(c||Rt(o,":")?"bind":Rt(o,"@")?"on":"slot");if(t[2]){const r="slot"===l,s=o.lastIndexOf(t[2]),c=It(e,$t(e,n,s),$t(e,n,s+t[2].length+(r&&t[3]||"").length));let a=t[2],p=!0;a.startsWith("[")?(p=!1,a=a.endsWith("]")?a.slice(1,a.length-1):a.slice(1)):r&&(a+=t[3]||""),i={type:4,content:a,isStatic:p,constType:p?3:0,loc:c}}if(r&&r.isQuoted){const e=r.loc;e.start.offset++,e.start.column++,e.end=He(e.start,r.content),e.source=e.source.slice(1,-1)}const a=t[3]?t[3].slice(1).split("."):[];return c&&a.push("prop"),"bind"===l&&i&&a.includes("sync")&&pt("COMPILER_V_BIND_SYNC",e,0)&&(l="model",a.splice(a.indexOf("sync"),1)),{type:7,name:l,exp:r&&{type:4,content:r.content,isStatic:!1,constType:0,loc:r.loc},arg:i,modifiers:a,loc:s}}return!e.inVPre&&Rt(o,"v-"),{type:6,name:o,value:r&&{type:2,content:r.content,loc:r.loc},loc:s}}function Tt(e,t){const[n,o]=e.options.delimiters,r=e.source.indexOf(o,n.length);if(-1===r)return;const s=Ct(e);Pt(e,n.length);const i=Ct(e),c=Ct(e),l=r-n.length,a=e.source.slice(0,l),p=Ot(e,l,t),u=p.trim(),f=p.indexOf(u);f>0&&We(i,a,f);return We(c,a,l-(p.length-u.length-f)),Pt(e,o.length),{type:5,content:{type:4,isStatic:!1,constType:0,content:u,loc:It(e,i,c)},loc:It(e,s)}}function kt(e,t){const n=3===t?["]]>"]:["<",e.options.delimiters[0]];let o=e.source.length;for(let s=0;s<n.length;s++){const t=e.source.indexOf(n[s],1);-1!==t&&o>t&&(o=t)}const r=Ct(e);return{type:2,content:Ot(e,o,t),loc:It(e,r)}}function Ot(e,t,n){const o=e.source.slice(0,t);return Pt(e,t),2!==n&&3!==n&&o.includes("&")?e.options.decodeEntities(o,4===n):o}function Ct(e){const{column:t,line:n,offset:o}=e;return{column:t,line:n,offset:o}}function It(e,t,n){return{start:t,end:n=n||Ct(e),source:e.originalSource.slice(t.offset,n.offset)}}function Mt(e){return e[e.length-1]}function Rt(e,t){return e.startsWith(t)}function Pt(e,t){const{source:n}=e;We(e,n,t),e.source=n.slice(t)}function wt(e){const t=/^[\t\r\n\f ]+/.exec(e.source);t&&Pt(e,t[0].length)}function $t(e,t,n){return He(t,e.originalSource.slice(t.offset,n),n)}function Lt(e,t,n){const o=e.source;switch(t){case 0:if(Rt(o,"</"))for(let e=n.length-1;e>=0;--e)if(Vt(o,n[e].tag))return!0;break;case 1:case 2:{const e=Mt(n);if(e&&Vt(o,e.tag))return!0;break}case 3:if(Rt(o,"]]>"))return!0}return!o}function Vt(e,t){return Rt(e,"</")&&e.slice(2,2+t.length).toLowerCase()===t.toLowerCase()&&/[\t\r\n\f />]/.test(e[2+t.length]||">")}function At(e,t){Bt(e,t,Dt(e,e.children[0]))}function Dt(e,t){const{children:n}=e;return 1===n.length&&1===t.type&&!qe(t)}function Bt(e,t,n=!1){const{children:o}=e,r=o.length;let s=0;for(let i=0;i<o.length;i++){const e=o[i];if(1===e.type&&0===e.tagType){const o=n?0:Ft(e,t);if(o>0){if(o>=2){e.codegenNode.patchFlag="-1",e.codegenNode=t.hoist(e.codegenNode),s++;continue}}else{const n=e.codegenNode;if(13===n.type){const o=Ut(n);if((!o||512===o||1===o)&&Wt(e,t)>=2){const o=Kt(e);o&&(n.props=t.hoist(o))}n.dynamicProps&&(n.dynamicProps=t.hoist(n.dynamicProps))}}}if(1===e.type){const n=1===e.tagType;n&&t.scopes.vSlot++,Bt(e,t),n&&t.scopes.vSlot--}else if(11===e.type)Bt(e,t,1===e.children.length);else if(9===e.type)for(let n=0;n<e.branches.length;n++)Bt(e.branches[n],t,1===e.branches[n].children.length)}s&&t.transformHoist&&t.transformHoist(o,t,e),s&&s===r&&1===e.type&&0===e.tagType&&e.codegenNode&&13===e.codegenNode.type&&h(e.codegenNode.children)&&(e.codegenNode.children=t.hoist(be(e.codegenNode.children)))}function Ft(e,t){const{constantCache:n}=t;switch(e.type){case 1:if(0!==e.tagType)return 0;const o=n.get(e);if(void 0!==o)return o;const r=e.codegenNode;if(13!==r.type)return 0;if(r.isBlock&&"svg"!==e.tag&&"foreignObject"!==e.tag)return 0;if(Ut(r))return n.set(e,0),0;{let o=3;const s=Wt(e,t);if(0===s)return n.set(e,0),0;s<o&&(o=s);for(let r=0;r<e.children.length;r++){const s=Ft(e.children[r],t);if(0===s)return n.set(e,0),0;s<o&&(o=s)}if(o>1)for(let r=0;r<e.props.length;r++){const s=e.props[r];if(7===s.type&&"bind"===s.name&&s.exp){const r=Ft(s.exp,t);if(0===r)return n.set(e,0),0;r<o&&(o=r)}}if(r.isBlock){for(let t=0;t<e.props.length;t++){if(7===e.props[t].type)return n.set(e,0),0}t.removeHelper(L),t.removeHelper(Qe(t.inSSR,r.isComponent)),r.isBlock=!1,t.helper(Xe(t.inSSR,r.isComponent))}return n.set(e,o),o}case 2:case 3:return 3;case 9:case 11:case 10:default:return 0;case 5:case 12:return Ft(e.content,t);case 4:return e.constType;case 8:let s=3;for(let n=0;n<e.children.length;n++){const o=e.children[n];if(m(o)||g(o))continue;const r=Ft(o,t);if(0===r)return 0;r<s&&(s=r)}return s}}const jt=new Set([Q,ee,te,ne]);function Ht(e,t){if(14===e.type&&!m(e.callee)&&jt.has(e.callee)){const n=e.arguments[0];if(4===n.type)return Ft(n,t);if(14===n.type)return Ht(n,t)}return 0}function Wt(e,t){let n=3;const o=Kt(e);if(o&&15===o.type){const{properties:e}=o;for(let o=0;o<e.length;o++){const{key:r,value:s}=e[o],i=Ft(r,t);if(0===i)return i;let c;if(i<n&&(n=i),c=4===s.type?Ft(s,t):14===s.type?Ht(s,t):0,0===c)return c;c<n&&(n=c)}}return n}function Kt(e){const t=e.codegenNode;if(13===t.type)return t.props}function Ut(e){const t=e.patchFlag;return t?parseInt(t,10):void 0}function Jt(e,{filename:t="",prefixIdentifiers:n=!1,hoistStatic:o=!1,cacheHandlers:r=!1,nodeTransforms:s=[],directiveTransforms:i={},transformHoist:c=null,isBuiltInComponent:p=a,isCustomElement:u=a,expressionPlugins:f=[],scopeId:d=null,slotted:h=!0,ssr:g=!1,inSSR:y=!1,ssrCssVars:v="",bindingMetadata:S=l,inline:b=!1,isTS:E=!1,onError:_=O,onWarn:x=C,compatConfig:k}){const I=t.replace(/\?.*$/,"").match(/([^/\\]+)\.\w+$/),M={selfName:I&&T(N(I[1])),prefixIdentifiers:n,hoistStatic:o,cacheHandlers:r,nodeTransforms:s,directiveTransforms:i,transformHoist:c,isBuiltInComponent:p,isCustomElement:u,expressionPlugins:f,scopeId:d,slotted:h,ssr:g,inSSR:y,ssrCssVars:v,bindingMetadata:S,inline:b,isTS:E,onError:_,onWarn:x,compatConfig:k,root:e,helpers:new Map,components:new Set,directives:new Set,hoists:[],imports:[],constantCache:new Map,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:e,childIndex:0,inVOnce:!1,helper(e){const t=M.helpers.get(e)||0;return M.helpers.set(e,t+1),e},removeHelper(e){const t=M.helpers.get(e);if(t){const n=t-1;n?M.helpers.set(e,n):M.helpers.delete(e)}},helperString:e=>`_${me[M.helper(e)]}`,replaceNode(e){M.parent.children[M.childIndex]=M.currentNode=e},removeNode(e){const t=e?M.parent.children.indexOf(e):M.currentNode?M.childIndex:-1;e&&e!==M.currentNode?M.childIndex>t&&(M.childIndex--,M.onNodeRemoved()):(M.currentNode=null,M.onNodeRemoved()),M.parent.children.splice(t,1)},onNodeRemoved:()=>{},addIdentifiers(e){},removeIdentifiers(e){},hoist(e){m(e)&&(e=_e(e)),M.hoists.push(e);const t=_e(`_hoisted_${M.hoists.length}`,!1,e.loc,2);return t.hoisted=e,t},cache:(e,t=!1)=>Ce(M.cached++,e,t)};return M.filters=new Set,M}function Gt(e,t){const n=Jt(e,t);zt(e,n),t.hoistStatic&&At(e,n),t.ssr||function(e,t){const{helper:n}=t,{children:o}=e;if(1===o.length){const n=o[0];if(Dt(e,n)&&n.codegenNode){const o=n.codegenNode;13===o.type&&it(o,t),e.codegenNode=o}else e.codegenNode=n}else if(o.length>1){let o=64;e.codegenNode=Se(t,n(M),void 0,e.children,o+"",void 0,void 0,!0,void 0,!1)}}(e,n),e.helpers=new Set([...n.helpers.keys()]),e.components=[...n.components],e.directives=[...n.directives],e.imports=n.imports,e.hoists=n.hoists,e.temps=n.temps,e.cached=n.cached,e.filters=[...n.filters]}function zt(e,t){t.currentNode=e;const{nodeTransforms:n}=t,o=[];for(let s=0;s<n.length;s++){const r=n[s](e,t);if(r&&(h(r)?o.push(...r):o.push(r)),!t.currentNode)return;e=t.currentNode}switch(e.type){case 3:t.ssr||t.helper(F);break;case 5:t.ssr||t.helper(q);break;case 9:for(let n=0;n<e.branches.length;n++)zt(e.branches[n],t);break;case 10:case 11:case 1:case 0:!function(e,t){let n=0;const o=()=>{n--};for(;n<e.children.length;n++){const r=e.children[n];m(r)||(t.parent=e,t.childIndex=n,t.onNodeRemoved=o,zt(r,t))}}(e,t)}t.currentNode=e;let r=o.length;for(;r--;)o[r]()}function Yt(e,t){const n=m(e)?t=>t===e:t=>e.test(t);return(e,o)=>{if(1===e.type){const{props:r}=e;if(3===e.tagType&&r.some(Ye))return;const s=[];for(let i=0;i<r.length;i++){const c=r[i];if(7===c.type&&n(c.name)){r.splice(i,1),i--;const n=t(e,c,o);n&&s.push(n)}}return s}}}const Zt="/*#__PURE__*/",qt=e=>`${me[e]}: _${me[e]}`;function Xt(e,{mode:t="function",prefixIdentifiers:n="module"===t,sourceMap:o=!1,filename:r="template.vue.html",scopeId:s=null,optimizeImports:i=!1,runtimeGlobalName:c="Vue",runtimeModuleName:l="vue",ssrRuntimeModuleName:a="vue/server-renderer",ssr:p=!1,isTS:u=!1,inSSR:f=!1}){const d={mode:t,prefixIdentifiers:n,sourceMap:o,filename:r,scopeId:s,optimizeImports:i,runtimeGlobalName:c,runtimeModuleName:l,ssrRuntimeModuleName:a,ssr:p,isTS:u,inSSR:f,source:e.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:!1,map:void 0,helper:e=>`_${me[e]}`,push(e,t){d.code+=e},indent(){h(++d.indentLevel)},deindent(e=!1){e?--d.indentLevel:h(--d.indentLevel)},newline(){h(d.indentLevel)}};function h(e){d.push("\n"+"  ".repeat(e))}return d}function Qt(e,t={}){const n=Xt(e,t);t.onContextCreated&&t.onContextCreated(n);const{mode:o,push:r,prefixIdentifiers:s,indent:i,deindent:c,newline:l,ssr:a}=n,p=Array.from(e.helpers),u=p.length>0,f=!s&&"module"!==o,d=n;!function(e,t){const{push:n,newline:o,runtimeGlobalName:r}=t,s=r,i=Array.from(e.helpers);if(i.length>0&&(n(`const _Vue = ${s}\n`),e.hoists.length)){n(`const { ${[D,B,F,j,H].filter((e=>i.includes(e))).map(qt).join(", ")} } = _Vue\n`)}(function(e,t){if(!e.length)return;t.pure=!0;const{push:n,newline:o}=t;o();for(let r=0;r<e.length;r++){const s=e[r];s&&(n(`const _hoisted_${r+1} = `),on(s,t),o())}t.pure=!1})(e.hoists,t),o(),n("return ")}(e,d);if(r(`function ${a?"ssrRender":"render"}(${(a?["_ctx","_push","_parent","_attrs"]:["_ctx","_cache"]).join(", ")}) {`),i(),f&&(r("with (_ctx) {"),i(),u&&(r(`const { ${p.map(qt).join(", ")} } = _Vue`),r("\n"),l())),e.components.length&&(en(e.components,"component",n),(e.directives.length||e.temps>0)&&l()),e.directives.length&&(en(e.directives,"directive",n),e.temps>0&&l()),e.filters&&e.filters.length&&(l(),en(e.filters,"filter",n),l()),e.temps>0){r("let ");for(let t=0;t<e.temps;t++)r(`${t>0?", ":""}_temp${t}`)}return(e.components.length||e.directives.length||e.temps)&&(r("\n"),l()),a||r("return "),e.codegenNode?on(e.codegenNode,n):r("null"),f&&(c(),r("}")),c(),r("}"),{ast:e,code:n.code,preamble:"",map:n.map?n.map.toJSON():void 0}}function en(e,t,{helper:n,push:o,newline:r,isTS:s}){const i=n("filter"===t?J:"component"===t?W:U);for(let c=0;c<e.length;c++){let n=e[c];const l=n.endsWith("__self");l&&(n=n.slice(0,-6)),o(`const ${rt(n,t)} = ${i}(${JSON.stringify(n)}${l?", true":""})${s?"!":""}`),c<e.length-1&&r()}}function tn(e,t){const n=e.length>3||!1;t.push("["),n&&t.indent(),nn(e,t,n),n&&t.deindent(),t.push("]")}function nn(e,t,n=!1,o=!0){const{push:r,newline:s}=t;for(let i=0;i<e.length;i++){const c=e[i];m(c)?r(c):h(c)?tn(c,t):on(c,t),i<e.length-1&&(n?(o&&r(","),s()):o&&r(", "))}}function on(e,t){if(m(e))t.push(e);else if(g(e))t.push(t.helper(e));else switch(e.type){case 1:case 9:case 11:case 12:on(e.codegenNode,t);break;case 2:!function(e,t){t.push(JSON.stringify(e.content),e)}(e,t);break;case 4:rn(e,t);break;case 5:!function(e,t){const{push:n,helper:o,pure:r}=t;r&&n(Zt);n(`${o(q)}(`),on(e.content,t),n(")")}(e,t);break;case 8:sn(e,t);break;case 3:!function(e,t){const{push:n,helper:o,pure:r}=t;r&&n(Zt);n(`${o(F)}(${JSON.stringify(e.content)})`,e)}(e,t);break;case 13:!function(e,t){const{push:n,helper:o,pure:r}=t,{tag:s,props:i,children:c,patchFlag:l,dynamicProps:a,directives:p,isBlock:u,disableTracking:f,isComponent:d}=e;p&&n(o(G)+"(");u&&n(`(${o(L)}(${f?"true":""}), `);r&&n(Zt);const h=u?Qe(t.inSSR,d):Xe(t.inSSR,d);n(o(h)+"(",e),nn(function(e){let t=e.length;for(;t--&&null==e[t];);return e.slice(0,t+1).map((e=>e||"null"))}([s,i,c,l,a]),t),n(")"),u&&n(")");p&&(n(", "),on(p,t),n(")"))}(e,t);break;case 14:!function(e,t){const{push:n,helper:o,pure:r}=t,s=m(e.callee)?e.callee:o(e.callee);r&&n(Zt);n(s+"(",e),nn(e.arguments,t),n(")")}(e,t);break;case 15:!function(e,t){const{push:n,indent:o,deindent:r,newline:s}=t,{properties:i}=e;if(!i.length)return void n("{}",e);const c=i.length>1||!1;n(c?"{":"{ "),c&&o();for(let l=0;l<i.length;l++){const{key:e,value:o}=i[l];cn(e,t),n(": "),on(o,t),l<i.length-1&&(n(","),s())}c&&r(),n(c?"}":" }")}(e,t);break;case 17:!function(e,t){tn(e.elements,t)}(e,t);break;case 18:!function(e,t){const{push:n,indent:o,deindent:r}=t,{params:s,returns:i,body:c,newline:l,isSlot:a}=e;a&&n(`_${me[pe]}(`);n("(",e),h(s)?nn(s,t):s&&on(s,t);n(") => "),(l||c)&&(n("{"),o());i?(l&&n("return "),h(i)?tn(i,t):on(i,t)):c&&on(c,t);(l||c)&&(r(),n("}"));a&&(e.isNonScopedSlot&&n(", undefined, true"),n(")"))}(e,t);break;case 19:!function(e,t){const{test:n,consequent:o,alternate:r,newline:s}=e,{push:i,indent:c,deindent:l,newline:a}=t;if(4===n.type){const e=!$e(n.content);e&&i("("),rn(n,t),e&&i(")")}else i("("),on(n,t),i(")");s&&c(),t.indentLevel++,s||i(" "),i("? "),on(o,t),t.indentLevel--,s&&a(),s||i(" "),i(": ");const p=19===r.type;p||t.indentLevel++;on(r,t),p||t.indentLevel--;s&&l(!0)}(e,t);break;case 20:!function(e,t){const{push:n,helper:o,indent:r,deindent:s,newline:i}=t;n(`_cache[${e.index}] || (`),e.isVNode&&(r(),n(`${o(ce)}(-1),`),i());n(`_cache[${e.index}] = `),on(e.value,t),e.isVNode&&(n(","),i(),n(`${o(ce)}(1),`),i(),n(`_cache[${e.index}]`),s());n(")")}(e,t);break;case 21:nn(e.body,t,!0,!1)}}function rn(e,t){const{content:n,isStatic:o}=e;t.push(o?JSON.stringify(n):n,e)}function sn(e,t){for(let n=0;n<e.children.length;n++){const o=e.children[n];m(o)?t.push(o):on(o,t)}}function cn(e,t){const{push:n}=t;if(8===e.type)n("["),sn(e,t),n("]");else if(e.isStatic){n($e(e.content)?e.content:JSON.stringify(e.content),e)}else n(`[${e.content}]`,e)}function ln(e,t=[]){switch(e.type){case"Identifier":t.push(e);break;case"MemberExpression":let n=e;for(;"MemberExpression"===n.type;)n=n.object;t.push(n);break;case"ObjectPattern":for(const o of e.properties)ln("RestElement"===o.type?o.argument:o.value,t);break;case"ArrayPattern":e.elements.forEach((e=>{e&&ln(e,t)}));break;case"RestElement":ln(e.argument,t);break;case"AssignmentPattern":ln(e.left,t)}return t}const an=e=>e&&("ObjectProperty"===e.type||"ObjectMethod"===e.type)&&!e.computed;function pn(e,t,n=!1,o=!1,r=Object.create(t.identifiers)){return e}const un=Yt(/^(if|else|else-if)$/,((e,t,n)=>fn(e,t,n,((e,t,o)=>{const r=n.parent.children;let s=r.indexOf(e),i=0;for(;s-- >=0;){const e=r[s];e&&9===e.type&&(i+=e.branches.length)}return()=>{if(o)e.codegenNode=hn(t,i,n);else{const o=function(e){for(;;)if(19===e.type){if(19!==e.alternate.type)return e;e=e.alternate}else 20===e.type&&(e=e.value)}(e.codegenNode);o.alternate=hn(t,i+e.branches.length-1,n)}}}))));function fn(e,t,n,o){if(!("else"===t.name||t.exp&&t.exp.content.trim())){t.exp=_e("true",!1,t.exp?t.exp.loc:e.loc)}if("if"===t.name){const r=dn(e,t),s={type:9,loc:e.loc,branches:[r]};if(n.replaceNode(s),o)return o(s,r,!0)}else{const r=n.parent.children;let s=r.indexOf(e);for(;s-- >=-1;){const i=r[s];if(i&&3===i.type)n.removeNode(i);else{if(!i||2!==i.type||i.content.trim().length){if(i&&9===i.type){n.removeNode();const r=dn(e,t);i.branches.push(r);const s=o&&o(i,r,!1);zt(r,n),s&&s(),n.currentNode=null}break}n.removeNode(i)}}}}function dn(e,t){const n=3===e.tagType;return{type:10,loc:e.loc,condition:"else"===t.name?void 0:t.exp,children:n&&!Ke(e,"for")?e.children:[e],userKey:Ue(e,"key"),isTemplateIf:n}}function hn(e,t,n){return e.condition?Oe(e.condition,mn(e,t,n),Te(n.helper(F),['""',"true"])):mn(e,t,n)}function mn(e,t,n){const{helper:o}=n,r=Ne("key",_e(`${t}`,!1,ye,2)),{children:s}=e,i=s[0];if(1!==s.length||1!==i.type){if(1===s.length&&11===i.type){const e=i.codegenNode;return nt(e,r,n),e}{let t=64;return Se(n,o(M),Ee([r]),s,t+"",void 0,void 0,!0,!1,!1,e.loc)}}{const e=i.codegenNode,t=st(e);return 13===t.type&&it(t,n),nt(t,r,n),e}}const gn=Yt("for",((e,t,n)=>{const{helper:o,removeHelper:r}=n;return yn(e,t,n,(t=>{const s=Te(o(z),[t.source]),i=Ze(e),c=Ke(e,"memo"),l=Ue(e,"key"),a=l&&(6===l.type?_e(l.value.content,!0):l.exp),p=l?Ne("key",a):null,u=4===t.source.type&&t.source.constType>0,f=u?64:l?128:256;return t.codegenNode=Se(n,o(M),void 0,s,f+"",void 0,void 0,!0,!u,!1,e.loc),()=>{let l;const{children:f}=t,d=1!==f.length||1!==f[0].type,h=qe(e)?e:i&&1===e.children.length&&qe(e.children[0])?e.children[0]:null;if(h?(l=h.codegenNode,i&&p&&nt(l,p,n)):d?l=Se(n,o(M),p?Ee([p]):void 0,e.children,"64",void 0,void 0,!0,void 0,!1):(l=f[0].codegenNode,i&&p&&nt(l,p,n),l.isBlock!==!u&&(l.isBlock?(r(L),r(Qe(n.inSSR,l.isComponent))):r(Xe(n.inSSR,l.isComponent))),l.isBlock=!u,l.isBlock?(o(L),o(Qe(n.inSSR,l.isComponent))):o(Xe(n.inSSR,l.isComponent))),c){const e=ke(_n(t.parseResult,[_e("_cached")]));e.body=Ie([xe(["const _memo = (",c.exp,")"]),xe(["if (_cached",...a?[" && _cached.key === ",a]:[],` && ${n.helperString(he)}(_cached, _memo)) return _cached`]),xe(["const _item = ",l]),_e("_item.memo = _memo"),_e("return _item")]),s.arguments.push(e,_e("_cache"),_e(String(n.cached++)))}else s.arguments.push(ke(_n(t.parseResult),l,!0))}}))}));function yn(e,t,n,o){if(!t.exp)return;const r=En(t.exp);if(!r)return;const{scopes:s}=n,{source:i,value:c,key:l,index:a}=r,p={type:11,loc:t.loc,source:i,valueAlias:c,keyAlias:l,objectIndexAlias:a,parseResult:r,children:Ze(e)?e.children:[e]};n.replaceNode(p),s.vFor++;const u=o&&o(p);return()=>{s.vFor--,u&&u()}}const vn=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Sn=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,bn=/^\(|\)$/g;function En(e,t){const n=e.loc,o=e.content,r=o.match(vn);if(!r)return;const[,s,i]=r,c={source:Nn(n,i.trim(),o.indexOf(i,s.length)),value:void 0,key:void 0,index:void 0};let l=s.trim().replace(bn,"").trim();const a=s.indexOf(l),p=l.match(Sn);if(p){l=l.replace(Sn,"").trim();const e=p[1].trim();let t;if(e&&(t=o.indexOf(e,a+l.length),c.key=Nn(n,e,t)),p[2]){const r=p[2].trim();r&&(c.index=Nn(n,r,o.indexOf(r,c.key?t+e.length:a+l.length)))}}return l&&(c.value=Nn(n,l,a)),c}function Nn(e,t,n){return _e(t,!1,je(e,n,t.length))}function _n({value:e,key:t,index:n},o=[]){return function(e){let t=e.length;for(;t--&&!e[t];);return e.slice(0,t+1).map(((e,t)=>e||_e("_".repeat(t+1),!1)))}([e,t,n,...o])}const xn=_e("undefined",!1),Tn=(e,t)=>{if(1===e.type&&(1===e.tagType||3===e.tagType)){const n=Ke(e,"slot");if(n)return t.scopes.vSlot++,()=>{t.scopes.vSlot--}}},kn=(e,t,n)=>ke(e,t,!1,!0,t.length?t[0].loc:n);function On(e,t,n=kn){t.helper(pe);const{children:o,loc:r}=e,s=[],i=[];let c=t.scopes.vSlot>0||t.scopes.vFor>0;const l=Ke(e,"slot",!0);if(l){const{arg:e,exp:t}=l;e&&!Me(e)&&(c=!0),s.push(Ne(e||_e("default",!0),n(t,o,r)))}let a=!1,p=!1;const u=[],f=new Set;let d=0;for(let g=0;g<o.length;g++){const e=o[g];let r;if(!Ze(e)||!(r=Ke(e,"slot",!0))){3!==e.type&&u.push(e);continue}if(l)break;a=!0;const{children:h,loc:m}=e,{arg:y=_e("default",!0),exp:v}=r;let S;Me(y)?S=y?y.content:"default":c=!0;const b=n(v,h,m);let E,N,_;if(E=Ke(e,"if"))c=!0,i.push(Oe(E.exp,Cn(y,b,d++),xn));else if(N=Ke(e,/^else(-if)?$/,!0)){let e,t=g;for(;t--&&(e=o[t],3===e.type););if(e&&Ze(e)&&Ke(e,"if")){o.splice(g,1),g--;let e=i[i.length-1];for(;19===e.alternate.type;)e=e.alternate;e.alternate=N.exp?Oe(N.exp,Cn(y,b,d++),xn):Cn(y,b,d++)}}else if(_=Ke(e,"for")){c=!0;const e=_.parseResult||En(_.exp);e&&i.push(Te(t.helper(z),[e.source,ke(_n(e),Cn(y,b),!0)]))}else{if(S){if(f.has(S))continue;f.add(S),"default"===S&&(p=!0)}s.push(Ne(y,b))}}if(!l){const e=(e,o)=>{const s=n(e,o,r);return t.compatConfig&&(s.isNonScopedSlot=!0),Ne("default",s)};a?u.length&&u.some((e=>Mn(e)))&&(p||s.push(e(void 0,u))):s.push(e(void 0,o))}const h=c?2:In(e.children)?3:1;let m=Ee(s.concat(Ne("_",_e(h+"",!1))),r);return i.length&&(m=Te(t.helper(Z),[m,be(i)])),{slots:m,hasDynamicSlots:c}}function Cn(e,t,n){const o=[Ne("name",e),Ne("fn",t)];return null!=n&&o.push(Ne("key",_e(String(n),!0))),Ee(o)}function In(e){for(let t=0;t<e.length;t++){const n=e[t];switch(n.type){case 1:if(2===n.tagType||In(n.children))return!0;break;case 9:if(In(n.branches))return!0;break;case 10:case 11:if(In(n.children))return!0}}return!1}function Mn(e){return 2!==e.type&&12!==e.type||(2===e.type?!!e.content.trim():Mn(e.content))}const Rn=new WeakMap,Pn=(e,t)=>function(){if(1!==(e=t.currentNode).type||0!==e.tagType&&1!==e.tagType)return;const{tag:n,props:o}=e,r=1===e.tagType;let s=r?wn(e,t):`"${n}"`;const i=y(s)&&s.callee===K;let c,l,a,p,u,f,d=0,h=i||s===R||s===P||!r&&("svg"===n||"foreignObject"===n);if(o.length>0){const n=$n(e,t,void 0,r,i);c=n.props,d=n.patchFlag,u=n.dynamicPropNames;const o=n.directives;f=o&&o.length?be(o.map((e=>An(e,t)))):void 0,n.shouldUseBlock&&(h=!0)}if(e.children.length>0){s===w&&(h=!0,d|=1024);if(r&&s!==R&&s!==w){const{slots:n,hasDynamicSlots:o}=On(e,t);l=n,o&&(d|=1024)}else if(1===e.children.length&&s!==R){const n=e.children[0],o=n.type,r=5===o||8===o;r&&0===Ft(n,t)&&(d|=1),l=r||2===o?n:e.children}else l=e.children}0!==d&&(a=String(d),u&&u.length&&(p=function(e){let t="[";for(let n=0,o=e.length;n<o;n++)t+=JSON.stringify(e[n]),n<o-1&&(t+=", ");return t+"]"}(u))),e.codegenNode=Se(t,s,c,l,a,p,f,!!h,!1,r,e.loc)};function wn(e,t,n=!1){let{tag:o}=e;const r=Dn(o),s=Ue(e,"is");if(s)if(r||at("COMPILER_IS_ON_ELEMENT",t)){const e=6===s.type?s.value&&_e(s.value.content,!0):s.exp;if(e)return Te(t.helper(K),[e])}else 6===s.type&&s.value.content.startsWith("vue:")&&(o=s.value.content.slice(4));const i=!r&&Ke(e,"is");if(i&&i.exp)return Te(t.helper(K),[i.exp]);const c=Pe(o)||t.isBuiltInComponent(o);return c?(n||t.helper(c),c):(t.helper(W),t.components.add(o),rt(o,"component"))}function $n(e,t,n=e.props,o,r,s=!1){const{tag:i,loc:c,children:l}=e;let a=[];const p=[],u=[],d=l.length>0;let h=!1,m=0,y=!1,b=!1,E=!1,N=!1,_=!1,x=!1;const T=[],k=e=>{a.length&&(p.push(Ee(Ln(a),c)),a=[]),e&&p.push(e)},O=({key:e,value:n})=>{if(Me(e)){const s=e.content,i=f(s);if(!i||o&&!r||"onclick"===s.toLowerCase()||"onUpdate:modelValue"===s||v(s)||(N=!0),i&&v(s)&&(x=!0),20===n.type||(4===n.type||8===n.type)&&Ft(n,t)>0)return;"ref"===s?y=!0:"class"===s?b=!0:"style"===s?E=!0:"key"===s||T.includes(s)||T.push(s),!o||"class"!==s&&"style"!==s||T.includes(s)||T.push(s)}else _=!0};for(let f=0;f<n.length;f++){const r=n[f];if(6===r.type){const{loc:e,name:n,value:o}=r;let s=!0;if("ref"===n&&(y=!0,t.scopes.vFor>0&&a.push(Ne(_e("ref_for",!0),_e("true")))),"is"===n&&(Dn(i)||o&&o.content.startsWith("vue:")||at("COMPILER_IS_ON_ELEMENT",t)))continue;a.push(Ne(_e(n,!0,je(e,0,n.length)),_e(o?o.content:"",s,o?o.loc:e)))}else{const{name:n,arg:l,exp:f,loc:m}=r,y="bind"===n,v="on"===n;if("slot"===n)continue;if("once"===n||"memo"===n)continue;if("is"===n||y&&Je(l,"is")&&(Dn(i)||at("COMPILER_IS_ON_ELEMENT",t)))continue;if(v&&s)continue;if((y&&Je(l,"key")||v&&d&&Je(l,"vue:before-update"))&&(h=!0),y&&Je(l,"ref")&&t.scopes.vFor>0&&a.push(Ne(_e("ref_for",!0),_e("true"))),!l&&(y||v)){if(_=!0,f)if(y){if(k(),at("COMPILER_V_BIND_OBJECT_ORDER",t)){p.unshift(f);continue}p.push(f)}else k({type:14,loc:m,callee:t.helper(oe),arguments:o?[f]:[f,"true"]});continue}const b=t.directiveTransforms[n];if(b){const{props:n,needRuntime:o}=b(r,e,t);!s&&n.forEach(O),v&&l&&!Me(l)?k(Ee(n,c)):a.push(...n),o&&(u.push(r),g(o)&&Rn.set(r,o))}else S(n)||(u.push(r),d&&(h=!0))}}let C;if(p.length?(k(),C=p.length>1?Te(t.helper(X),p,c):p[0]):a.length&&(C=Ee(Ln(a),c)),_?m|=16:(b&&!o&&(m|=2),E&&!o&&(m|=4),T.length&&(m|=8),N&&(m|=32)),h||0!==m&&32!==m||!(y||x||u.length>0)||(m|=512),!t.inSSR&&C)switch(C.type){case 15:let e=-1,n=-1,o=!1;for(let t=0;t<C.properties.length;t++){const r=C.properties[t].key;Me(r)?"class"===r.content?e=t:"style"===r.content&&(n=t):r.isHandlerKey||(o=!0)}const r=C.properties[e],s=C.properties[n];o?C=Te(t.helper(te),[C]):(r&&!Me(r.value)&&(r.value=Te(t.helper(Q),[r.value])),s&&(E||4===s.value.type&&"["===s.value.content.trim()[0]||17===s.value.type)&&(s.value=Te(t.helper(ee),[s.value])));break;case 14:break;default:C=Te(t.helper(te),[Te(t.helper(ne),[C])])}return{props:C,directives:u,patchFlag:m,dynamicPropNames:T,shouldUseBlock:h}}function Ln(e){const t=new Map,n=[];for(let o=0;o<e.length;o++){const r=e[o];if(8===r.key.type||!r.key.isStatic){n.push(r);continue}const s=r.key.content,i=t.get(s);i?("style"===s||"class"===s||f(s))&&Vn(i,r):(t.set(s,r),n.push(r))}return n}function Vn(e,t){17===e.value.type?e.value.elements.push(t.value):e.value=be([e.value,t.value],e.loc)}function An(e,t){const n=[],o=Rn.get(e);o?n.push(t.helperString(o)):(t.helper(U),t.directives.add(e.name),n.push(rt(e.name,"directive")));const{loc:r}=e;if(e.exp&&n.push(e.exp),e.arg&&(e.exp||n.push("void 0"),n.push(e.arg)),Object.keys(e.modifiers).length){e.arg||(e.exp||n.push("void 0"),n.push("void 0"));const t=_e("true",!1,r);n.push(Ee(e.modifiers.map((e=>Ne(e,t))),r))}return be(n,e.loc)}function Dn(e){return"component"===e||"Component"===e}const Bn=(e,t)=>{if(qe(e)){const{children:n,loc:o}=e,{slotName:r,slotProps:s}=Fn(e,t),i=[t.prefixIdentifiers?"_ctx.$slots":"$slots",r,"{}","undefined","true"];let c=2;s&&(i[2]=s,c=3),n.length&&(i[3]=ke([],n,!1,!1,o),c=4),t.scopeId&&!t.slotted&&(c=5),i.splice(c),e.codegenNode=Te(t.helper(Y),i,o)}};function Fn(e,t){let n,o='"default"';const r=[];for(let s=0;s<e.props.length;s++){const t=e.props[s];6===t.type?t.value&&("name"===t.name?o=JSON.stringify(t.value.content):(t.name=N(t.name),r.push(t))):"bind"===t.name&&Je(t.arg,"name")?t.exp&&(o=t.exp):("bind"===t.name&&t.arg&&Me(t.arg)&&(t.arg.content=N(t.arg.content)),r.push(t))}if(r.length>0){const{props:o,directives:s}=$n(e,t,r,!1,!1);n=o}return{slotName:o,slotProps:n}}const jn=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,Hn=(e,t,n,o)=>{const{loc:r,modifiers:s,arg:i}=e;let c;if(4===i.type)if(i.isStatic){let e=i.content;e.startsWith("vue:")&&(e=`vnode-${e.slice(4)}`);c=_e(0!==t.tagType||e.startsWith("vnode")||!/[A-Z]/.test(e)?k(N(e)):`on:${e}`,!0,i.loc)}else c=xe([`${n.helperString(ie)}(`,i,")"]);else c=i,c.children.unshift(`${n.helperString(ie)}(`),c.children.push(")");let l=e.exp;l&&!l.content.trim()&&(l=void 0);let a=n.cacheHandlers&&!l&&!n.inVOnce;if(l){const e=Fe(l.content),t=!(e||jn.test(l.content)),n=l.content.includes(";");(t||a&&e)&&(l=xe([`${t?"$event":"(...args)"} => ${n?"{":"("}`,l,n?"}":")"]))}let p={props:[Ne(c,l||_e("() => {}",!1,r))]};return o&&(p=o(p)),a&&(p.props[0].value=n.cache(p.props[0].value)),p.props.forEach((e=>e.key.isHandlerKey=!0)),p},Wn=(e,t,n)=>{const{exp:o,modifiers:r,loc:s}=e,i=e.arg;return 4!==i.type?(i.children.unshift("("),i.children.push(') || ""')):i.isStatic||(i.content=`${i.content} || ""`),r.includes("camel")&&(4===i.type?i.content=i.isStatic?N(i.content):`${n.helperString(re)}(${i.content})`:(i.children.unshift(`${n.helperString(re)}(`),i.children.push(")"))),n.inSSR||(r.includes("prop")&&Kn(i,"."),r.includes("attr")&&Kn(i,"^")),!o||4===o.type&&!o.content.trim()?{props:[Ne(i,_e("",!0,s))]}:{props:[Ne(i,o)]}},Kn=(e,t)=>{4===e.type?e.content=e.isStatic?t+e.content:`\`${t}\${${e.content}}\``:(e.children.unshift(`'${t}' + (`),e.children.push(")"))},Un=(e,t)=>{if(0===e.type||1===e.type||11===e.type||10===e.type)return()=>{const n=e.children;let o,r=!1;for(let e=0;e<n.length;e++){const t=n[e];if(ze(t)){r=!0;for(let r=e+1;r<n.length;r++){const s=n[r];if(!ze(s)){o=void 0;break}o||(o=n[e]=xe([t],t.loc)),o.children.push(" + ",s),n.splice(r,1),r--}}}if(r&&(1!==n.length||0!==e.type&&(1!==e.type||0!==e.tagType||e.props.find((e=>7===e.type&&!t.directiveTransforms[e.name]))||"template"===e.tag)))for(let e=0;e<n.length;e++){const o=n[e];if(ze(o)||8===o.type){const r=[];2===o.type&&" "===o.content||r.push(o),t.ssr||0!==Ft(o,t)||r.push("1"),n[e]={type:12,content:o,loc:o.loc,codegenNode:Te(t.helper(j),r)}}}}},Jn=new WeakSet,Gn=(e,t)=>{if(1===e.type&&Ke(e,"once",!0)){if(Jn.has(e)||t.inVOnce)return;return Jn.add(e),t.inVOnce=!0,t.helper(ce),()=>{t.inVOnce=!1;const e=t.currentNode;e.codegenNode&&(e.codegenNode=t.cache(e.codegenNode,!0))}}},zn=(e,t,n)=>{const{exp:o,arg:r}=e;if(!o)return Yn();const s=o.loc.source,i=4===o.type?o.content:s,c=n.bindingMetadata[s];if("props"===c||"props-aliased"===c)return Yn();if(!i.trim()||!Fe(i))return Yn();const l=r||_e("modelValue",!0),a=r?Me(r)?`onUpdate:${N(r.content)}`:xe(['"onUpdate:" + ',r]):"onUpdate:modelValue";let p;p=xe([`${n.isTS?"($event: any)":"$event"} => ((`,o,") = $event)"]);const u=[Ne(l,e.exp),Ne(a,p)];if(e.modifiers.length&&1===t.tagType){const t=e.modifiers.map((e=>($e(e)?e:JSON.stringify(e))+": true")).join(", "),n=r?Me(r)?`${r.content}Modifiers`:xe([r,' + "Modifiers"']):"modelModifiers";u.push(Ne(n,_e(`{ ${t} }`,!1,e.loc,2)))}return Yn(u)};function Yn(e=[]){return{props:e}}const Zn=/[\w).+\-_$\]]/,qn=(e,t)=>{at("COMPILER_FILTER",t)&&(5===e.type&&Xn(e.content,t),1===e.type&&e.props.forEach((e=>{7===e.type&&"for"!==e.name&&e.exp&&Xn(e.exp,t)})))};function Xn(e,t){if(4===e.type)Qn(e,t);else for(let n=0;n<e.children.length;n++){const o=e.children[n];"object"==typeof o&&(4===o.type?Qn(o,t):8===o.type?Xn(e,t):5===o.type&&Xn(o.content,t))}}function Qn(e,t){const n=e.content;let o,r,s,i,c=!1,l=!1,a=!1,p=!1,u=0,f=0,d=0,h=0,m=[];for(s=0;s<n.length;s++)if(r=o,o=n.charCodeAt(s),c)39===o&&92!==r&&(c=!1);else if(l)34===o&&92!==r&&(l=!1);else if(a)96===o&&92!==r&&(a=!1);else if(p)47===o&&92!==r&&(p=!1);else if(124!==o||124===n.charCodeAt(s+1)||124===n.charCodeAt(s-1)||u||f||d){switch(o){case 34:l=!0;break;case 39:c=!0;break;case 96:a=!0;break;case 40:d++;break;case 41:d--;break;case 91:f++;break;case 93:f--;break;case 123:u++;break;case 125:u--}if(47===o){let e,t=s-1;for(;t>=0&&(e=n.charAt(t)," "===e);t--);e&&Zn.test(e)||(p=!0)}}else void 0===i?(h=s+1,i=n.slice(0,s).trim()):g();function g(){m.push(n.slice(h,s).trim()),h=s+1}if(void 0===i?i=n.slice(0,s).trim():0!==h&&g(),m.length){for(s=0;s<m.length;s++)i=eo(i,m[s],t);e.content=i}}function eo(e,t,n){n.helper(J);const o=t.indexOf("(");if(o<0)return n.filters.add(t),`${rt(t,"filter")}(${e})`;{const r=t.slice(0,o),s=t.slice(o+1);return n.filters.add(r),`${rt(r,"filter")}(${e}${")"!==s?","+s:s}`}}const to=new WeakSet,no=(e,t)=>{if(1===e.type){const n=Ke(e,"memo");if(!n||to.has(e))return;return to.add(e),()=>{const o=e.codegenNode||t.currentNode.codegenNode;o&&13===o.type&&(1!==e.tagType&&it(o,t),e.codegenNode=Te(t.helper(de),[n.exp,ke(void 0,o),"_cache",String(t.cached++)]))}}};function oo(e){return[[Gn,un,no,gn,qn,Bn,Pn,Tn,Un],{on:Hn,bind:Wn,model:zn}]}function ro(e,t={}){const n=t.onError||O,o="module"===t.mode;!0===t.prefixIdentifiers?n(I(47)):o&&n(I(48));t.cacheHandlers&&n(I(49)),t.scopeId&&!o&&n(I(50));const r=m(e)?ht(e,t):e,[s,i]=oo();return Gt(r,d({},t,{prefixIdentifiers:false,nodeTransforms:[...s,...t.nodeTransforms||[]],directiveTransforms:d({},i,t.directiveTransforms||{})})),Qt(r,d({},t,{prefixIdentifiers:false}))}const so=()=>({props:[]}),io=Symbol(""),co=Symbol(""),lo=Symbol(""),ao=Symbol(""),po=Symbol(""),uo=Symbol(""),fo=Symbol(""),ho=Symbol(""),mo=Symbol(""),go=Symbol("");let yo;ge({[io]:"vModelRadio",[co]:"vModelCheckbox",[lo]:"vModelText",[ao]:"vModelSelect",[po]:"vModelDynamic",[uo]:"withModifiers",[fo]:"withKeys",[ho]:"vShow",[mo]:"Transition",[go]:"TransitionGroup"});const vo=t("style,iframe,script,noscript",!0),So={isVoidTag:c,isNativeTag:e=>s(e)||i(e),isPreTag:e=>"pre"===e,decodeEntities:function(e,t=!1){return yo||(yo=document.createElement("div")),t?(yo.innerHTML=`<div foo="${e.replace(/"/g,"&quot;")}">`,yo.children[0].getAttribute("foo")):(yo.innerHTML=e,yo.textContent)},isBuiltInComponent:e=>Re(e,"Transition")?mo:Re(e,"TransitionGroup")?go:void 0,getNamespace(e,t){let n=t?t.ns:0;if(t&&2===n)if("annotation-xml"===t.tag){if("svg"===e)return 1;t.props.some((e=>6===e.type&&"encoding"===e.name&&null!=e.value&&("text/html"===e.value.content||"application/xhtml+xml"===e.value.content)))&&(n=0)}else/^m(?:[ions]|text)$/.test(t.tag)&&"mglyph"!==e&&"malignmark"!==e&&(n=0);else t&&1===n&&("foreignObject"!==t.tag&&"desc"!==t.tag&&"title"!==t.tag||(n=0));if(0===n){if("svg"===e)return 1;if("math"===e)return 2}return n},getTextMode({tag:e,ns:t}){if(0===t){if("textarea"===e||"title"===e)return 1;if(vo(e))return 2}return 0}},bo=e=>{1===e.type&&e.props.forEach(((t,n)=>{6===t.type&&"style"===t.name&&t.value&&(e.props[n]={type:7,name:"bind",arg:_e("style",!0,t.loc),exp:Eo(t.value.content,t.loc),modifiers:[],loc:t.loc})}))},Eo=(e,t)=>{const s=function(e){const t={};return e.replace(r,"").split(n).forEach((e=>{if(e){const n=e.split(o);n.length>1&&(t[n[0].trim()]=n[1].trim())}})),t}(e);return _e(JSON.stringify(s),!1,t,3)};function No(e,t){return I(e,t)}const _o=t("passive,once,capture"),xo=t("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),To=t("left,right"),ko=t("onkeyup,onkeydown,onkeypress",!0),Oo=(e,t)=>Me(e)&&"onclick"===e.content.toLowerCase()?_e(t,!0):4!==e.type?xe(["(",e,`) === "onClick" ? "${t}" : (`,e,")"]):e,Co=(e,t)=>{1!==e.type||0!==e.tagType||"script"!==e.tag&&"style"!==e.tag||t.removeNode()},Io=[bo],Mo={cloak:so,html:(e,t,n)=>{const{exp:o,loc:r}=e;return t.children.length&&(t.children.length=0),{props:[Ne(_e("innerHTML",!0,r),o||_e("",!0))]}},text:(e,t,n)=>{const{exp:o,loc:r}=e;return t.children.length&&(t.children.length=0),{props:[Ne(_e("textContent",!0),o?Ft(o,n)>0?o:Te(n.helperString(q),[o],r):_e("",!0))]}},model:(e,t,n)=>{const o=zn(e,t,n);if(!o.props.length||1===t.tagType)return o;const{tag:r}=t,s=n.isCustomElement(r);if("input"===r||"textarea"===r||"select"===r||s){let e=lo,i=!1;if("input"===r||s){const n=Ue(t,"type");if(n){if(7===n.type)e=po;else if(n.value)switch(n.value.content){case"radio":e=io;break;case"checkbox":e=co;break;case"file":i=!0}}else Ge(t)&&(e=po)}else"select"===r&&(e=ao);i||(o.needRuntime=n.helper(e))}return o.props=o.props.filter((e=>!(4===e.key.type&&"modelValue"===e.key.content))),o},on:(e,t,n)=>Hn(e,t,n,(t=>{const{modifiers:o}=e;if(!o.length)return t;let{key:r,value:s}=t.props[0];const{keyModifiers:i,nonKeyModifiers:c,eventOptionModifiers:l}=((e,t,n,o)=>{const r=[],s=[],i=[];for(let c=0;c<t.length;c++){const o=t[c];"native"===o&&pt("COMPILER_V_ON_NATIVE",n)||_o(o)?i.push(o):To(o)?Me(e)?ko(e.content)?r.push(o):s.push(o):(r.push(o),s.push(o)):xo(o)?s.push(o):r.push(o)}return{keyModifiers:r,nonKeyModifiers:s,eventOptionModifiers:i}})(r,o,n);if(c.includes("right")&&(r=Oo(r,"onContextmenu")),c.includes("middle")&&(r=Oo(r,"onMouseup")),c.length&&(s=Te(n.helper(uo),[s,JSON.stringify(c)])),!i.length||Me(r)&&!ko(r.content)||(s=Te(n.helper(fo),[s,JSON.stringify(i)])),l.length){const e=l.map(T).join("");r=Me(r)?_e(`${r.content}${e}`,!0):xe(["(",r,`) + "${e}"`])}return{props:[Ne(r,s)]}})),show:(e,t,n)=>({props:[],needRuntime:n.helper(ho)})};return e.BASE_TRANSITION=$,e.CAMELIZE=re,e.CAPITALIZE=se,e.CREATE_BLOCK=V,e.CREATE_COMMENT=F,e.CREATE_ELEMENT_BLOCK=A,e.CREATE_ELEMENT_VNODE=B,e.CREATE_SLOTS=Z,e.CREATE_STATIC=H,e.CREATE_TEXT=j,e.CREATE_VNODE=D,e.DOMDirectiveTransforms=Mo,e.DOMNodeTransforms=Io,e.FRAGMENT=M,e.GUARD_REACTIVE_PROPS=ne,e.IS_MEMO_SAME=he,e.IS_REF=fe,e.KEEP_ALIVE=w,e.MERGE_PROPS=X,e.NORMALIZE_CLASS=Q,e.NORMALIZE_PROPS=te,e.NORMALIZE_STYLE=ee,e.OPEN_BLOCK=L,e.POP_SCOPE_ID=ae,e.PUSH_SCOPE_ID=le,e.RENDER_LIST=z,e.RENDER_SLOT=Y,e.RESOLVE_COMPONENT=W,e.RESOLVE_DIRECTIVE=U,e.RESOLVE_DYNAMIC_COMPONENT=K,e.RESOLVE_FILTER=J,e.SET_BLOCK_TRACKING=ce,e.SUSPENSE=P,e.TELEPORT=R,e.TO_DISPLAY_STRING=q,e.TO_HANDLERS=oe,e.TO_HANDLER_KEY=ie,e.TRANSITION=mo,e.TRANSITION_GROUP=go,e.UNREF=ue,e.V_MODEL_CHECKBOX=co,e.V_MODEL_DYNAMIC=po,e.V_MODEL_RADIO=io,e.V_MODEL_SELECT=ao,e.V_MODEL_TEXT=lo,e.V_ON_WITH_KEYS=fo,e.V_ON_WITH_MODIFIERS=uo,e.V_SHOW=ho,e.WITH_CTX=pe,e.WITH_DIRECTIVES=G,e.WITH_MEMO=de,e.advancePositionWithClone=He,e.advancePositionWithMutation=We,e.assert=function(e,t){if(!e)throw new Error(t||"unexpected compiler condition")},e.baseCompile=ro,e.baseParse=ht,e.buildDirectiveArgs=An,e.buildProps=$n,e.buildSlots=On,e.checkCompatEnabled=pt,e.compile=function(e,t={}){return ro(e,d({},So,t,{nodeTransforms:[Co,...Io,...t.nodeTransforms||[]],directiveTransforms:d({},Mo,t.directiveTransforms||{}),transformHoist:null}))},e.createArrayExpression=be,e.createAssignmentExpression=function(e,t){return{type:24,left:e,right:t,loc:ye}},e.createBlockStatement=Ie,e.createCacheExpression=Ce,e.createCallExpression=Te,e.createCompilerError=I,e.createCompoundExpression=xe,e.createConditionalExpression=Oe,e.createDOMCompilerError=No,e.createForLoopParams=_n,e.createFunctionExpression=ke,e.createIfStatement=function(e,t,n){return{type:23,test:e,consequent:t,alternate:n,loc:ye}},e.createInterpolation=function(e,t){return{type:5,loc:t,content:m(e)?_e(e,!1,t):e}},e.createObjectExpression=Ee,e.createObjectProperty=Ne,e.createReturnStatement=function(e){return{type:26,returns:e,loc:ye}},e.createRoot=ve,e.createSequenceExpression=function(e){return{type:25,expressions:e,loc:ye}},e.createSimpleExpression=_e,e.createStructuralDirectiveTransform=Yt,e.createTemplateLiteral=function(e){return{type:22,elements:e,loc:ye}},e.createTransformContext=Jt,e.createVNodeCall=Se,e.extractIdentifiers=ln,e.findDir=Ke,e.findProp=Ue,e.generate=Qt,e.generateCodeFrame=function(e,t=0,n=e.length){let o=e.split(/(\r?\n)/);const r=o.filter(((e,t)=>t%2==1));o=o.filter(((e,t)=>t%2==0));let s=0;const i=[];for(let c=0;c<o.length;c++)if(s+=o[c].length+(r[c]&&r[c].length||0),s>=t){for(let e=c-2;e<=c+2||n>s;e++){if(e<0||e>=o.length)continue;const l=e+1;i.push(`${l}${" ".repeat(Math.max(3-String(l).length,0))}|  ${o[e]}`);const a=o[e].length,p=r[e]&&r[e].length||0;if(e===c){const e=t-(s-(a+p)),o=Math.max(1,n>s?a-e:n-t);i.push("   |  "+" ".repeat(e)+"^".repeat(o))}else if(e>c){if(n>s){const e=Math.max(Math.min(n-s,a),1);i.push("   |  "+"^".repeat(e))}s+=a+p}}break}return i.join("\n")},e.getBaseTransformPreset=oo,e.getConstantType=Ft,e.getInnerRange=je,e.getMemoedVNodeCall=st,e.getVNodeBlockHelper=Qe,e.getVNodeHelper=Xe,e.hasDynamicKeyVBind=Ge,e.hasScopeRef=function e(t,n){if(!t||0===Object.keys(n).length)return!1;switch(t.type){case 1:for(let o=0;o<t.props.length;o++){const r=t.props[o];if(7===r.type&&(e(r.arg,n)||e(r.exp,n)))return!0}return t.children.some((t=>e(t,n)));case 11:return!!e(t.source,n)||t.children.some((t=>e(t,n)));case 9:return t.branches.some((t=>e(t,n)));case 10:return!!e(t.condition,n)||t.children.some((t=>e(t,n)));case 4:return!t.isStatic&&$e(t.content)&&!!n[t.content];case 8:return t.children.some((t=>y(t)&&e(t,n)));case 5:case 12:return e(t.content,n);default:return!1}},e.helperNameMap=me,e.injectProp=nt,e.isBuiltInType=Re,e.isCoreComponent=Pe,e.isFunctionType=e=>/Function(?:Expression|Declaration)$|Method$/.test(e.type),e.isInDestructureAssignment=function(e,t){if(e&&("ObjectProperty"===e.type||"ArrayPattern"===e.type)){let e=t.length;for(;e--;){const n=t[e];if("AssignmentExpression"===n.type)return!0;if("ObjectProperty"!==n.type&&!n.type.endsWith("Pattern"))break}}return!1},e.isMemberExpression=Fe,e.isMemberExpressionBrowser=De,e.isMemberExpressionNode=Be,e.isReferencedIdentifier=function(e,t,n){return!1},e.isSimpleIdentifier=$e,e.isSlotOutlet=qe,e.isStaticArgOf=Je,e.isStaticExp=Me,e.isStaticProperty=an,e.isStaticPropertyKey=(e,t)=>an(t)&&t.key===e,e.isTemplateNode=Ze,e.isText=ze,e.isVSlot=Ye,e.locStub=ye,e.makeBlock=it,e.noopDirectiveTransform=so,e.parse=function(e,t={}){return ht(e,d({},So,t))},e.parserOptions=So,e.processExpression=pn,e.processFor=yn,e.processIf=fn,e.processSlotOutlet=Fn,e.registerRuntimeHelpers=ge,e.resolveComponentType=wn,e.stringifyExpression=function e(t){return m(t)?t:4===t.type?t.content:t.children.map(e).join("")},e.toValidAssetId=rt,e.trackSlotScopes=Tn,e.trackVForSlotScopes=(e,t)=>{let n;if(Ze(e)&&e.props.some(Ye)&&(n=Ke(e,"for"))){const e=n.parseResult=En(n.exp);if(e){const{value:n,key:o,index:r}=e,{addIdentifiers:s,removeIdentifiers:i}=t;return n&&s(n),o&&s(o),r&&s(r),()=>{n&&i(n),o&&i(o),r&&i(r)}}}},e.transform=Gt,e.transformBind=Wn,e.transformElement=Pn,e.transformExpression=(e,t)=>{if(5===e.type)e.content=pn(e.content,t);else if(1===e.type)for(let n=0;n<e.props.length;n++){const o=e.props[n];if(7===o.type&&"for"!==o.name){const e=o.exp,n=o.arg;!e||4!==e.type||"on"===o.name&&n||(o.exp=pn(e,t,"slot"===o.name)),n&&4===n.type&&!n.isStatic&&(o.arg=pn(n,t))}}},e.transformModel=zn,e.transformOn=Hn,e.transformStyle=bo,e.traverseNode=zt,e.walkBlockDeclarations=function(e,t){for(const n of e.body)if("VariableDeclaration"===n.type){if(n.declare)continue;for(const e of n.declarations)for(const n of ln(e.id))t(n)}else if("FunctionDeclaration"===n.type||"ClassDeclaration"===n.type){if(n.declare||!n.id)continue;t(n.id)}},e.walkFunctionParams=function(e,t){for(const n of e.params)for(const e of ln(n))t(e)},e.walkIdentifiers=function(e,t,n=!1,o=[],r=Object.create(null)){},e.warnDeprecation=function(e,t,n,...o){if("suppress-warning"===lt(e,t))return;const{message:r,link:s}=ct[e],i=`(deprecation ${e}) ${"function"==typeof r?r(...o):r}${s?`\n  Details: ${s}`:""}`,c=new SyntaxError(i);c.code=e,n&&(c.loc=n),t.onWarn(c)},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
ª/README.mdÄ# @vue/compiler-dom©/index.jsÄ½'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./dist/compiler-dom.cjs.prod.js')
} else {
  module.exports = require('./dist/compiler-dom.cjs.js')
}
¾/dist/compiler-dom.cjs.prod.jsÆ (å'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compilerCore = require('@vue/compiler-core');
var shared = require('@vue/shared');

const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(``);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(``);
const V_MODEL_DYNAMIC = Symbol(``);
const V_ON_WITH_MODIFIERS = Symbol(``);
const V_ON_WITH_KEYS = Symbol(``);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(``);
compilerCore.registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

var namedCharacterReferences = {
	GT: ">",
	gt: ">",
	LT: "<",
	lt: "<",
	"ac;": "âˆ¾",
	"af;": "â¡",
	AMP: "&",
	amp: "&",
	"ap;": "â‰ˆ",
	"DD;": "â……",
	"dd;": "â…†",
	deg: "Â°",
	"ee;": "â…‡",
	"eg;": "âªš",
	"el;": "âª™",
	ETH: "Ã",
	eth: "Ã°",
	"gE;": "â‰§",
	"ge;": "â‰¥",
	"Gg;": "â‹™",
	"gg;": "â‰«",
	"gl;": "â‰·",
	"GT;": ">",
	"Gt;": "â‰«",
	"gt;": ">",
	"ic;": "â£",
	"ii;": "â…ˆ",
	"Im;": "â„‘",
	"in;": "âˆˆ",
	"it;": "â¢",
	"lE;": "â‰¦",
	"le;": "â‰¤",
	"lg;": "â‰¶",
	"Ll;": "â‹˜",
	"ll;": "â‰ª",
	"LT;": "<",
	"Lt;": "â‰ª",
	"lt;": "<",
	"mp;": "âˆ“",
	"Mu;": "Îœ",
	"mu;": "Î¼",
	"ne;": "â‰ ",
	"ni;": "âˆ‹",
	not: "Â¬",
	"Nu;": "Î",
	"nu;": "Î½",
	"Or;": "â©”",
	"or;": "âˆ¨",
	"oS;": "â“ˆ",
	"Pi;": "Î ",
	"pi;": "Ï€",
	"pm;": "Â±",
	"Pr;": "âª»",
	"pr;": "â‰º",
	"Re;": "â„œ",
	REG: "Â®",
	reg: "Â®",
	"rx;": "â„ž",
	"Sc;": "âª¼",
	"sc;": "â‰»",
	shy: "Â­",
	uml: "Â¨",
	"wp;": "â„˜",
	"wr;": "â‰€",
	"Xi;": "Îž",
	"xi;": "Î¾",
	yen: "Â¥",
	"acd;": "âˆ¿",
	"acE;": "âˆ¾Ì³",
	"Acy;": "Ð",
	"acy;": "Ð°",
	"Afr;": "ð”„",
	"afr;": "ð”ž",
	"AMP;": "&",
	"amp;": "&",
	"And;": "â©“",
	"and;": "âˆ§",
	"ang;": "âˆ ",
	"apE;": "â©°",
	"ape;": "â‰Š",
	"ast;": "*",
	Auml: "Ã„",
	auml: "Ã¤",
	"Bcy;": "Ð‘",
	"bcy;": "Ð±",
	"Bfr;": "ð”…",
	"bfr;": "ð”Ÿ",
	"bne;": "=âƒ¥",
	"bot;": "âŠ¥",
	"Cap;": "â‹’",
	"cap;": "âˆ©",
	cent: "Â¢",
	"Cfr;": "â„­",
	"cfr;": "ð” ",
	"Chi;": "Î§",
	"chi;": "Ï‡",
	"cir;": "â—‹",
	COPY: "Â©",
	copy: "Â©",
	"Cup;": "â‹“",
	"cup;": "âˆª",
	"Dcy;": "Ð”",
	"dcy;": "Ð´",
	"deg;": "Â°",
	"Del;": "âˆ‡",
	"Dfr;": "ð”‡",
	"dfr;": "ð”¡",
	"die;": "Â¨",
	"div;": "Ã·",
	"Dot;": "Â¨",
	"dot;": "Ë™",
	"Ecy;": "Ð­",
	"ecy;": "Ñ",
	"Efr;": "ð”ˆ",
	"efr;": "ð”¢",
	"egs;": "âª–",
	"ell;": "â„“",
	"els;": "âª•",
	"ENG;": "ÅŠ",
	"eng;": "Å‹",
	"Eta;": "Î—",
	"eta;": "Î·",
	"ETH;": "Ã",
	"eth;": "Ã°",
	Euml: "Ã‹",
	euml: "Ã«",
	"Fcy;": "Ð¤",
	"fcy;": "Ñ„",
	"Ffr;": "ð”‰",
	"ffr;": "ð”£",
	"gap;": "âª†",
	"Gcy;": "Ð“",
	"gcy;": "Ð³",
	"gEl;": "âªŒ",
	"gel;": "â‹›",
	"geq;": "â‰¥",
	"ges;": "â©¾",
	"Gfr;": "ð”Š",
	"gfr;": "ð”¤",
	"ggg;": "â‹™",
	"gla;": "âª¥",
	"glE;": "âª’",
	"glj;": "âª¤",
	"gnE;": "â‰©",
	"gne;": "âªˆ",
	"Hat;": "^",
	"Hfr;": "â„Œ",
	"hfr;": "ð”¥",
	"Icy;": "Ð˜",
	"icy;": "Ð¸",
	"iff;": "â‡”",
	"Ifr;": "â„‘",
	"ifr;": "ð”¦",
	"Int;": "âˆ¬",
	"int;": "âˆ«",
	Iuml: "Ã",
	iuml: "Ã¯",
	"Jcy;": "Ð™",
	"jcy;": "Ð¹",
	"Jfr;": "ð”",
	"jfr;": "ð”§",
	"Kcy;": "Ðš",
	"kcy;": "Ðº",
	"Kfr;": "ð”Ž",
	"kfr;": "ð”¨",
	"lap;": "âª…",
	"lat;": "âª«",
	"Lcy;": "Ð›",
	"lcy;": "Ð»",
	"lEg;": "âª‹",
	"leg;": "â‹š",
	"leq;": "â‰¤",
	"les;": "â©½",
	"Lfr;": "ð”",
	"lfr;": "ð”©",
	"lgE;": "âª‘",
	"lnE;": "â‰¨",
	"lne;": "âª‡",
	"loz;": "â—Š",
	"lrm;": "â€Ž",
	"Lsh;": "â†°",
	"lsh;": "â†°",
	macr: "Â¯",
	"Map;": "â¤…",
	"map;": "â†¦",
	"Mcy;": "Ðœ",
	"mcy;": "Ð¼",
	"Mfr;": "ð”",
	"mfr;": "ð”ª",
	"mho;": "â„§",
	"mid;": "âˆ£",
	"nap;": "â‰‰",
	nbsp: "Â ",
	"Ncy;": "Ð",
	"ncy;": "Ð½",
	"Nfr;": "ð”‘",
	"nfr;": "ð”«",
	"ngE;": "â‰§Ì¸",
	"nge;": "â‰±",
	"nGg;": "â‹™Ì¸",
	"nGt;": "â‰«âƒ’",
	"ngt;": "â‰¯",
	"nis;": "â‹¼",
	"niv;": "âˆ‹",
	"nlE;": "â‰¦Ì¸",
	"nle;": "â‰°",
	"nLl;": "â‹˜Ì¸",
	"nLt;": "â‰ªâƒ’",
	"nlt;": "â‰®",
	"Not;": "â«¬",
	"not;": "Â¬",
	"npr;": "âŠ€",
	"nsc;": "âŠ",
	"num;": "#",
	"Ocy;": "Ðž",
	"ocy;": "Ð¾",
	"Ofr;": "ð”’",
	"ofr;": "ð”¬",
	"ogt;": "â§",
	"ohm;": "Î©",
	"olt;": "â§€",
	"ord;": "â©",
	ordf: "Âª",
	ordm: "Âº",
	"orv;": "â©›",
	Ouml: "Ã–",
	ouml: "Ã¶",
	"par;": "âˆ¥",
	para: "Â¶",
	"Pcy;": "ÐŸ",
	"pcy;": "Ð¿",
	"Pfr;": "ð”“",
	"pfr;": "ð”­",
	"Phi;": "Î¦",
	"phi;": "Ï†",
	"piv;": "Ï–",
	"prE;": "âª³",
	"pre;": "âª¯",
	"Psi;": "Î¨",
	"psi;": "Ïˆ",
	"Qfr;": "ð””",
	"qfr;": "ð”®",
	QUOT: "\"",
	quot: "\"",
	"Rcy;": "Ð ",
	"rcy;": "Ñ€",
	"REG;": "Â®",
	"reg;": "Â®",
	"Rfr;": "â„œ",
	"rfr;": "ð”¯",
	"Rho;": "Î¡",
	"rho;": "Ï",
	"rlm;": "â€",
	"Rsh;": "â†±",
	"rsh;": "â†±",
	"scE;": "âª´",
	"sce;": "âª°",
	"Scy;": "Ð¡",
	"scy;": "Ñ",
	sect: "Â§",
	"Sfr;": "ð”–",
	"sfr;": "ð”°",
	"shy;": "Â­",
	"sim;": "âˆ¼",
	"smt;": "âªª",
	"sol;": "/",
	"squ;": "â–¡",
	"Sub;": "â‹",
	"sub;": "âŠ‚",
	"Sum;": "âˆ‘",
	"sum;": "âˆ‘",
	"Sup;": "â‹‘",
	"sup;": "âŠƒ",
	sup1: "Â¹",
	sup2: "Â²",
	sup3: "Â³",
	"Tab;": "\t",
	"Tau;": "Î¤",
	"tau;": "Ï„",
	"Tcy;": "Ð¢",
	"tcy;": "Ñ‚",
	"Tfr;": "ð”—",
	"tfr;": "ð”±",
	"top;": "âŠ¤",
	"Ucy;": "Ð£",
	"ucy;": "Ñƒ",
	"Ufr;": "ð”˜",
	"ufr;": "ð”²",
	"uml;": "Â¨",
	Uuml: "Ãœ",
	uuml: "Ã¼",
	"Vcy;": "Ð’",
	"vcy;": "Ð²",
	"Vee;": "â‹",
	"vee;": "âˆ¨",
	"Vfr;": "ð”™",
	"vfr;": "ð”³",
	"Wfr;": "ð”š",
	"wfr;": "ð”´",
	"Xfr;": "ð”›",
	"xfr;": "ð”µ",
	"Ycy;": "Ð«",
	"ycy;": "Ñ‹",
	"yen;": "Â¥",
	"Yfr;": "ð”œ",
	"yfr;": "ð”¶",
	yuml: "Ã¿",
	"Zcy;": "Ð—",
	"zcy;": "Ð·",
	"Zfr;": "â„¨",
	"zfr;": "ð”·",
	"zwj;": "â€",
	Acirc: "Ã‚",
	acirc: "Ã¢",
	acute: "Â´",
	AElig: "Ã†",
	aelig: "Ã¦",
	"andd;": "â©œ",
	"andv;": "â©š",
	"ange;": "â¦¤",
	"Aopf;": "ð”¸",
	"aopf;": "ð•’",
	"apid;": "â‰‹",
	"apos;": "'",
	Aring: "Ã…",
	aring: "Ã¥",
	"Ascr;": "ð’œ",
	"ascr;": "ð’¶",
	"Auml;": "Ã„",
	"auml;": "Ã¤",
	"Barv;": "â«§",
	"bbrk;": "âŽµ",
	"Beta;": "Î’",
	"beta;": "Î²",
	"beth;": "â„¶",
	"bNot;": "â«­",
	"bnot;": "âŒ",
	"Bopf;": "ð”¹",
	"bopf;": "ð•“",
	"boxH;": "â•",
	"boxh;": "â”€",
	"boxV;": "â•‘",
	"boxv;": "â”‚",
	"Bscr;": "â„¬",
	"bscr;": "ð’·",
	"bsim;": "âˆ½",
	"bsol;": "\\",
	"bull;": "â€¢",
	"bump;": "â‰Ž",
	"caps;": "âˆ©ï¸€",
	"Cdot;": "ÄŠ",
	"cdot;": "Ä‹",
	cedil: "Â¸",
	"cent;": "Â¢",
	"CHcy;": "Ð§",
	"chcy;": "Ñ‡",
	"circ;": "Ë†",
	"cirE;": "â§ƒ",
	"cire;": "â‰—",
	"comp;": "âˆ",
	"cong;": "â‰…",
	"Copf;": "â„‚",
	"copf;": "ð•”",
	"COPY;": "Â©",
	"copy;": "Â©",
	"Cscr;": "ð’ž",
	"cscr;": "ð’¸",
	"csub;": "â«",
	"csup;": "â«",
	"cups;": "âˆªï¸€",
	"Darr;": "â†¡",
	"dArr;": "â‡“",
	"darr;": "â†“",
	"dash;": "â€",
	"dHar;": "â¥¥",
	"diam;": "â‹„",
	"DJcy;": "Ð‚",
	"djcy;": "Ñ’",
	"Dopf;": "ð”»",
	"dopf;": "ð••",
	"Dscr;": "ð’Ÿ",
	"dscr;": "ð’¹",
	"DScy;": "Ð…",
	"dscy;": "Ñ•",
	"dsol;": "â§¶",
	"dtri;": "â–¿",
	"DZcy;": "Ð",
	"dzcy;": "ÑŸ",
	"ecir;": "â‰–",
	Ecirc: "ÃŠ",
	ecirc: "Ãª",
	"Edot;": "Ä–",
	"eDot;": "â‰‘",
	"edot;": "Ä—",
	"emsp;": "â€ƒ",
	"ensp;": "â€‚",
	"Eopf;": "ð”¼",
	"eopf;": "ð•–",
	"epar;": "â‹•",
	"epsi;": "Îµ",
	"Escr;": "â„°",
	"escr;": "â„¯",
	"Esim;": "â©³",
	"esim;": "â‰‚",
	"Euml;": "Ã‹",
	"euml;": "Ã«",
	"euro;": "â‚¬",
	"excl;": "!",
	"flat;": "â™­",
	"fnof;": "Æ’",
	"Fopf;": "ð”½",
	"fopf;": "ð•—",
	"fork;": "â‹”",
	"Fscr;": "â„±",
	"fscr;": "ð’»",
	"Gdot;": "Ä ",
	"gdot;": "Ä¡",
	"geqq;": "â‰§",
	"gesl;": "â‹›ï¸€",
	"GJcy;": "Ðƒ",
	"gjcy;": "Ñ“",
	"gnap;": "âªŠ",
	"gneq;": "âªˆ",
	"Gopf;": "ð”¾",
	"gopf;": "ð•˜",
	"Gscr;": "ð’¢",
	"gscr;": "â„Š",
	"gsim;": "â‰³",
	"gtcc;": "âª§",
	"gvnE;": "â‰©ï¸€",
	"half;": "Â½",
	"hArr;": "â‡”",
	"harr;": "â†”",
	"hbar;": "â„",
	"Hopf;": "â„",
	"hopf;": "ð•™",
	"Hscr;": "â„‹",
	"hscr;": "ð’½",
	Icirc: "ÃŽ",
	icirc: "Ã®",
	"Idot;": "Ä°",
	"IEcy;": "Ð•",
	"iecy;": "Ðµ",
	iexcl: "Â¡",
	"imof;": "âŠ·",
	"IOcy;": "Ð",
	"iocy;": "Ñ‘",
	"Iopf;": "ð•€",
	"iopf;": "ð•š",
	"Iota;": "Î™",
	"iota;": "Î¹",
	"Iscr;": "â„",
	"iscr;": "ð’¾",
	"isin;": "âˆˆ",
	"Iuml;": "Ã",
	"iuml;": "Ã¯",
	"Jopf;": "ð•",
	"jopf;": "ð•›",
	"Jscr;": "ð’¥",
	"jscr;": "ð’¿",
	"KHcy;": "Ð¥",
	"khcy;": "Ñ…",
	"KJcy;": "ÐŒ",
	"kjcy;": "Ñœ",
	"Kopf;": "ð•‚",
	"kopf;": "ð•œ",
	"Kscr;": "ð’¦",
	"kscr;": "ð“€",
	"Lang;": "âŸª",
	"lang;": "âŸ¨",
	laquo: "Â«",
	"Larr;": "â†ž",
	"lArr;": "â‡",
	"larr;": "â†",
	"late;": "âª­",
	"lcub;": "{",
	"ldca;": "â¤¶",
	"ldsh;": "â†²",
	"leqq;": "â‰¦",
	"lesg;": "â‹šï¸€",
	"lHar;": "â¥¢",
	"LJcy;": "Ð‰",
	"ljcy;": "Ñ™",
	"lnap;": "âª‰",
	"lneq;": "âª‡",
	"Lopf;": "ð•ƒ",
	"lopf;": "ð•",
	"lozf;": "â§«",
	"lpar;": "(",
	"Lscr;": "â„’",
	"lscr;": "ð“",
	"lsim;": "â‰²",
	"lsqb;": "[",
	"ltcc;": "âª¦",
	"ltri;": "â—ƒ",
	"lvnE;": "â‰¨ï¸€",
	"macr;": "Â¯",
	"male;": "â™‚",
	"malt;": "âœ ",
	micro: "Âµ",
	"mlcp;": "â«›",
	"mldr;": "â€¦",
	"Mopf;": "ð•„",
	"mopf;": "ð•ž",
	"Mscr;": "â„³",
	"mscr;": "ð“‚",
	"nang;": "âˆ âƒ’",
	"napE;": "â©°Ì¸",
	"nbsp;": "Â ",
	"ncap;": "â©ƒ",
	"ncup;": "â©‚",
	"ngeq;": "â‰±",
	"nges;": "â©¾Ì¸",
	"ngtr;": "â‰¯",
	"nGtv;": "â‰«Ì¸",
	"nisd;": "â‹º",
	"NJcy;": "ÐŠ",
	"njcy;": "Ñš",
	"nldr;": "â€¥",
	"nleq;": "â‰°",
	"nles;": "â©½Ì¸",
	"nLtv;": "â‰ªÌ¸",
	"nmid;": "âˆ¤",
	"Nopf;": "â„•",
	"nopf;": "ð•Ÿ",
	"npar;": "âˆ¦",
	"npre;": "âª¯Ì¸",
	"nsce;": "âª°Ì¸",
	"Nscr;": "ð’©",
	"nscr;": "ð“ƒ",
	"nsim;": "â‰",
	"nsub;": "âŠ„",
	"nsup;": "âŠ…",
	"ntgl;": "â‰¹",
	"ntlg;": "â‰¸",
	"nvap;": "â‰âƒ’",
	"nvge;": "â‰¥âƒ’",
	"nvgt;": ">âƒ’",
	"nvle;": "â‰¤âƒ’",
	"nvlt;": "<âƒ’",
	"oast;": "âŠ›",
	"ocir;": "âŠš",
	Ocirc: "Ã”",
	ocirc: "Ã´",
	"odiv;": "â¨¸",
	"odot;": "âŠ™",
	"ogon;": "Ë›",
	"oint;": "âˆ®",
	"omid;": "â¦¶",
	"Oopf;": "ð•†",
	"oopf;": "ð• ",
	"opar;": "â¦·",
	"ordf;": "Âª",
	"ordm;": "Âº",
	"oror;": "â©–",
	"Oscr;": "ð’ª",
	"oscr;": "â„´",
	"osol;": "âŠ˜",
	"Ouml;": "Ã–",
	"ouml;": "Ã¶",
	"para;": "Â¶",
	"part;": "âˆ‚",
	"perp;": "âŠ¥",
	"phiv;": "Ï•",
	"plus;": "+",
	"Popf;": "â„™",
	"popf;": "ð•¡",
	pound: "Â£",
	"prap;": "âª·",
	"prec;": "â‰º",
	"prnE;": "âªµ",
	"prod;": "âˆ",
	"prop;": "âˆ",
	"Pscr;": "ð’«",
	"pscr;": "ð“…",
	"qint;": "â¨Œ",
	"Qopf;": "â„š",
	"qopf;": "ð•¢",
	"Qscr;": "ð’¬",
	"qscr;": "ð“†",
	"QUOT;": "\"",
	"quot;": "\"",
	"race;": "âˆ½Ì±",
	"Rang;": "âŸ«",
	"rang;": "âŸ©",
	raquo: "Â»",
	"Rarr;": "â† ",
	"rArr;": "â‡’",
	"rarr;": "â†’",
	"rcub;": "}",
	"rdca;": "â¤·",
	"rdsh;": "â†³",
	"real;": "â„œ",
	"rect;": "â–­",
	"rHar;": "â¥¤",
	"rhov;": "Ï±",
	"ring;": "Ëš",
	"Ropf;": "â„",
	"ropf;": "ð•£",
	"rpar;": ")",
	"Rscr;": "â„›",
	"rscr;": "ð“‡",
	"rsqb;": "]",
	"rtri;": "â–¹",
	"scap;": "âª¸",
	"scnE;": "âª¶",
	"sdot;": "â‹…",
	"sect;": "Â§",
	"semi;": ";",
	"sext;": "âœ¶",
	"SHcy;": "Ð¨",
	"shcy;": "Ñˆ",
	"sime;": "â‰ƒ",
	"simg;": "âªž",
	"siml;": "âª",
	"smid;": "âˆ£",
	"smte;": "âª¬",
	"solb;": "â§„",
	"Sopf;": "ð•Š",
	"sopf;": "ð•¤",
	"spar;": "âˆ¥",
	"Sqrt;": "âˆš",
	"squf;": "â–ª",
	"Sscr;": "ð’®",
	"sscr;": "ð“ˆ",
	"Star;": "â‹†",
	"star;": "â˜†",
	"subE;": "â«…",
	"sube;": "âŠ†",
	"succ;": "â‰»",
	"sung;": "â™ª",
	"sup1;": "Â¹",
	"sup2;": "Â²",
	"sup3;": "Â³",
	"supE;": "â«†",
	"supe;": "âŠ‡",
	szlig: "ÃŸ",
	"tbrk;": "âŽ´",
	"tdot;": "âƒ›",
	THORN: "Ãž",
	thorn: "Ã¾",
	times: "Ã—",
	"tint;": "âˆ­",
	"toea;": "â¤¨",
	"Topf;": "ð•‹",
	"topf;": "ð•¥",
	"tosa;": "â¤©",
	"trie;": "â‰œ",
	"Tscr;": "ð’¯",
	"tscr;": "ð“‰",
	"TScy;": "Ð¦",
	"tscy;": "Ñ†",
	"Uarr;": "â†Ÿ",
	"uArr;": "â‡‘",
	"uarr;": "â†‘",
	Ucirc: "Ã›",
	ucirc: "Ã»",
	"uHar;": "â¥£",
	"Uopf;": "ð•Œ",
	"uopf;": "ð•¦",
	"Upsi;": "Ï’",
	"upsi;": "Ï…",
	"Uscr;": "ð’°",
	"uscr;": "ð“Š",
	"utri;": "â–µ",
	"Uuml;": "Ãœ",
	"uuml;": "Ã¼",
	"vArr;": "â‡•",
	"varr;": "â†•",
	"Vbar;": "â««",
	"vBar;": "â«¨",
	"Vert;": "â€–",
	"vert;": "|",
	"Vopf;": "ð•",
	"vopf;": "ð•§",
	"Vscr;": "ð’±",
	"vscr;": "ð“‹",
	"Wopf;": "ð•Ž",
	"wopf;": "ð•¨",
	"Wscr;": "ð’²",
	"wscr;": "ð“Œ",
	"xcap;": "â‹‚",
	"xcup;": "â‹ƒ",
	"xmap;": "âŸ¼",
	"xnis;": "â‹»",
	"Xopf;": "ð•",
	"xopf;": "ð•©",
	"Xscr;": "ð’³",
	"xscr;": "ð“",
	"xvee;": "â‹",
	"YAcy;": "Ð¯",
	"yacy;": "Ñ",
	"YIcy;": "Ð‡",
	"yicy;": "Ñ—",
	"Yopf;": "ð•",
	"yopf;": "ð•ª",
	"Yscr;": "ð’´",
	"yscr;": "ð“Ž",
	"YUcy;": "Ð®",
	"yucy;": "ÑŽ",
	"Yuml;": "Å¸",
	"yuml;": "Ã¿",
	"Zdot;": "Å»",
	"zdot;": "Å¼",
	"Zeta;": "Î–",
	"zeta;": "Î¶",
	"ZHcy;": "Ð–",
	"zhcy;": "Ð¶",
	"Zopf;": "â„¤",
	"zopf;": "ð•«",
	"Zscr;": "ð’µ",
	"zscr;": "ð“",
	"zwnj;": "â€Œ",
	Aacute: "Ã",
	aacute: "Ã¡",
	"Acirc;": "Ã‚",
	"acirc;": "Ã¢",
	"acute;": "Â´",
	"AElig;": "Ã†",
	"aelig;": "Ã¦",
	Agrave: "Ã€",
	agrave: "Ã ",
	"aleph;": "â„µ",
	"Alpha;": "Î‘",
	"alpha;": "Î±",
	"Amacr;": "Ä€",
	"amacr;": "Ä",
	"amalg;": "â¨¿",
	"angle;": "âˆ ",
	"angrt;": "âˆŸ",
	"angst;": "Ã…",
	"Aogon;": "Ä„",
	"aogon;": "Ä…",
	"Aring;": "Ã…",
	"aring;": "Ã¥",
	"asymp;": "â‰ˆ",
	Atilde: "Ãƒ",
	atilde: "Ã£",
	"awint;": "â¨‘",
	"bcong;": "â‰Œ",
	"bdquo;": "â€ž",
	"bepsi;": "Ï¶",
	"blank;": "â£",
	"blk12;": "â–’",
	"blk14;": "â–‘",
	"blk34;": "â–“",
	"block;": "â–ˆ",
	"boxDL;": "â•—",
	"boxDl;": "â•–",
	"boxdL;": "â••",
	"boxdl;": "â”",
	"boxDR;": "â•”",
	"boxDr;": "â•“",
	"boxdR;": "â•’",
	"boxdr;": "â”Œ",
	"boxHD;": "â•¦",
	"boxHd;": "â•¤",
	"boxhD;": "â•¥",
	"boxhd;": "â”¬",
	"boxHU;": "â•©",
	"boxHu;": "â•§",
	"boxhU;": "â•¨",
	"boxhu;": "â”´",
	"boxUL;": "â•",
	"boxUl;": "â•œ",
	"boxuL;": "â•›",
	"boxul;": "â”˜",
	"boxUR;": "â•š",
	"boxUr;": "â•™",
	"boxuR;": "â•˜",
	"boxur;": "â””",
	"boxVH;": "â•¬",
	"boxVh;": "â•«",
	"boxvH;": "â•ª",
	"boxvh;": "â”¼",
	"boxVL;": "â•£",
	"boxVl;": "â•¢",
	"boxvL;": "â•¡",
	"boxvl;": "â”¤",
	"boxVR;": "â• ",
	"boxVr;": "â•Ÿ",
	"boxvR;": "â•ž",
	"boxvr;": "â”œ",
	"Breve;": "Ë˜",
	"breve;": "Ë˜",
	brvbar: "Â¦",
	"bsemi;": "â",
	"bsime;": "â‹",
	"bsolb;": "â§…",
	"bumpE;": "âª®",
	"bumpe;": "â‰",
	"caret;": "â",
	"caron;": "Ë‡",
	"ccaps;": "â©",
	Ccedil: "Ã‡",
	ccedil: "Ã§",
	"Ccirc;": "Äˆ",
	"ccirc;": "Ä‰",
	"ccups;": "â©Œ",
	"cedil;": "Â¸",
	"check;": "âœ“",
	"clubs;": "â™£",
	"Colon;": "âˆ·",
	"colon;": ":",
	"comma;": ",",
	"crarr;": "â†µ",
	"Cross;": "â¨¯",
	"cross;": "âœ—",
	"csube;": "â«‘",
	"csupe;": "â«’",
	"ctdot;": "â‹¯",
	"cuepr;": "â‹ž",
	"cuesc;": "â‹Ÿ",
	"cupor;": "â©…",
	curren: "Â¤",
	"cuvee;": "â‹Ž",
	"cuwed;": "â‹",
	"cwint;": "âˆ±",
	"Dashv;": "â«¤",
	"dashv;": "âŠ£",
	"dblac;": "Ë",
	"ddarr;": "â‡Š",
	"Delta;": "Î”",
	"delta;": "Î´",
	"dharl;": "â‡ƒ",
	"dharr;": "â‡‚",
	"diams;": "â™¦",
	"disin;": "â‹²",
	divide: "Ã·",
	"doteq;": "â‰",
	"dtdot;": "â‹±",
	"dtrif;": "â–¾",
	"duarr;": "â‡µ",
	"duhar;": "â¥¯",
	Eacute: "Ã‰",
	eacute: "Ã©",
	"Ecirc;": "ÃŠ",
	"ecirc;": "Ãª",
	"eDDot;": "â©·",
	"efDot;": "â‰’",
	Egrave: "Ãˆ",
	egrave: "Ã¨",
	"Emacr;": "Ä’",
	"emacr;": "Ä“",
	"empty;": "âˆ…",
	"Eogon;": "Ä˜",
	"eogon;": "Ä™",
	"eplus;": "â©±",
	"epsiv;": "Ïµ",
	"eqsim;": "â‰‚",
	"Equal;": "â©µ",
	"equiv;": "â‰¡",
	"erarr;": "â¥±",
	"erDot;": "â‰“",
	"esdot;": "â‰",
	"exist;": "âˆƒ",
	"fflig;": "ï¬€",
	"filig;": "ï¬",
	"fjlig;": "fj",
	"fllig;": "ï¬‚",
	"fltns;": "â–±",
	"forkv;": "â«™",
	frac12: "Â½",
	frac14: "Â¼",
	frac34: "Â¾",
	"frasl;": "â„",
	"frown;": "âŒ¢",
	"Gamma;": "Î“",
	"gamma;": "Î³",
	"Gcirc;": "Äœ",
	"gcirc;": "Ä",
	"gescc;": "âª©",
	"gimel;": "â„·",
	"gneqq;": "â‰©",
	"gnsim;": "â‹§",
	"grave;": "`",
	"gsime;": "âªŽ",
	"gsiml;": "âª",
	"gtcir;": "â©º",
	"gtdot;": "â‹—",
	"Hacek;": "Ë‡",
	"harrw;": "â†­",
	"Hcirc;": "Ä¤",
	"hcirc;": "Ä¥",
	"hoarr;": "â‡¿",
	Iacute: "Ã",
	iacute: "Ã­",
	"Icirc;": "ÃŽ",
	"icirc;": "Ã®",
	"iexcl;": "Â¡",
	Igrave: "ÃŒ",
	igrave: "Ã¬",
	"iiint;": "âˆ­",
	"iiota;": "â„©",
	"IJlig;": "Ä²",
	"ijlig;": "Ä³",
	"Imacr;": "Äª",
	"imacr;": "Ä«",
	"image;": "â„‘",
	"imath;": "Ä±",
	"imped;": "Æµ",
	"infin;": "âˆž",
	"Iogon;": "Ä®",
	"iogon;": "Ä¯",
	"iprod;": "â¨¼",
	iquest: "Â¿",
	"isinE;": "â‹¹",
	"isins;": "â‹´",
	"isinv;": "âˆˆ",
	"Iukcy;": "Ð†",
	"iukcy;": "Ñ–",
	"Jcirc;": "Ä´",
	"jcirc;": "Äµ",
	"jmath;": "È·",
	"Jukcy;": "Ð„",
	"jukcy;": "Ñ”",
	"Kappa;": "Îš",
	"kappa;": "Îº",
	"lAarr;": "â‡š",
	"langd;": "â¦‘",
	"laquo;": "Â«",
	"larrb;": "â‡¤",
	"lates;": "âª­ï¸€",
	"lBarr;": "â¤Ž",
	"lbarr;": "â¤Œ",
	"lbbrk;": "â²",
	"lbrke;": "â¦‹",
	"lceil;": "âŒˆ",
	"ldquo;": "â€œ",
	"lescc;": "âª¨",
	"lhard;": "â†½",
	"lharu;": "â†¼",
	"lhblk;": "â–„",
	"llarr;": "â‡‡",
	"lltri;": "â—º",
	"lneqq;": "â‰¨",
	"lnsim;": "â‹¦",
	"loang;": "âŸ¬",
	"loarr;": "â‡½",
	"lobrk;": "âŸ¦",
	"lopar;": "â¦…",
	"lrarr;": "â‡†",
	"lrhar;": "â‡‹",
	"lrtri;": "âŠ¿",
	"lsime;": "âª",
	"lsimg;": "âª",
	"lsquo;": "â€˜",
	"ltcir;": "â©¹",
	"ltdot;": "â‹–",
	"ltrie;": "âŠ´",
	"ltrif;": "â—‚",
	"mdash;": "â€”",
	"mDDot;": "âˆº",
	"micro;": "Âµ",
	middot: "Â·",
	"minus;": "âˆ’",
	"mumap;": "âŠ¸",
	"nabla;": "âˆ‡",
	"napid;": "â‰‹Ì¸",
	"napos;": "Å‰",
	"natur;": "â™®",
	"nbump;": "â‰ŽÌ¸",
	"ncong;": "â‰‡",
	"ndash;": "â€“",
	"neArr;": "â‡—",
	"nearr;": "â†—",
	"nedot;": "â‰Ì¸",
	"nesim;": "â‰‚Ì¸",
	"ngeqq;": "â‰§Ì¸",
	"ngsim;": "â‰µ",
	"nhArr;": "â‡Ž",
	"nharr;": "â†®",
	"nhpar;": "â«²",
	"nlArr;": "â‡",
	"nlarr;": "â†š",
	"nleqq;": "â‰¦Ì¸",
	"nless;": "â‰®",
	"nlsim;": "â‰´",
	"nltri;": "â‹ª",
	"notin;": "âˆ‰",
	"notni;": "âˆŒ",
	"npart;": "âˆ‚Ì¸",
	"nprec;": "âŠ€",
	"nrArr;": "â‡",
	"nrarr;": "â†›",
	"nrtri;": "â‹«",
	"nsime;": "â‰„",
	"nsmid;": "âˆ¤",
	"nspar;": "âˆ¦",
	"nsubE;": "â«…Ì¸",
	"nsube;": "âŠˆ",
	"nsucc;": "âŠ",
	"nsupE;": "â«†Ì¸",
	"nsupe;": "âŠ‰",
	Ntilde: "Ã‘",
	ntilde: "Ã±",
	"numsp;": "â€‡",
	"nvsim;": "âˆ¼âƒ’",
	"nwArr;": "â‡–",
	"nwarr;": "â†–",
	Oacute: "Ã“",
	oacute: "Ã³",
	"Ocirc;": "Ã”",
	"ocirc;": "Ã´",
	"odash;": "âŠ",
	"OElig;": "Å’",
	"oelig;": "Å“",
	"ofcir;": "â¦¿",
	Ograve: "Ã’",
	ograve: "Ã²",
	"ohbar;": "â¦µ",
	"olarr;": "â†º",
	"olcir;": "â¦¾",
	"oline;": "â€¾",
	"Omacr;": "ÅŒ",
	"omacr;": "Å",
	"Omega;": "Î©",
	"omega;": "Ï‰",
	"operp;": "â¦¹",
	"oplus;": "âŠ•",
	"orarr;": "â†»",
	"order;": "â„´",
	Oslash: "Ã˜",
	oslash: "Ã¸",
	Otilde: "Ã•",
	otilde: "Ãµ",
	"ovbar;": "âŒ½",
	"parsl;": "â«½",
	"phone;": "â˜Ž",
	"plusb;": "âŠž",
	"pluse;": "â©²",
	plusmn: "Â±",
	"pound;": "Â£",
	"prcue;": "â‰¼",
	"Prime;": "â€³",
	"prime;": "â€²",
	"prnap;": "âª¹",
	"prsim;": "â‰¾",
	"quest;": "?",
	"rAarr;": "â‡›",
	"radic;": "âˆš",
	"rangd;": "â¦’",
	"range;": "â¦¥",
	"raquo;": "Â»",
	"rarrb;": "â‡¥",
	"rarrc;": "â¤³",
	"rarrw;": "â†",
	"ratio;": "âˆ¶",
	"RBarr;": "â¤",
	"rBarr;": "â¤",
	"rbarr;": "â¤",
	"rbbrk;": "â³",
	"rbrke;": "â¦Œ",
	"rceil;": "âŒ‰",
	"rdquo;": "â€",
	"reals;": "â„",
	"rhard;": "â‡",
	"rharu;": "â‡€",
	"rlarr;": "â‡„",
	"rlhar;": "â‡Œ",
	"rnmid;": "â«®",
	"roang;": "âŸ­",
	"roarr;": "â‡¾",
	"robrk;": "âŸ§",
	"ropar;": "â¦†",
	"rrarr;": "â‡‰",
	"rsquo;": "â€™",
	"rtrie;": "âŠµ",
	"rtrif;": "â–¸",
	"sbquo;": "â€š",
	"sccue;": "â‰½",
	"Scirc;": "Åœ",
	"scirc;": "Å",
	"scnap;": "âªº",
	"scsim;": "â‰¿",
	"sdotb;": "âŠ¡",
	"sdote;": "â©¦",
	"seArr;": "â‡˜",
	"searr;": "â†˜",
	"setmn;": "âˆ–",
	"sharp;": "â™¯",
	"Sigma;": "Î£",
	"sigma;": "Ïƒ",
	"simeq;": "â‰ƒ",
	"simgE;": "âª ",
	"simlE;": "âªŸ",
	"simne;": "â‰†",
	"slarr;": "â†",
	"smile;": "âŒ£",
	"smtes;": "âª¬ï¸€",
	"sqcap;": "âŠ“",
	"sqcup;": "âŠ”",
	"sqsub;": "âŠ",
	"sqsup;": "âŠ",
	"srarr;": "â†’",
	"starf;": "â˜…",
	"strns;": "Â¯",
	"subnE;": "â«‹",
	"subne;": "âŠŠ",
	"supnE;": "â«Œ",
	"supne;": "âŠ‹",
	"swArr;": "â‡™",
	"swarr;": "â†™",
	"szlig;": "ÃŸ",
	"Theta;": "Î˜",
	"theta;": "Î¸",
	"thkap;": "â‰ˆ",
	"THORN;": "Ãž",
	"thorn;": "Ã¾",
	"Tilde;": "âˆ¼",
	"tilde;": "Ëœ",
	"times;": "Ã—",
	"TRADE;": "â„¢",
	"trade;": "â„¢",
	"trisb;": "â§",
	"TSHcy;": "Ð‹",
	"tshcy;": "Ñ›",
	"twixt;": "â‰¬",
	Uacute: "Ãš",
	uacute: "Ãº",
	"Ubrcy;": "ÐŽ",
	"ubrcy;": "Ñž",
	"Ucirc;": "Ã›",
	"ucirc;": "Ã»",
	"udarr;": "â‡…",
	"udhar;": "â¥®",
	Ugrave: "Ã™",
	ugrave: "Ã¹",
	"uharl;": "â†¿",
	"uharr;": "â†¾",
	"uhblk;": "â–€",
	"ultri;": "â—¸",
	"Umacr;": "Åª",
	"umacr;": "Å«",
	"Union;": "â‹ƒ",
	"Uogon;": "Å²",
	"uogon;": "Å³",
	"uplus;": "âŠŽ",
	"upsih;": "Ï’",
	"UpTee;": "âŠ¥",
	"Uring;": "Å®",
	"uring;": "Å¯",
	"urtri;": "â—¹",
	"utdot;": "â‹°",
	"utrif;": "â–´",
	"uuarr;": "â‡ˆ",
	"varpi;": "Ï–",
	"vBarv;": "â«©",
	"VDash;": "âŠ«",
	"Vdash;": "âŠ©",
	"vDash;": "âŠ¨",
	"vdash;": "âŠ¢",
	"veeeq;": "â‰š",
	"vltri;": "âŠ²",
	"vnsub;": "âŠ‚âƒ’",
	"vnsup;": "âŠƒâƒ’",
	"vprop;": "âˆ",
	"vrtri;": "âŠ³",
	"Wcirc;": "Å´",
	"wcirc;": "Åµ",
	"Wedge;": "â‹€",
	"wedge;": "âˆ§",
	"xcirc;": "â—¯",
	"xdtri;": "â–½",
	"xhArr;": "âŸº",
	"xharr;": "âŸ·",
	"xlArr;": "âŸ¸",
	"xlarr;": "âŸµ",
	"xodot;": "â¨€",
	"xrArr;": "âŸ¹",
	"xrarr;": "âŸ¶",
	"xutri;": "â–³",
	Yacute: "Ã",
	yacute: "Ã½",
	"Ycirc;": "Å¶",
	"ycirc;": "Å·",
	"Aacute;": "Ã",
	"aacute;": "Ã¡",
	"Abreve;": "Ä‚",
	"abreve;": "Äƒ",
	"Agrave;": "Ã€",
	"agrave;": "Ã ",
	"andand;": "â©•",
	"angmsd;": "âˆ¡",
	"angsph;": "âˆ¢",
	"apacir;": "â©¯",
	"approx;": "â‰ˆ",
	"Assign;": "â‰”",
	"Atilde;": "Ãƒ",
	"atilde;": "Ã£",
	"barvee;": "âŠ½",
	"Barwed;": "âŒ†",
	"barwed;": "âŒ…",
	"becaus;": "âˆµ",
	"bernou;": "â„¬",
	"bigcap;": "â‹‚",
	"bigcup;": "â‹ƒ",
	"bigvee;": "â‹",
	"bkarow;": "â¤",
	"bottom;": "âŠ¥",
	"bowtie;": "â‹ˆ",
	"boxbox;": "â§‰",
	"bprime;": "â€µ",
	"brvbar;": "Â¦",
	"bullet;": "â€¢",
	"Bumpeq;": "â‰Ž",
	"bumpeq;": "â‰",
	"Cacute;": "Ä†",
	"cacute;": "Ä‡",
	"capand;": "â©„",
	"capcap;": "â©‹",
	"capcup;": "â©‡",
	"capdot;": "â©€",
	"Ccaron;": "ÄŒ",
	"ccaron;": "Ä",
	"Ccedil;": "Ã‡",
	"ccedil;": "Ã§",
	"circeq;": "â‰—",
	"cirmid;": "â«¯",
	"Colone;": "â©´",
	"colone;": "â‰”",
	"commat;": "@",
	"compfn;": "âˆ˜",
	"Conint;": "âˆ¯",
	"conint;": "âˆ®",
	"coprod;": "âˆ",
	"copysr;": "â„—",
	"cularr;": "â†¶",
	"CupCap;": "â‰",
	"cupcap;": "â©†",
	"cupcup;": "â©Š",
	"cupdot;": "âŠ",
	"curarr;": "â†·",
	"curren;": "Â¤",
	"cylcty;": "âŒ­",
	"Dagger;": "â€¡",
	"dagger;": "â€ ",
	"daleth;": "â„¸",
	"Dcaron;": "ÄŽ",
	"dcaron;": "Ä",
	"dfisht;": "â¥¿",
	"divide;": "Ã·",
	"divonx;": "â‹‡",
	"dlcorn;": "âŒž",
	"dlcrop;": "âŒ",
	"dollar;": "$",
	"DotDot;": "âƒœ",
	"drcorn;": "âŒŸ",
	"drcrop;": "âŒŒ",
	"Dstrok;": "Ä",
	"dstrok;": "Ä‘",
	"Eacute;": "Ã‰",
	"eacute;": "Ã©",
	"easter;": "â©®",
	"Ecaron;": "Äš",
	"ecaron;": "Ä›",
	"ecolon;": "â‰•",
	"Egrave;": "Ãˆ",
	"egrave;": "Ã¨",
	"egsdot;": "âª˜",
	"elsdot;": "âª—",
	"emptyv;": "âˆ…",
	"emsp13;": "â€„",
	"emsp14;": "â€…",
	"eparsl;": "â§£",
	"eqcirc;": "â‰–",
	"equals;": "=",
	"equest;": "â‰Ÿ",
	"Exists;": "âˆƒ",
	"female;": "â™€",
	"ffilig;": "ï¬ƒ",
	"ffllig;": "ï¬„",
	"ForAll;": "âˆ€",
	"forall;": "âˆ€",
	"frac12;": "Â½",
	"frac13;": "â…“",
	"frac14;": "Â¼",
	"frac15;": "â…•",
	"frac16;": "â…™",
	"frac18;": "â…›",
	"frac23;": "â…”",
	"frac25;": "â…–",
	"frac34;": "Â¾",
	"frac35;": "â…—",
	"frac38;": "â…œ",
	"frac45;": "â…˜",
	"frac56;": "â…š",
	"frac58;": "â…",
	"frac78;": "â…ž",
	"gacute;": "Çµ",
	"Gammad;": "Ïœ",
	"gammad;": "Ï",
	"Gbreve;": "Äž",
	"gbreve;": "ÄŸ",
	"Gcedil;": "Ä¢",
	"gesdot;": "âª€",
	"gesles;": "âª”",
	"gtlPar;": "â¦•",
	"gtrarr;": "â¥¸",
	"gtrdot;": "â‹—",
	"gtrsim;": "â‰³",
	"hairsp;": "â€Š",
	"hamilt;": "â„‹",
	"HARDcy;": "Ðª",
	"hardcy;": "ÑŠ",
	"hearts;": "â™¥",
	"hellip;": "â€¦",
	"hercon;": "âŠ¹",
	"homtht;": "âˆ»",
	"horbar;": "â€•",
	"hslash;": "â„",
	"Hstrok;": "Ä¦",
	"hstrok;": "Ä§",
	"hybull;": "âƒ",
	"hyphen;": "â€",
	"Iacute;": "Ã",
	"iacute;": "Ã­",
	"Igrave;": "ÃŒ",
	"igrave;": "Ã¬",
	"iiiint;": "â¨Œ",
	"iinfin;": "â§œ",
	"incare;": "â„…",
	"inodot;": "Ä±",
	"intcal;": "âŠº",
	"iquest;": "Â¿",
	"isinsv;": "â‹³",
	"Itilde;": "Ä¨",
	"itilde;": "Ä©",
	"Jsercy;": "Ðˆ",
	"jsercy;": "Ñ˜",
	"kappav;": "Ï°",
	"Kcedil;": "Ä¶",
	"kcedil;": "Ä·",
	"kgreen;": "Ä¸",
	"Lacute;": "Ä¹",
	"lacute;": "Äº",
	"lagran;": "â„’",
	"Lambda;": "Î›",
	"lambda;": "Î»",
	"langle;": "âŸ¨",
	"larrfs;": "â¤",
	"larrhk;": "â†©",
	"larrlp;": "â†«",
	"larrpl;": "â¤¹",
	"larrtl;": "â†¢",
	"lAtail;": "â¤›",
	"latail;": "â¤™",
	"lbrace;": "{",
	"lbrack;": "[",
	"Lcaron;": "Ä½",
	"lcaron;": "Ä¾",
	"Lcedil;": "Ä»",
	"lcedil;": "Ä¼",
	"ldquor;": "â€ž",
	"lesdot;": "â©¿",
	"lesges;": "âª“",
	"lfisht;": "â¥¼",
	"lfloor;": "âŒŠ",
	"lharul;": "â¥ª",
	"llhard;": "â¥«",
	"Lmidot;": "Ä¿",
	"lmidot;": "Å€",
	"lmoust;": "âŽ°",
	"loplus;": "â¨­",
	"lowast;": "âˆ—",
	"lowbar;": "_",
	"lparlt;": "â¦“",
	"lrhard;": "â¥­",
	"lsaquo;": "â€¹",
	"lsquor;": "â€š",
	"Lstrok;": "Å",
	"lstrok;": "Å‚",
	"lthree;": "â‹‹",
	"ltimes;": "â‹‰",
	"ltlarr;": "â¥¶",
	"ltrPar;": "â¦–",
	"mapsto;": "â†¦",
	"marker;": "â–®",
	"mcomma;": "â¨©",
	"midast;": "*",
	"midcir;": "â«°",
	"middot;": "Â·",
	"minusb;": "âŠŸ",
	"minusd;": "âˆ¸",
	"mnplus;": "âˆ“",
	"models;": "âŠ§",
	"mstpos;": "âˆ¾",
	"Nacute;": "Åƒ",
	"nacute;": "Å„",
	"nbumpe;": "â‰Ì¸",
	"Ncaron;": "Å‡",
	"ncaron;": "Åˆ",
	"Ncedil;": "Å…",
	"ncedil;": "Å†",
	"nearhk;": "â¤¤",
	"nequiv;": "â‰¢",
	"nesear;": "â¤¨",
	"nexist;": "âˆ„",
	"nltrie;": "â‹¬",
	"notinE;": "â‹¹Ì¸",
	"nparsl;": "â«½âƒ¥",
	"nprcue;": "â‹ ",
	"nrarrc;": "â¤³Ì¸",
	"nrarrw;": "â†Ì¸",
	"nrtrie;": "â‹­",
	"nsccue;": "â‹¡",
	"nsimeq;": "â‰„",
	"Ntilde;": "Ã‘",
	"ntilde;": "Ã±",
	"numero;": "â„–",
	"nVDash;": "âŠ¯",
	"nVdash;": "âŠ®",
	"nvDash;": "âŠ­",
	"nvdash;": "âŠ¬",
	"nvHarr;": "â¤„",
	"nvlArr;": "â¤‚",
	"nvrArr;": "â¤ƒ",
	"nwarhk;": "â¤£",
	"nwnear;": "â¤§",
	"Oacute;": "Ã“",
	"oacute;": "Ã³",
	"Odblac;": "Å",
	"odblac;": "Å‘",
	"odsold;": "â¦¼",
	"Ograve;": "Ã’",
	"ograve;": "Ã²",
	"ominus;": "âŠ–",
	"origof;": "âŠ¶",
	"Oslash;": "Ã˜",
	"oslash;": "Ã¸",
	"Otilde;": "Ã•",
	"otilde;": "Ãµ",
	"Otimes;": "â¨·",
	"otimes;": "âŠ—",
	"parsim;": "â«³",
	"percnt;": "%",
	"period;": ".",
	"permil;": "â€°",
	"phmmat;": "â„³",
	"planck;": "â„",
	"plankv;": "â„",
	"plusdo;": "âˆ”",
	"plusdu;": "â¨¥",
	"plusmn;": "Â±",
	"preceq;": "âª¯",
	"primes;": "â„™",
	"prnsim;": "â‹¨",
	"propto;": "âˆ",
	"prurel;": "âŠ°",
	"puncsp;": "â€ˆ",
	"qprime;": "â—",
	"Racute;": "Å”",
	"racute;": "Å•",
	"rangle;": "âŸ©",
	"rarrap;": "â¥µ",
	"rarrfs;": "â¤ž",
	"rarrhk;": "â†ª",
	"rarrlp;": "â†¬",
	"rarrpl;": "â¥…",
	"Rarrtl;": "â¤–",
	"rarrtl;": "â†£",
	"rAtail;": "â¤œ",
	"ratail;": "â¤š",
	"rbrace;": "}",
	"rbrack;": "]",
	"Rcaron;": "Å˜",
	"rcaron;": "Å™",
	"Rcedil;": "Å–",
	"rcedil;": "Å—",
	"rdquor;": "â€",
	"rfisht;": "â¥½",
	"rfloor;": "âŒ‹",
	"rharul;": "â¥¬",
	"rmoust;": "âŽ±",
	"roplus;": "â¨®",
	"rpargt;": "â¦”",
	"rsaquo;": "â€º",
	"rsquor;": "â€™",
	"rthree;": "â‹Œ",
	"rtimes;": "â‹Š",
	"Sacute;": "Åš",
	"sacute;": "Å›",
	"Scaron;": "Å ",
	"scaron;": "Å¡",
	"Scedil;": "Åž",
	"scedil;": "ÅŸ",
	"scnsim;": "â‹©",
	"searhk;": "â¤¥",
	"seswar;": "â¤©",
	"sfrown;": "âŒ¢",
	"SHCHcy;": "Ð©",
	"shchcy;": "Ñ‰",
	"sigmaf;": "Ï‚",
	"sigmav;": "Ï‚",
	"simdot;": "â©ª",
	"smashp;": "â¨³",
	"SOFTcy;": "Ð¬",
	"softcy;": "ÑŒ",
	"solbar;": "âŒ¿",
	"spades;": "â™ ",
	"sqcaps;": "âŠ“ï¸€",
	"sqcups;": "âŠ”ï¸€",
	"sqsube;": "âŠ‘",
	"sqsupe;": "âŠ’",
	"Square;": "â–¡",
	"square;": "â–¡",
	"squarf;": "â–ª",
	"ssetmn;": "âˆ–",
	"ssmile;": "âŒ£",
	"sstarf;": "â‹†",
	"subdot;": "âª½",
	"Subset;": "â‹",
	"subset;": "âŠ‚",
	"subsim;": "â«‡",
	"subsub;": "â«•",
	"subsup;": "â«“",
	"succeq;": "âª°",
	"supdot;": "âª¾",
	"Supset;": "â‹‘",
	"supset;": "âŠƒ",
	"supsim;": "â«ˆ",
	"supsub;": "â«”",
	"supsup;": "â«–",
	"swarhk;": "â¤¦",
	"swnwar;": "â¤ª",
	"target;": "âŒ–",
	"Tcaron;": "Å¤",
	"tcaron;": "Å¥",
	"Tcedil;": "Å¢",
	"tcedil;": "Å£",
	"telrec;": "âŒ•",
	"there4;": "âˆ´",
	"thetav;": "Ï‘",
	"thinsp;": "â€‰",
	"thksim;": "âˆ¼",
	"timesb;": "âŠ ",
	"timesd;": "â¨°",
	"topbot;": "âŒ¶",
	"topcir;": "â«±",
	"tprime;": "â€´",
	"tridot;": "â—¬",
	"Tstrok;": "Å¦",
	"tstrok;": "Å§",
	"Uacute;": "Ãš",
	"uacute;": "Ãº",
	"Ubreve;": "Å¬",
	"ubreve;": "Å­",
	"Udblac;": "Å°",
	"udblac;": "Å±",
	"ufisht;": "â¥¾",
	"Ugrave;": "Ã™",
	"ugrave;": "Ã¹",
	"ulcorn;": "âŒœ",
	"ulcrop;": "âŒ",
	"urcorn;": "âŒ",
	"urcrop;": "âŒŽ",
	"Utilde;": "Å¨",
	"utilde;": "Å©",
	"vangrt;": "â¦œ",
	"varphi;": "Ï•",
	"varrho;": "Ï±",
	"Vdashl;": "â«¦",
	"veebar;": "âŠ»",
	"vellip;": "â‹®",
	"Verbar;": "â€–",
	"verbar;": "|",
	"vsubnE;": "â«‹ï¸€",
	"vsubne;": "âŠŠï¸€",
	"vsupnE;": "â«Œï¸€",
	"vsupne;": "âŠ‹ï¸€",
	"Vvdash;": "âŠª",
	"wedbar;": "â©Ÿ",
	"wedgeq;": "â‰™",
	"weierp;": "â„˜",
	"wreath;": "â‰€",
	"xoplus;": "â¨",
	"xotime;": "â¨‚",
	"xsqcup;": "â¨†",
	"xuplus;": "â¨„",
	"xwedge;": "â‹€",
	"Yacute;": "Ã",
	"yacute;": "Ã½",
	"Zacute;": "Å¹",
	"zacute;": "Åº",
	"Zcaron;": "Å½",
	"zcaron;": "Å¾",
	"zeetrf;": "â„¨",
	"alefsym;": "â„µ",
	"angrtvb;": "âŠ¾",
	"angzarr;": "â¼",
	"asympeq;": "â‰",
	"backsim;": "âˆ½",
	"Because;": "âˆµ",
	"because;": "âˆµ",
	"bemptyv;": "â¦°",
	"between;": "â‰¬",
	"bigcirc;": "â—¯",
	"bigodot;": "â¨€",
	"bigstar;": "â˜…",
	"bnequiv;": "â‰¡âƒ¥",
	"boxplus;": "âŠž",
	"Cayleys;": "â„­",
	"Cconint;": "âˆ°",
	"ccupssm;": "â©",
	"Cedilla;": "Â¸",
	"cemptyv;": "â¦²",
	"cirscir;": "â§‚",
	"coloneq;": "â‰”",
	"congdot;": "â©­",
	"cudarrl;": "â¤¸",
	"cudarrr;": "â¤µ",
	"cularrp;": "â¤½",
	"curarrm;": "â¤¼",
	"dbkarow;": "â¤",
	"ddagger;": "â€¡",
	"ddotseq;": "â©·",
	"demptyv;": "â¦±",
	"Diamond;": "â‹„",
	"diamond;": "â‹„",
	"digamma;": "Ï",
	"dotplus;": "âˆ”",
	"DownTee;": "âŠ¤",
	"dwangle;": "â¦¦",
	"Element;": "âˆˆ",
	"Epsilon;": "Î•",
	"epsilon;": "Îµ",
	"eqcolon;": "â‰•",
	"equivDD;": "â©¸",
	"gesdoto;": "âª‚",
	"gtquest;": "â©¼",
	"gtrless;": "â‰·",
	"harrcir;": "â¥ˆ",
	"Implies;": "â‡’",
	"intprod;": "â¨¼",
	"isindot;": "â‹µ",
	"larrbfs;": "â¤Ÿ",
	"larrsim;": "â¥³",
	"lbrksld;": "â¦",
	"lbrkslu;": "â¦",
	"ldrdhar;": "â¥§",
	"LeftTee;": "âŠ£",
	"lesdoto;": "âª",
	"lessdot;": "â‹–",
	"lessgtr;": "â‰¶",
	"lesssim;": "â‰²",
	"lotimes;": "â¨´",
	"lozenge;": "â—Š",
	"ltquest;": "â©»",
	"luruhar;": "â¥¦",
	"maltese;": "âœ ",
	"minusdu;": "â¨ª",
	"napprox;": "â‰‰",
	"natural;": "â™®",
	"nearrow;": "â†—",
	"NewLine;": "\n",
	"nexists;": "âˆ„",
	"NoBreak;": "â ",
	"notinva;": "âˆ‰",
	"notinvb;": "â‹·",
	"notinvc;": "â‹¶",
	"NotLess;": "â‰®",
	"notniva;": "âˆŒ",
	"notnivb;": "â‹¾",
	"notnivc;": "â‹½",
	"npolint;": "â¨”",
	"npreceq;": "âª¯Ì¸",
	"nsqsube;": "â‹¢",
	"nsqsupe;": "â‹£",
	"nsubset;": "âŠ‚âƒ’",
	"nsucceq;": "âª°Ì¸",
	"nsupset;": "âŠƒâƒ’",
	"nvinfin;": "â§ž",
	"nvltrie;": "âŠ´âƒ’",
	"nvrtrie;": "âŠµâƒ’",
	"nwarrow;": "â†–",
	"olcross;": "â¦»",
	"Omicron;": "ÎŸ",
	"omicron;": "Î¿",
	"orderof;": "â„´",
	"orslope;": "â©—",
	"OverBar;": "â€¾",
	"pertenk;": "â€±",
	"planckh;": "â„Ž",
	"pluscir;": "â¨¢",
	"plussim;": "â¨¦",
	"plustwo;": "â¨§",
	"precsim;": "â‰¾",
	"Product;": "âˆ",
	"quatint;": "â¨–",
	"questeq;": "â‰Ÿ",
	"rarrbfs;": "â¤ ",
	"rarrsim;": "â¥´",
	"rbrksld;": "â¦Ž",
	"rbrkslu;": "â¦",
	"rdldhar;": "â¥©",
	"realine;": "â„›",
	"rotimes;": "â¨µ",
	"ruluhar;": "â¥¨",
	"searrow;": "â†˜",
	"simplus;": "â¨¤",
	"simrarr;": "â¥²",
	"subedot;": "â«ƒ",
	"submult;": "â«",
	"subplus;": "âª¿",
	"subrarr;": "â¥¹",
	"succsim;": "â‰¿",
	"supdsub;": "â«˜",
	"supedot;": "â«„",
	"suphsol;": "âŸ‰",
	"suphsub;": "â«—",
	"suplarr;": "â¥»",
	"supmult;": "â«‚",
	"supplus;": "â«€",
	"swarrow;": "â†™",
	"topfork;": "â«š",
	"triplus;": "â¨¹",
	"tritime;": "â¨»",
	"UpArrow;": "â†‘",
	"Uparrow;": "â‡‘",
	"uparrow;": "â†‘",
	"Upsilon;": "Î¥",
	"upsilon;": "Ï…",
	"uwangle;": "â¦§",
	"vzigzag;": "â¦š",
	"zigrarr;": "â‡",
	"andslope;": "â©˜",
	"angmsdaa;": "â¦¨",
	"angmsdab;": "â¦©",
	"angmsdac;": "â¦ª",
	"angmsdad;": "â¦«",
	"angmsdae;": "â¦¬",
	"angmsdaf;": "â¦­",
	"angmsdag;": "â¦®",
	"angmsdah;": "â¦¯",
	"angrtvbd;": "â¦",
	"approxeq;": "â‰Š",
	"awconint;": "âˆ³",
	"backcong;": "â‰Œ",
	"barwedge;": "âŒ…",
	"bbrktbrk;": "âŽ¶",
	"bigoplus;": "â¨",
	"bigsqcup;": "â¨†",
	"biguplus;": "â¨„",
	"bigwedge;": "â‹€",
	"boxminus;": "âŠŸ",
	"boxtimes;": "âŠ ",
	"bsolhsub;": "âŸˆ",
	"capbrcup;": "â©‰",
	"circledR;": "Â®",
	"circledS;": "â“ˆ",
	"cirfnint;": "â¨",
	"clubsuit;": "â™£",
	"cupbrcap;": "â©ˆ",
	"curlyvee;": "â‹Ž",
	"cwconint;": "âˆ²",
	"DDotrahd;": "â¤‘",
	"doteqdot;": "â‰‘",
	"DotEqual;": "â‰",
	"dotminus;": "âˆ¸",
	"drbkarow;": "â¤",
	"dzigrarr;": "âŸ¿",
	"elinters;": "â§",
	"emptyset;": "âˆ…",
	"eqvparsl;": "â§¥",
	"fpartint;": "â¨",
	"geqslant;": "â©¾",
	"gesdotol;": "âª„",
	"gnapprox;": "âªŠ",
	"hksearow;": "â¤¥",
	"hkswarow;": "â¤¦",
	"imagline;": "â„",
	"imagpart;": "â„‘",
	"infintie;": "â§",
	"integers;": "â„¤",
	"Integral;": "âˆ«",
	"intercal;": "âŠº",
	"intlarhk;": "â¨—",
	"laemptyv;": "â¦´",
	"ldrushar;": "â¥‹",
	"leqslant;": "â©½",
	"lesdotor;": "âªƒ",
	"LessLess;": "âª¡",
	"llcorner;": "âŒž",
	"lnapprox;": "âª‰",
	"lrcorner;": "âŒŸ",
	"lurdshar;": "â¥Š",
	"mapstoup;": "â†¥",
	"multimap;": "âŠ¸",
	"naturals;": "â„•",
	"ncongdot;": "â©­Ì¸",
	"NotEqual;": "â‰ ",
	"notindot;": "â‹µÌ¸",
	"NotTilde;": "â‰",
	"otimesas;": "â¨¶",
	"parallel;": "âˆ¥",
	"PartialD;": "âˆ‚",
	"plusacir;": "â¨£",
	"pointint;": "â¨•",
	"Precedes;": "â‰º",
	"precneqq;": "âªµ",
	"precnsim;": "â‹¨",
	"profalar;": "âŒ®",
	"profline;": "âŒ’",
	"profsurf;": "âŒ“",
	"raemptyv;": "â¦³",
	"realpart;": "â„œ",
	"RightTee;": "âŠ¢",
	"rppolint;": "â¨’",
	"rtriltri;": "â§Ž",
	"scpolint;": "â¨“",
	"setminus;": "âˆ–",
	"shortmid;": "âˆ£",
	"smeparsl;": "â§¤",
	"sqsubset;": "âŠ",
	"sqsupset;": "âŠ",
	"subseteq;": "âŠ†",
	"Succeeds;": "â‰»",
	"succneqq;": "âª¶",
	"succnsim;": "â‹©",
	"SuchThat;": "âˆ‹",
	"Superset;": "âŠƒ",
	"supseteq;": "âŠ‡",
	"thetasym;": "Ï‘",
	"thicksim;": "âˆ¼",
	"timesbar;": "â¨±",
	"triangle;": "â–µ",
	"triminus;": "â¨º",
	"trpezium;": "â¢",
	"Uarrocir;": "â¥‰",
	"ulcorner;": "âŒœ",
	"UnderBar;": "_",
	"urcorner;": "âŒ",
	"varkappa;": "Ï°",
	"varsigma;": "Ï‚",
	"vartheta;": "Ï‘",
	"backprime;": "â€µ",
	"backsimeq;": "â‹",
	"Backslash;": "âˆ–",
	"bigotimes;": "â¨‚",
	"CenterDot;": "Â·",
	"centerdot;": "Â·",
	"checkmark;": "âœ“",
	"CircleDot;": "âŠ™",
	"complexes;": "â„‚",
	"Congruent;": "â‰¡",
	"Coproduct;": "âˆ",
	"dotsquare;": "âŠ¡",
	"DoubleDot;": "Â¨",
	"DownArrow;": "â†“",
	"Downarrow;": "â‡“",
	"downarrow;": "â†“",
	"DownBreve;": "Ì‘",
	"gtrapprox;": "âª†",
	"gtreqless;": "â‹›",
	"gvertneqq;": "â‰©ï¸€",
	"heartsuit;": "â™¥",
	"HumpEqual;": "â‰",
	"LeftArrow;": "â†",
	"Leftarrow;": "â‡",
	"leftarrow;": "â†",
	"LeftFloor;": "âŒŠ",
	"lesseqgtr;": "â‹š",
	"LessTilde;": "â‰²",
	"lvertneqq;": "â‰¨ï¸€",
	"Mellintrf;": "â„³",
	"MinusPlus;": "âˆ“",
	"ngeqslant;": "â©¾Ì¸",
	"nleqslant;": "â©½Ì¸",
	"NotCupCap;": "â‰­",
	"NotExists;": "âˆ„",
	"NotSubset;": "âŠ‚âƒ’",
	"nparallel;": "âˆ¦",
	"nshortmid;": "âˆ¤",
	"nsubseteq;": "âŠˆ",
	"nsupseteq;": "âŠ‰",
	"OverBrace;": "âž",
	"pitchfork;": "â‹”",
	"PlusMinus;": "Â±",
	"rationals;": "â„š",
	"spadesuit;": "â™ ",
	"subseteqq;": "â«…",
	"subsetneq;": "âŠŠ",
	"supseteqq;": "â«†",
	"supsetneq;": "âŠ‹",
	"Therefore;": "âˆ´",
	"therefore;": "âˆ´",
	"ThinSpace;": "â€‰",
	"triangleq;": "â‰œ",
	"TripleDot;": "âƒ›",
	"UnionPlus;": "âŠŽ",
	"varpropto;": "âˆ",
	"Bernoullis;": "â„¬",
	"circledast;": "âŠ›",
	"CirclePlus;": "âŠ•",
	"complement;": "âˆ",
	"curlywedge;": "â‹",
	"eqslantgtr;": "âª–",
	"EqualTilde;": "â‰‚",
	"Fouriertrf;": "â„±",
	"gtreqqless;": "âªŒ",
	"ImaginaryI;": "â…ˆ",
	"Laplacetrf;": "â„’",
	"LeftVector;": "â†¼",
	"lessapprox;": "âª…",
	"lesseqqgtr;": "âª‹",
	"Lleftarrow;": "â‡š",
	"lmoustache;": "âŽ°",
	"longmapsto;": "âŸ¼",
	"mapstodown;": "â†§",
	"mapstoleft;": "â†¤",
	"nLeftarrow;": "â‡",
	"nleftarrow;": "â†š",
	"NotElement;": "âˆ‰",
	"NotGreater;": "â‰¯",
	"nsubseteqq;": "â«…Ì¸",
	"nsupseteqq;": "â«†Ì¸",
	"precapprox;": "âª·",
	"Proportion;": "âˆ·",
	"RightArrow;": "â†’",
	"Rightarrow;": "â‡’",
	"rightarrow;": "â†’",
	"RightFloor;": "âŒ‹",
	"rmoustache;": "âŽ±",
	"sqsubseteq;": "âŠ‘",
	"sqsupseteq;": "âŠ’",
	"subsetneqq;": "â«‹",
	"succapprox;": "âª¸",
	"supsetneqq;": "â«Œ",
	"ThickSpace;": "âŸâ€Š",
	"TildeEqual;": "â‰ƒ",
	"TildeTilde;": "â‰ˆ",
	"UnderBrace;": "âŸ",
	"UpArrowBar;": "â¤’",
	"UpTeeArrow;": "â†¥",
	"upuparrows;": "â‡ˆ",
	"varepsilon;": "Ïµ",
	"varnothing;": "âˆ…",
	"backepsilon;": "Ï¶",
	"blacksquare;": "â–ª",
	"circledcirc;": "âŠš",
	"circleddash;": "âŠ",
	"CircleMinus;": "âŠ–",
	"CircleTimes;": "âŠ—",
	"curlyeqprec;": "â‹ž",
	"curlyeqsucc;": "â‹Ÿ",
	"diamondsuit;": "â™¦",
	"eqslantless;": "âª•",
	"Equilibrium;": "â‡Œ",
	"expectation;": "â„°",
	"GreaterLess;": "â‰·",
	"LeftCeiling;": "âŒˆ",
	"LessGreater;": "â‰¶",
	"MediumSpace;": "âŸ",
	"NotLessLess;": "â‰ªÌ¸",
	"NotPrecedes;": "âŠ€",
	"NotSucceeds;": "âŠ",
	"NotSuperset;": "âŠƒâƒ’",
	"nRightarrow;": "â‡",
	"nrightarrow;": "â†›",
	"OverBracket;": "âŽ´",
	"preccurlyeq;": "â‰¼",
	"precnapprox;": "âª¹",
	"quaternions;": "â„",
	"RightVector;": "â‡€",
	"Rrightarrow;": "â‡›",
	"RuleDelayed;": "â§´",
	"SmallCircle;": "âˆ˜",
	"SquareUnion;": "âŠ”",
	"straightphi;": "Ï•",
	"SubsetEqual;": "âŠ†",
	"succcurlyeq;": "â‰½",
	"succnapprox;": "âªº",
	"thickapprox;": "â‰ˆ",
	"UpDownArrow;": "â†•",
	"Updownarrow;": "â‡•",
	"updownarrow;": "â†•",
	"VerticalBar;": "âˆ£",
	"blacklozenge;": "â§«",
	"DownArrowBar;": "â¤“",
	"DownTeeArrow;": "â†§",
	"ExponentialE;": "â…‡",
	"exponentiale;": "â…‡",
	"GreaterEqual;": "â‰¥",
	"GreaterTilde;": "â‰³",
	"HilbertSpace;": "â„‹",
	"HumpDownHump;": "â‰Ž",
	"Intersection;": "â‹‚",
	"LeftArrowBar;": "â‡¤",
	"LeftTeeArrow;": "â†¤",
	"LeftTriangle;": "âŠ²",
	"LeftUpVector;": "â†¿",
	"NotCongruent;": "â‰¢",
	"NotHumpEqual;": "â‰Ì¸",
	"NotLessEqual;": "â‰°",
	"NotLessTilde;": "â‰´",
	"Proportional;": "âˆ",
	"RightCeiling;": "âŒ‰",
	"risingdotseq;": "â‰“",
	"RoundImplies;": "â¥°",
	"ShortUpArrow;": "â†‘",
	"SquareSubset;": "âŠ",
	"triangledown;": "â–¿",
	"triangleleft;": "â—ƒ",
	"UnderBracket;": "âŽµ",
	"varsubsetneq;": "âŠŠï¸€",
	"varsupsetneq;": "âŠ‹ï¸€",
	"VerticalLine;": "|",
	"ApplyFunction;": "â¡",
	"bigtriangleup;": "â–³",
	"blacktriangle;": "â–´",
	"DifferentialD;": "â…†",
	"divideontimes;": "â‹‡",
	"DoubleLeftTee;": "â«¤",
	"DoubleUpArrow;": "â‡‘",
	"fallingdotseq;": "â‰’",
	"hookleftarrow;": "â†©",
	"leftarrowtail;": "â†¢",
	"leftharpoonup;": "â†¼",
	"LeftTeeVector;": "â¥š",
	"LeftVectorBar;": "â¥’",
	"LessFullEqual;": "â‰¦",
	"LongLeftArrow;": "âŸµ",
	"Longleftarrow;": "âŸ¸",
	"longleftarrow;": "âŸµ",
	"looparrowleft;": "â†«",
	"measuredangle;": "âˆ¡",
	"NotEqualTilde;": "â‰‚Ì¸",
	"NotTildeEqual;": "â‰„",
	"NotTildeTilde;": "â‰‰",
	"ntriangleleft;": "â‹ª",
	"Poincareplane;": "â„Œ",
	"PrecedesEqual;": "âª¯",
	"PrecedesTilde;": "â‰¾",
	"RightArrowBar;": "â‡¥",
	"RightTeeArrow;": "â†¦",
	"RightTriangle;": "âŠ³",
	"RightUpVector;": "â†¾",
	"shortparallel;": "âˆ¥",
	"smallsetminus;": "âˆ–",
	"SucceedsEqual;": "âª°",
	"SucceedsTilde;": "â‰¿",
	"SupersetEqual;": "âŠ‡",
	"triangleright;": "â–¹",
	"UpEquilibrium;": "â¥®",
	"upharpoonleft;": "â†¿",
	"varsubsetneqq;": "â«‹ï¸€",
	"varsupsetneqq;": "â«Œï¸€",
	"VerticalTilde;": "â‰€",
	"VeryThinSpace;": "â€Š",
	"curvearrowleft;": "â†¶",
	"DiacriticalDot;": "Ë™",
	"doublebarwedge;": "âŒ†",
	"DoubleRightTee;": "âŠ¨",
	"downdownarrows;": "â‡Š",
	"DownLeftVector;": "â†½",
	"GreaterGreater;": "âª¢",
	"hookrightarrow;": "â†ª",
	"HorizontalLine;": "â”€",
	"InvisibleComma;": "â£",
	"InvisibleTimes;": "â¢",
	"LeftDownVector;": "â‡ƒ",
	"leftleftarrows;": "â‡‡",
	"LeftRightArrow;": "â†”",
	"Leftrightarrow;": "â‡”",
	"leftrightarrow;": "â†”",
	"leftthreetimes;": "â‹‹",
	"LessSlantEqual;": "â©½",
	"LongRightArrow;": "âŸ¶",
	"Longrightarrow;": "âŸ¹",
	"longrightarrow;": "âŸ¶",
	"looparrowright;": "â†¬",
	"LowerLeftArrow;": "â†™",
	"NestedLessLess;": "â‰ª",
	"NotGreaterLess;": "â‰¹",
	"NotLessGreater;": "â‰¸",
	"NotSubsetEqual;": "âŠˆ",
	"NotVerticalBar;": "âˆ¤",
	"nshortparallel;": "âˆ¦",
	"ntriangleright;": "â‹«",
	"OpenCurlyQuote;": "â€˜",
	"ReverseElement;": "âˆ‹",
	"rightarrowtail;": "â†£",
	"rightharpoonup;": "â‡€",
	"RightTeeVector;": "â¥›",
	"RightVectorBar;": "â¥“",
	"ShortDownArrow;": "â†“",
	"ShortLeftArrow;": "â†",
	"SquareSuperset;": "âŠ",
	"TildeFullEqual;": "â‰…",
	"trianglelefteq;": "âŠ´",
	"upharpoonright;": "â†¾",
	"UpperLeftArrow;": "â†–",
	"ZeroWidthSpace;": "â€‹",
	"bigtriangledown;": "â–½",
	"circlearrowleft;": "â†º",
	"CloseCurlyQuote;": "â€™",
	"ContourIntegral;": "âˆ®",
	"curvearrowright;": "â†·",
	"DoubleDownArrow;": "â‡“",
	"DoubleLeftArrow;": "â‡",
	"downharpoonleft;": "â‡ƒ",
	"DownRightVector;": "â‡",
	"leftharpoondown;": "â†½",
	"leftrightarrows;": "â‡†",
	"LeftRightVector;": "â¥Ž",
	"LeftTriangleBar;": "â§",
	"LeftUpTeeVector;": "â¥ ",
	"LeftUpVectorBar;": "â¥˜",
	"LowerRightArrow;": "â†˜",
	"nLeftrightarrow;": "â‡Ž",
	"nleftrightarrow;": "â†®",
	"NotGreaterEqual;": "â‰±",
	"NotGreaterTilde;": "â‰µ",
	"NotHumpDownHump;": "â‰ŽÌ¸",
	"NotLeftTriangle;": "â‹ª",
	"NotSquareSubset;": "âŠÌ¸",
	"ntrianglelefteq;": "â‹¬",
	"OverParenthesis;": "âœ",
	"RightDownVector;": "â‡‚",
	"rightleftarrows;": "â‡„",
	"rightsquigarrow;": "â†",
	"rightthreetimes;": "â‹Œ",
	"ShortRightArrow;": "â†’",
	"straightepsilon;": "Ïµ",
	"trianglerighteq;": "âŠµ",
	"UpperRightArrow;": "â†—",
	"vartriangleleft;": "âŠ²",
	"circlearrowright;": "â†»",
	"DiacriticalAcute;": "Â´",
	"DiacriticalGrave;": "`",
	"DiacriticalTilde;": "Ëœ",
	"DoubleRightArrow;": "â‡’",
	"DownArrowUpArrow;": "â‡µ",
	"downharpoonright;": "â‡‚",
	"EmptySmallSquare;": "â—»",
	"GreaterEqualLess;": "â‹›",
	"GreaterFullEqual;": "â‰§",
	"LeftAngleBracket;": "âŸ¨",
	"LeftUpDownVector;": "â¥‘",
	"LessEqualGreater;": "â‹š",
	"NonBreakingSpace;": "Â ",
	"NotPrecedesEqual;": "âª¯Ì¸",
	"NotRightTriangle;": "â‹«",
	"NotSucceedsEqual;": "âª°Ì¸",
	"NotSucceedsTilde;": "â‰¿Ì¸",
	"NotSupersetEqual;": "âŠ‰",
	"ntrianglerighteq;": "â‹­",
	"rightharpoondown;": "â‡",
	"rightrightarrows;": "â‡‰",
	"RightTriangleBar;": "â§",
	"RightUpTeeVector;": "â¥œ",
	"RightUpVectorBar;": "â¥”",
	"twoheadleftarrow;": "â†ž",
	"UnderParenthesis;": "â",
	"UpArrowDownArrow;": "â‡…",
	"vartriangleright;": "âŠ³",
	"blacktriangledown;": "â–¾",
	"blacktriangleleft;": "â—‚",
	"DoubleUpDownArrow;": "â‡•",
	"DoubleVerticalBar;": "âˆ¥",
	"DownLeftTeeVector;": "â¥ž",
	"DownLeftVectorBar;": "â¥–",
	"FilledSmallSquare;": "â—¼",
	"GreaterSlantEqual;": "â©¾",
	"LeftDoubleBracket;": "âŸ¦",
	"LeftDownTeeVector;": "â¥¡",
	"LeftDownVectorBar;": "â¥™",
	"leftrightharpoons;": "â‡‹",
	"LeftTriangleEqual;": "âŠ´",
	"NegativeThinSpace;": "â€‹",
	"NotGreaterGreater;": "â‰«Ì¸",
	"NotLessSlantEqual;": "â©½Ì¸",
	"NotNestedLessLess;": "âª¡Ì¸",
	"NotReverseElement;": "âˆŒ",
	"NotSquareSuperset;": "âŠÌ¸",
	"NotTildeFullEqual;": "â‰‡",
	"RightAngleBracket;": "âŸ©",
	"rightleftharpoons;": "â‡Œ",
	"RightUpDownVector;": "â¥",
	"SquareSubsetEqual;": "âŠ‘",
	"twoheadrightarrow;": "â† ",
	"VerticalSeparator;": "â˜",
	"blacktriangleright;": "â–¸",
	"DownRightTeeVector;": "â¥Ÿ",
	"DownRightVectorBar;": "â¥—",
	"LongLeftRightArrow;": "âŸ·",
	"Longleftrightarrow;": "âŸº",
	"longleftrightarrow;": "âŸ·",
	"NegativeThickSpace;": "â€‹",
	"NotLeftTriangleBar;": "â§Ì¸",
	"PrecedesSlantEqual;": "â‰¼",
	"ReverseEquilibrium;": "â‡‹",
	"RightDoubleBracket;": "âŸ§",
	"RightDownTeeVector;": "â¥",
	"RightDownVectorBar;": "â¥•",
	"RightTriangleEqual;": "âŠµ",
	"SquareIntersection;": "âŠ“",
	"SucceedsSlantEqual;": "â‰½",
	"DoubleLongLeftArrow;": "âŸ¸",
	"DownLeftRightVector;": "â¥",
	"LeftArrowRightArrow;": "â‡†",
	"leftrightsquigarrow;": "â†­",
	"NegativeMediumSpace;": "â€‹",
	"NotGreaterFullEqual;": "â‰§Ì¸",
	"NotRightTriangleBar;": "â§Ì¸",
	"RightArrowLeftArrow;": "â‡„",
	"SquareSupersetEqual;": "âŠ’",
	"CapitalDifferentialD;": "â……",
	"DoubleLeftRightArrow;": "â‡”",
	"DoubleLongRightArrow;": "âŸ¹",
	"EmptyVerySmallSquare;": "â–«",
	"NestedGreaterGreater;": "â‰«",
	"NotDoubleVerticalBar;": "âˆ¦",
	"NotGreaterSlantEqual;": "â©¾Ì¸",
	"NotLeftTriangleEqual;": "â‹¬",
	"NotSquareSubsetEqual;": "â‹¢",
	"OpenCurlyDoubleQuote;": "â€œ",
	"ReverseUpEquilibrium;": "â¥¯",
	"CloseCurlyDoubleQuote;": "â€",
	"DoubleContourIntegral;": "âˆ¯",
	"FilledVerySmallSquare;": "â–ª",
	"NegativeVeryThinSpace;": "â€‹",
	"NotPrecedesSlantEqual;": "â‹ ",
	"NotRightTriangleEqual;": "â‹­",
	"NotSucceedsSlantEqual;": "â‹¡",
	"DiacriticalDoubleAcute;": "Ë",
	"NotSquareSupersetEqual;": "â‹£",
	"NotNestedGreaterGreater;": "âª¢Ì¸",
	"ClockwiseContourIntegral;": "âˆ²",
	"DoubleLongLeftRightArrow;": "âŸº",
	"CounterClockwiseContourIntegral;": "âˆ³"
};

// lazy compute this to make this file tree-shakable for browser
let maxCRNameLength;
const decodeHtml = (rawText, asAttr) => {
    let offset = 0;
    const end = rawText.length;
    let decodedText = '';
    function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
    }
    while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (!head || offset + head.index >= end) {
            const remaining = end - offset;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
        }
        // Advance to the "&".
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === '&') {
            // Named character reference.
            let name = '';
            let value = undefined;
            if (/[0-9a-z]/i.test(rawText[1])) {
                if (!maxCRNameLength) {
                    maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
                }
                for (let length = maxCRNameLength; !value && length > 0; --length) {
                    name = rawText.slice(1, 1 + length);
                    value = namedCharacterReferences[name];
                }
                if (value) {
                    const semi = name.endsWith(';');
                    if (asAttr &&
                        !semi &&
                        /[=a-z0-9]/i.test(rawText[name.length + 1] || '')) {
                        decodedText += '&' + name;
                        advance(1 + name.length);
                    }
                    else {
                        decodedText += value;
                        advance(1 + name.length);
                    }
                }
                else {
                    decodedText += '&' + name;
                    advance(1 + name.length);
                }
            }
            else {
                decodedText += '&';
                advance(1);
            }
        }
        else {
            // Numeric character reference.
            const hex = head[0] === '&#x';
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern.exec(rawText);
            if (!body) {
                decodedText += head[0];
                advance(head[0].length);
            }
            else {
                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                let cp = Number.parseInt(body[1], hex ? 16 : 10);
                if (cp === 0) {
                    cp = 0xfffd;
                }
                else if (cp > 0x10ffff) {
                    cp = 0xfffd;
                }
                else if (cp >= 0xd800 && cp <= 0xdfff) {
                    cp = 0xfffd;
                }
                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                else if ((cp >= 0x01 && cp <= 0x08) ||
                    cp === 0x0b ||
                    (cp >= 0x0d && cp <= 0x1f) ||
                    (cp >= 0x7f && cp <= 0x9f)) {
                    cp = CCR_REPLACEMENTS[cp] || cp;
                }
                decodedText += String.fromCodePoint(cp);
                advance(body[0].length);
            }
        }
    }
    return decodedText;
};
// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
const CCR_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178
};

const isRawTextContainer = /*#__PURE__*/ shared.makeMap('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag: shared.isVoidTag,
    isNativeTag: tag => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtml,
    isBuiltInComponent: (tag) => {
        if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
        }
        else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* TextModes.RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* TextModes.RAWTEXT */;
            }
        }
        return 0 /* TextModes.DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* NodeTypes.DIRECTIVE */,
                    name: `bind`,
                    arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = shared.parseStringStyle(cssText);
    return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return compilerCore.createCompilerError(code, loc, DOMErrorMessages );
}
const DOMErrorMessages = {
    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp
                ? compilerCore.getConstantType(exp, context) > 0
                    ? exp
                    : compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc)
                : compilerCore.createSimpleExpression('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = compilerCore.transformModel(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = compilerCore.findProp(node, `type`);
            if (type) {
                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                    }
                }
            }
            else if (compilerCore.hasDynamicKeyVBind(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else ;
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else ;
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ shared.makeMap(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ shared.makeMap(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ shared.makeMap('left,right');
const isKeyboardEvent = /*#__PURE__*/ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if (compilerCore.isStaticExp(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? compilerCore.createSimpleExpression(event, true)
        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
            ? compilerCore.createCompoundExpression([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return compilerCore.transformOn(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join('');
            key = compilerCore.isStaticExp(key)
                ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [compilerCore.createObjectProperty(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

/**
 * This module is Node-only.
 */
/**
 * Regex for replacing placeholders for embedded constant variables
 * (e.g. import URL string constants generated by compiler-sfc)
 */
const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
/**
 * Turn eligible hoisted static trees into stringified static nodes, e.g.
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 *
 * A single static vnode can contain stringified content for **multiple**
 * consecutive nodes (element and plain text), called a "chunk".
 * `@vue/runtime-dom` will create the content via innerHTML in a hidden
 * container element and insert all the nodes in place. The call must also
 * provide the number of nodes contained in the chunk so that during hydration
 * we can know how many nodes the static vnode should adopt.
 *
 * The optimization scans a children list that contains hoisted nodes, and
 * tries to find the largest chunk of consecutive hoisted nodes before running
 * into a non-hoisted node or the end of the list. A chunk is then converted
 * into a single static vnode and replaces the hoisted expression of the first
 * node in the chunk. Other nodes in the chunk are considered "merged" and
 * therefore removed from both the hoist list and the children array.
 *
 * This optimization is only performed in Node.js.
 */
const stringifyStatic = (children, context, parent) => {
    // bail stringification for slot content
    if (context.scopes.vSlot > 0) {
        return;
    }
    let nc = 0; // current node count
    let ec = 0; // current element with binding count
    const currentChunk = [];
    const stringifyCurrentChunk = (currentIndex) => {
        if (nc >= 20 /* StringifyThresholds.NODE_COUNT */ ||
            ec >= 5 /* StringifyThresholds.ELEMENT_WITH_BINDING_COUNT */) {
            // combine all currently eligible nodes into a single static vnode call
            const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
                JSON.stringify(currentChunk.map(node => stringifyNode(node, context)).join('')).replace(expReplaceRE, `" + $1 + "`),
                // the 2nd argument indicates the number of DOM nodes this static vnode
                // will insert / hydrate
                String(currentChunk.length)
            ]);
            // replace the first node's hoisted expression with the static vnode call
            replaceHoist(currentChunk[0], staticCall, context);
            if (currentChunk.length > 1) {
                for (let i = 1; i < currentChunk.length; i++) {
                    // for the merged nodes, set their hoisted expression to null
                    replaceHoist(currentChunk[i], null, context);
                }
                // also remove merged nodes from children
                const deleteCount = currentChunk.length - 1;
                children.splice(currentIndex - currentChunk.length + 1, deleteCount);
                return deleteCount;
            }
        }
        return 0;
    };
    let i = 0;
    for (; i < children.length; i++) {
        const child = children[i];
        const hoisted = getHoistedNode(child);
        if (hoisted) {
            // presence of hoisted means child must be a stringifiable node
            const node = child;
            const result = analyzeNode(node);
            if (result) {
                // node is stringifiable, record state
                nc += result[0];
                ec += result[1];
                currentChunk.push(node);
                continue;
            }
        }
        // we only reach here if we ran into a node that is not stringifiable
        // check if currently analyzed nodes meet criteria for stringification.
        // adjust iteration index
        i -= stringifyCurrentChunk(i);
        // reset state
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
    }
    // in case the last node was also stringifiable
    stringifyCurrentChunk(i);
};
const getHoistedNode = (node) => ((node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */) ||
    node.type == 12 /* NodeTypes.TEXT_CALL */) &&
    node.codegenNode &&
    node.codegenNode.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
    node.codegenNode.hoisted;
const dataAriaRE = /^(data|aria)-/;
const isStringifiableAttr = (name, ns) => {
    return ((ns === 0 /* DOMNamespaces.HTML */
        ? shared.isKnownHtmlAttr(name)
        : ns === 1 /* DOMNamespaces.SVG */
            ? shared.isKnownSvgAttr(name)
            : false) || dataAriaRE.test(name));
};
const replaceHoist = (node, replacement, context) => {
    const hoistToReplace = node.codegenNode.hoisted;
    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
};
const isNonStringifiable = /*#__PURE__*/ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
/**
 * for a hoisted node, analyze it and return:
 * - false: bailed (contains non-stringifiable props or runtime constant)
 * - [nc, ec] where
 *   - nc is the number of nodes inside
 *   - ec is the number of element with bindings inside
 */
function analyzeNode(node) {
    if (node.type === 1 /* NodeTypes.ELEMENT */ && isNonStringifiable(node.tag)) {
        return false;
    }
    if (node.type === 12 /* NodeTypes.TEXT_CALL */) {
        return [1, 0];
    }
    let nc = 1; // node count
    let ec = node.props.length > 0 ? 1 : 0; // element w/ binding count
    let bailed = false;
    const bail = () => {
        bailed = true;
        return false;
    };
    // TODO: check for cases where using innerHTML will result in different
    // output compared to imperative node insertions.
    // probably only need to check for most common case
    // i.e. non-phrasing-content tags inside `<p>`
    function walk(node) {
        for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            // bail on non-attr bindings
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                !isStringifiableAttr(p.name, node.ns)) {
                return bail();
            }
            if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind') {
                // bail on non-attr bindings
                if (p.arg &&
                    (p.arg.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ ||
                        (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))) {
                    return bail();
                }
                if (p.exp &&
                    (p.exp.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ ||
                        p.exp.constType < 3 /* ConstantTypes.CAN_STRINGIFY */)) {
                    return bail();
                }
            }
        }
        for (let i = 0; i < node.children.length; i++) {
            nc++;
            const child = node.children[i];
            if (child.type === 1 /* NodeTypes.ELEMENT */) {
                if (child.props.length > 0) {
                    ec++;
                }
                walk(child);
                if (bailed) {
                    return false;
                }
            }
        }
        return true;
    }
    return walk(node) ? [nc, ec] : false;
}
function stringifyNode(node, context) {
    if (shared.isString(node)) {
        return node;
    }
    if (shared.isSymbol(node)) {
        return ``;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            return stringifyElement(node, context);
        case 2 /* NodeTypes.TEXT */:
            return shared.escapeHtml(node.content);
        case 3 /* NodeTypes.COMMENT */:
            return `<!--${shared.escapeHtml(node.content)}-->`;
        case 5 /* NodeTypes.INTERPOLATION */:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            return shared.escapeHtml(evaluateConstant(node));
        case 12 /* NodeTypes.TEXT_CALL */:
            return stringifyNode(node.content, context);
        default:
            // static trees will not contain if/for nodes
            return '';
    }
}
function stringifyElement(node, context) {
    let res = `<${node.tag}`;
    let innerHTML = '';
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            res += ` ${p.name}`;
            if (p.value) {
                res += `="${shared.escapeHtml(p.value.content)}"`;
            }
        }
        else if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
            if (p.name === 'bind') {
                const exp = p.exp;
                if (exp.content[0] === '_') {
                    // internally generated string constant references
                    // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
                    res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
                    continue;
                }
                // #6568
                if (shared.isBooleanAttr(p.arg.content) &&
                    exp.content === 'false') {
                    continue;
                }
                // constant v-bind, e.g. :foo="1"
                let evaluated = evaluateConstant(exp);
                if (evaluated != null) {
                    const arg = p.arg && p.arg.content;
                    if (arg === 'class') {
                        evaluated = shared.normalizeClass(evaluated);
                    }
                    else if (arg === 'style') {
                        evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
                    }
                    res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
                }
            }
            else if (p.name === 'html') {
                // #5439 v-html with constant value
                // not sure why would anyone do this but it can happen
                innerHTML = evaluateConstant(p.exp);
            }
            else if (p.name === 'text') {
                innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p.exp)));
            }
        }
    }
    if (context.scopeId) {
        res += ` ${context.scopeId}`;
    }
    res += `>`;
    if (innerHTML) {
        res += innerHTML;
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            res += stringifyNode(node.children[i], context);
        }
    }
    if (!shared.isVoidTag(node.tag)) {
        res += `</${node.tag}>`;
    }
    return res;
}
// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transforms/transformExpression)
function evaluateConstant(exp) {
    if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        return new Function(`return ${exp.content}`)();
    }
    else {
        // compound
        let res = ``;
        exp.children.forEach(c => {
            if (shared.isString(c) || shared.isSymbol(c)) {
                return;
            }
            if (c.type === 2 /* NodeTypes.TEXT */) {
                res += c.content;
            }
            else if (c.type === 5 /* NodeTypes.INTERPOLATION */) {
                res += shared.toDisplayString(evaluateConstant(c.content));
            }
            else {
                res += evaluateConstant(c);
            }
        });
        return res;
    }
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...([])
];
const DOMDirectiveTransforms = {
    cloak: compilerCore.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: stringifyStatic
    }));
}
function parse(template, options = {}) {
    return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
}

exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
exports.DOMNodeTransforms = DOMNodeTransforms;
exports.TRANSITION = TRANSITION;
exports.TRANSITION_GROUP = TRANSITION_GROUP;
exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
exports.V_MODEL_RADIO = V_MODEL_RADIO;
exports.V_MODEL_SELECT = V_MODEL_SELECT;
exports.V_MODEL_TEXT = V_MODEL_TEXT;
exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
exports.V_SHOW = V_SHOW;
exports.compile = compile;
exports.createDOMCompilerError = createDOMCompilerError;
exports.parse = parse;
exports.parserOptions = parserOptions;
exports.transformStyle = transformStyle;
Object.keys(compilerCore).forEach(function(k) {
  if (k !== 'default') exports[k] = compilerCore[k];
});
Ù!/dist/compiler-dom.esm-bundler.jsÅP=import { registerRuntimeHelpers, isBuiltInType, createSimpleExpression, createCompilerError, createObjectProperty, getConstantType, createCallExpression, TO_DISPLAY_STRING, transformModel as transformModel$1, findProp, hasDynamicKeyVBind, transformOn as transformOn$1, isStaticExp, createCompoundExpression, checkCompatEnabled, noopDirectiveTransform, baseCompile, baseParse } from '@vue/compiler-core';
export * from '@vue/compiler-core';
import { isVoidTag, isHTMLTag, isSVGTag, makeMap, parseStringStyle, capitalize, extend } from '@vue/shared';

const V_MODEL_RADIO = Symbol((process.env.NODE_ENV !== 'production') ? `vModelRadio` : ``);
const V_MODEL_CHECKBOX = Symbol((process.env.NODE_ENV !== 'production') ? `vModelCheckbox` : ``);
const V_MODEL_TEXT = Symbol((process.env.NODE_ENV !== 'production') ? `vModelText` : ``);
const V_MODEL_SELECT = Symbol((process.env.NODE_ENV !== 'production') ? `vModelSelect` : ``);
const V_MODEL_DYNAMIC = Symbol((process.env.NODE_ENV !== 'production') ? `vModelDynamic` : ``);
const V_ON_WITH_MODIFIERS = Symbol((process.env.NODE_ENV !== 'production') ? `vOnModifiersGuard` : ``);
const V_ON_WITH_KEYS = Symbol((process.env.NODE_ENV !== 'production') ? `vOnKeysGuard` : ``);
const V_SHOW = Symbol((process.env.NODE_ENV !== 'production') ? `vShow` : ``);
const TRANSITION = Symbol((process.env.NODE_ENV !== 'production') ? `Transition` : ``);
const TRANSITION_GROUP = Symbol((process.env.NODE_ENV !== 'production') ? `TransitionGroup` : ``);
registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag,
    isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
        }
        else if (isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* TextModes.RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* TextModes.RAWTEXT */;
            }
        }
        return 0 /* TextModes.DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* NodeTypes.DIRECTIVE */,
                    name: `bind`,
                    arg: createSimpleExpression(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = parseStringStyle(cssText);
    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return createCompilerError(code, loc, (process.env.NODE_ENV !== 'production') || !true ? DOMErrorMessages : undefined);
}
const DOMErrorMessages = {
    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            createObjectProperty(createSimpleExpression(`textContent`, true), exp
                ? getConstantType(exp, context) > 0
                    ? exp
                    : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
                : createSimpleExpression('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = transformModel$1(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = findProp(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = findProp(node, `type`);
            if (type) {
                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if (hasDynamicKeyVBind(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ makeMap(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            checkCompatEnabled("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if (isStaticExp(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? createSimpleExpression(event, true)
        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
            ? createCompoundExpression([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return transformOn$1(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
            key = isStaticExp(key)
                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [createObjectProperty(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const transformTransition = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (!node.children.length) {
                    return;
                }
                // warn multiple transition children
                if (hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
                // check if it's s single child w/ v-show
                // if yes, inject "persisted: true" to the transition props
                const child = node.children[0];
                if (child.type === 1 /* NodeTypes.ELEMENT */) {
                    for (const p of child.props) {
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {
                            node.props.push({
                                type: 6 /* NodeTypes.ATTRIBUTE */,
                                name: 'persisted',
                                value: undefined,
                                loc: node.loc
                            });
                        }
                    }
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&
        !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* NodeTypes.FOR */ ||
        (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...((process.env.NODE_ENV !== 'production') ? [transformTransition] : [])
];
const DOMDirectiveTransforms = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return baseCompile(template, extend({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return baseParse(template, extend({}, parserOptions, options));
}

export { DOMDirectiveTransforms, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };
­/package.jsonÅÒ{
  "name": "@vue/compiler-dom",
  "version": "3.2.47",
  "description": "@vue/compiler-dom",
  "main": "index.js",
  "module": "dist/compiler-dom.esm-bundler.js",
  "types": "dist/compiler-dom.d.ts",
  "unpkg": "dist/compiler-dom.global.js",
  "jsdelivr": "dist/compiler-dom.global.js",
  "files": [
    "index.js",
    "dist"
  ],
  "sideEffects": false,
  "buildOptions": {
    "name": "VueCompilerDOM",
    "compat": true,
    "formats": [
      "esm-bundler",
      "esm-browser",
      "cjs",
      "global"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vuejs/core.git",
    "directory": "packages/compiler-dom"
  },
  "keywords": [
    "vue"
  ],
  "author": "Evan You",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/vuejs/core/issues"
  },
  "homepage": "https://github.com/vuejs/core/tree/main/packages/compiler-dom#readme",
  "dependencies": {
    "@vue/shared": "3.2.47",
    "@vue/compiler-core": "3.2.47"
  }
}
Ù!/dist/compiler-dom.esm-browser.jsÆ aÇ/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* PatchFlags.TEXT */]: `TEXT`,
    [2 /* PatchFlags.CLASS */]: `CLASS`,
    [4 /* PatchFlags.STYLE */]: `STYLE`,
    [8 /* PatchFlags.PROPS */]: `PROPS`,
    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,
    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,
    [-2 /* PatchFlags.BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* SlotFlags.STABLE */]: 'STABLE',
    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',
    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'
};

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
    const ret = {};
    cssText
        .replace(styleCommentRE, '')
        .split(listDelimiterRE)
        .forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const EMPTY_OBJ = Object.freeze({})
    ;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const extend = Object.assign;
const isArray = Array.isArray;
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);

function defaultOnError(error) {
    throw error;
}
function defaultOnWarn(msg) {
    console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = (messages || errorMessages)[code] + (additionalMessage || ``)
        ;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* ErrorCodes.EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* ErrorCodes.EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* ErrorCodes.EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* ErrorCodes.MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* ErrorCodes.NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [20 /* ErrorCodes.UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
    [22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* ErrorCodes.X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* ErrorCodes.X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    [26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
    // transform errors
    [28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [29 /* ErrorCodes.X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
    [30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
    [34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>. ` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [40 /* ErrorCodes.X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [43 /* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44 /* ErrorCodes.X_V_MODEL_ON_PROPS */]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,
    [45 /* ErrorCodes.X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [51 /* ErrorCodes.__EXTEND_POINT__ */]: ``
};

const FRAGMENT = Symbol(`Fragment` );
const TELEPORT = Symbol(`Teleport` );
const SUSPENSE = Symbol(`Suspense` );
const KEEP_ALIVE = Symbol(`KeepAlive` );
const BASE_TRANSITION = Symbol(`BaseTransition` );
const OPEN_BLOCK = Symbol(`openBlock` );
const CREATE_BLOCK = Symbol(`createBlock` );
const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock` );
const CREATE_VNODE = Symbol(`createVNode` );
const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode` );
const CREATE_COMMENT = Symbol(`createCommentVNode` );
const CREATE_TEXT = Symbol(`createTextVNode` );
const CREATE_STATIC = Symbol(`createStaticVNode` );
const RESOLVE_COMPONENT = Symbol(`resolveComponent` );
const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent` );
const RESOLVE_DIRECTIVE = Symbol(`resolveDirective` );
const RESOLVE_FILTER = Symbol(`resolveFilter` );
const WITH_DIRECTIVES = Symbol(`withDirectives` );
const RENDER_LIST = Symbol(`renderList` );
const RENDER_SLOT = Symbol(`renderSlot` );
const CREATE_SLOTS = Symbol(`createSlots` );
const TO_DISPLAY_STRING = Symbol(`toDisplayString` );
const MERGE_PROPS = Symbol(`mergeProps` );
const NORMALIZE_CLASS = Symbol(`normalizeClass` );
const NORMALIZE_STYLE = Symbol(`normalizeStyle` );
const NORMALIZE_PROPS = Symbol(`normalizeProps` );
const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps` );
const TO_HANDLERS = Symbol(`toHandlers` );
const CAMELIZE = Symbol(`camelize` );
const CAPITALIZE = Symbol(`capitalize` );
const TO_HANDLER_KEY = Symbol(`toHandlerKey` );
const SET_BLOCK_TRACKING = Symbol(`setBlockTracking` );
const PUSH_SCOPE_ID = Symbol(`pushScopeId` );
const POP_SCOPE_ID = Symbol(`popScopeId` );
const WITH_CTX = Symbol(`withCtx` );
const UNREF = Symbol(`unref` );
const IS_REF = Symbol(`isRef` );
const WITH_MEMO = Symbol(`withMemo` );
const IS_MEMO_SAME = Symbol(`isMemoSame` );
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* NodeTypes.ROOT */,
        children,
        helpers: new Set(),
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
        }
        else {
            context.helper(getVNodeHelper(context.inSSR, isComponent));
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* NodeTypes.VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* NodeTypes.JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* NodeTypes.JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* NodeTypes.JS_PROPERTY */,
        loc: locStub,
        key: isString(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* ConstantTypes.NOT_CONSTANT */) {
    return {
        type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : constType
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* NodeTypes.INTERPOLATION */,
        loc,
        content: isString(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* NodeTypes.COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* NodeTypes.JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* NodeTypes.JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* NodeTypes.JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* NodeTypes.JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* NodeTypes.JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isStaticExp = (p) => p.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */
const isMemberExpressionBrowser = (path) => {
    // remove whitespaces around . or [ first
    path = path.trim().replace(whitespaceRE, s => s.trim());
    let state = 0 /* MemberExpLexState.inMemberExp */;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
            case 0 /* MemberExpLexState.inMemberExp */:
                if (char === '[') {
                    stateStack.push(state);
                    state = 1 /* MemberExpLexState.inBrackets */;
                    currentOpenBracketCount++;
                }
                else if (char === '(') {
                    stateStack.push(state);
                    state = 2 /* MemberExpLexState.inParens */;
                    currentOpenParensCount++;
                }
                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                    return false;
                }
                break;
            case 1 /* MemberExpLexState.inBrackets */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* MemberExpLexState.inString */;
                    currentStringType = char;
                }
                else if (char === `[`) {
                    currentOpenBracketCount++;
                }
                else if (char === `]`) {
                    if (!--currentOpenBracketCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 2 /* MemberExpLexState.inParens */:
                if (char === `'` || char === `"` || char === '`') {
                    stateStack.push(state);
                    state = 3 /* MemberExpLexState.inString */;
                    currentStringType = char;
                }
                else if (char === `(`) {
                    currentOpenParensCount++;
                }
                else if (char === `)`) {
                    // if the exp ends as a call then it should not be considered valid
                    if (i === path.length - 1) {
                        return false;
                    }
                    if (!--currentOpenParensCount) {
                        state = stateStack.pop();
                    }
                }
                break;
            case 3 /* MemberExpLexState.inString */:
                if (char === currentStringType) {
                    state = stateStack.pop();
                    currentStringType = null;
                }
                break;
        }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = NOOP
    ;
const isMemberExpression = isMemberExpressionBrowser
    ;
function getInnerRange(loc, offset, length) {
    const source = loc.source.slice(offset, offset + length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            (isString(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' &&
            (p.exp || allowEmpty) &&
            isStaticArgOf(p.arg, name)) {
            return p;
        }
    }
}
function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText$1(node) {
    return node.type === 5 /* NodeTypes.INTERPOLATION */ || node.type === 2 /* NodeTypes.TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 3 /* ElementTypes.TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 2 /* ElementTypes.SLOT */;
}
function getVNodeHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
    if (props &&
        !isString(props) &&
        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        const callee = props.callee;
        if (!isString(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
    }
    return [props, callPath];
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    /**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */
    let props = node.type === 13 /* NodeTypes.VNODE_CALL */ ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props &&
        !isString(props) &&
        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
    }
    if (props == null || isString(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!isString(first) && first.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
            // #6631
            if (!hasProp(prop, first)) {
                first.properties.unshift(prop);
            }
        }
        else {
            if (props.callee === TO_HANDLERS) {
                // #2366
                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                    createObjectExpression([prop]),
                    props
                ]);
            }
            else {
                props.arguments.unshift(createObjectExpression([prop]));
            }
        }
        !propsWithInjection && (propsWithInjection = props);
    }
    else if (props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
        if (!hasProp(prop, props)) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
        // the `guardReactiveProps` will no longer be needed
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
        }
    }
    if (node.type === 13 /* NodeTypes.VNODE_CALL */) {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.props = propsWithInjection;
        }
    }
    else {
        if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
        }
        else {
            node.arguments[2] = propsWithInjection;
        }
    }
}
// check existing key to avoid overriding user provided keys
function hasProp(prop, props) {
    let result = false;
    if (prop.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        const propKeyName = prop.key.content;
        result = props.properties.some(p => p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
            p.key.content === propKeyName);
    }
    return result;
}
function toValidAssetId(name, type) {
    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* NodeTypes.FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* NodeTypes.IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* NodeTypes.IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            return node.children.some(c => isObject(c) && hasScopeRef(c, ids));
        case 5 /* NodeTypes.INTERPOLATION */:
        case 12 /* NodeTypes.TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* NodeTypes.TEXT */:
        case 3 /* NodeTypes.COMMENT */:
            return false;
        default:
            return false;
    }
}
function getMemoedVNodeCall(node) {
    if (node.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
    }
    else {
        return node;
    }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
}

const deprecationData = {
    ["COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */]: {
        message: `Platform-native elements with "is" prop will no longer be ` +
            `treated as components in Vue 3 unless the "is" value is explicitly ` +
            `prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */]: {
        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
            `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
            `\`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
            `Vue 3 will automatically set a binding as DOM property when appropriate.`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
            `object spread: it will now overwrite an existing non-mergeable attribute ` +
            `that appears before v-bind in the case of conflict. ` +
            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
            `You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
        message: `v-if / v-for precedence when used on the same element has changed ` +
            `in Vue 3: v-if now takes higher precedence and will no longer have ` +
            `access to v-for scope variables. It is best to avoid the ambiguity ` +
            `with <template> tags or use a computed property that filters v-for ` +
            `data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */]: {
        message: `<template> with no special directives will render as a native template ` +
            `element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
};
function getCompatValue(key, context) {
    const config = context.options
        ? context.options.compatConfig
        : context.compatConfig;
    const value = config && config[key];
    if (key === 'MODE') {
        return value || 3; // compiler defaults to v3 behavior
    }
    else {
        return value;
    }
}
function isCompatEnabled(key, context) {
    const mode = getCompatValue('MODE', context);
    const value = getCompatValue(key, context);
    // in v3 mode, only enable if explicitly set to true
    // otherwise enable for any non-false value
    return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (enabled) {
        warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === 'suppress-warning') {
        return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
        err.loc = loc;
    context.onWarn(err);
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* Namespaces.HTML */,
    getTextMode: () => 0 /* TextModes.DATA */,
    isVoidTag: NO,
    isPreTag: NO,
    isCustomElement: NO,
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: true
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* TextModes.DATA */, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
    const options = extend({}, defaultParserOptions);
    let key;
    for (key in rawOptions) {
        // @ts-ignore
        options[key] =
            rawOptions[key] === undefined
                ? defaultParserOptions[key]
                : rawOptions[key];
    }
    return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* Namespaces.HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* TextModes.DATA */ || mode === 1 /* TextModes.RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* TextModes.DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* Namespaces.HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* ErrorCodes.MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* ErrorCodes.X_INVALID_END_TAG */);
                        parseTag(context, 1 /* TagType.End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                    // 2.x <template> with no directive compat
                    if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context) &&
                        node &&
                        node.tag === 'template' &&
                        !node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                            isSpecialTemplateDirective(p.name))) {
                        warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                        node = node.children;
                    }
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if (isArray(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace handling strategy like v2
    let removedWhitespace = false;
    if (mode !== 2 /* TextModes.RAWTEXT */ && mode !== 1 /* TextModes.RCDATA */) {
        const shouldCondense = context.options.whitespace !== 'preserve';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.type === 2 /* NodeTypes.TEXT */) {
                if (!context.inPre) {
                    if (!/[^\t\r\n\f ]/.test(node.content)) {
                        const prev = nodes[i - 1];
                        const next = nodes[i + 1];
                        // Remove if:
                        // - the whitespace is the first or last node, or:
                        // - (condense mode) the whitespace is between twos comments, or:
                        // - (condense mode) the whitespace is between comment and element, or:
                        // - (condense mode) the whitespace is between two elements AND contains newline
                        if (!prev ||
                            !next ||
                            (shouldCondense &&
                                ((prev.type === 3 /* NodeTypes.COMMENT */ &&
                                    next.type === 3 /* NodeTypes.COMMENT */) ||
                                    (prev.type === 3 /* NodeTypes.COMMENT */ &&
                                        next.type === 1 /* NodeTypes.ELEMENT */) ||
                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                        next.type === 3 /* NodeTypes.COMMENT */) ||
                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                        next.type === 1 /* NodeTypes.ELEMENT */ &&
                                        /[\r\n]/.test(node.content))))) {
                            removedWhitespace = true;
                            nodes[i] = null;
                        }
                        else {
                            // Otherwise, the whitespace is condensed into a single space
                            node.content = ' ';
                        }
                    }
                    else if (shouldCondense) {
                        // in condense mode, consecutive whitespaces in text are condensed
                        // down to a single space.
                        node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                    }
                }
                else {
                    // #6410 normalize windows newlines in <pre>:
                    // in SSR, browsers normalize server-rendered \r\n into a single \n
                    // in the DOM
                    node.content = node.content.replace(/\r\n/g, '\n');
                }
            }
            // Remove comment nodes if desired by configuration.
            else if (node.type === 3 /* NodeTypes.COMMENT */ && !context.options.comments) {
                removedWhitespace = true;
                nodes[i] = null;
            }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* NodeTypes.TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    if (node.type === 2 /* NodeTypes.TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* NodeTypes.TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* TextModes.CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* ErrorCodes.EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* ErrorCodes.EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* ErrorCodes.NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* NodeTypes.COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* NodeTypes.COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* TagType.Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        // #4030 self-closing <pre> tag
        if (isPreBoundary) {
            context.inPre = false;
        }
        if (isVPreBoundary) {
            context.inVPre = false;
        }
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    // 2.x inline-template compat
    {
        const inlineTemplateProp = element.props.find(p => p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'inline-template');
        if (inlineTemplateProp &&
            checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
            const loc = getSelection(context, element.loc.end);
            inlineTemplateProp.value = {
                type: 2 /* NodeTypes.TEXT */,
                content: loc.source,
                loc
            };
        }
    }
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* TagType.End */, parent);
    }
    else {
        emitError(context, 24 /* ErrorCodes.X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // Attributes.
    let props = parseAttributes(context, type);
    // check v-pre
    if (type === 0 /* TagType.Start */ &&
        !context.inVPre &&
        props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        extend(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* ErrorCodes.EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* TagType.End */ && isSelfClosing) {
            emitError(context, 4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type === 1 /* TagType.End */) {
        return;
    }
    // 2.x deprecation checks
    if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                if (p.name === 'if') {
                    hasIf = true;
                }
                else if (p.name === 'for') {
                    hasFor = true;
                }
            }
            if (hasIf && hasFor) {
                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                break;
            }
        }
    }
    let tagType = 0 /* ElementTypes.ELEMENT */;
    if (!context.inVPre) {
        if (tag === 'slot') {
            tagType = 2 /* ElementTypes.SLOT */;
        }
        else if (tag === 'template') {
            if (props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                tagType = 3 /* ElementTypes.TEMPLATE */;
            }
        }
        else if (isComponent(tag, props, context)) {
            tagType = 1 /* ElementTypes.COMPONENT */;
        }
    }
    return {
        type: 1 /* NodeTypes.ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function isComponent(tag, props, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
        return false;
    }
    if (tag === 'component' ||
        /^[A-Z]/.test(tag) ||
        isCoreComponent(tag) ||
        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
        (options.isNativeTag && !options.isNativeTag(tag))) {
        return true;
    }
    // at this point the tag should be a native tag, but check for potential "is"
    // casting
    for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (p.name === 'is' && p.value) {
                if (p.value.content.startsWith('vue:')) {
                    return true;
                }
                else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                    return true;
                }
            }
        }
        else {
            // directive
            // v-is (TODO Deprecate)
            if (p.name === 'is') {
                return true;
            }
            else if (
            // :is on plain element - only treat as component in compat mode
            p.name === 'bind' &&
                isStaticArgOf(p.arg, 'is') &&
                true &&
                checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                return true;
            }
        }
    }
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* TagType.End */) {
            emitError(context, 3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        // Trim whitespace between class
        // https://github.com/vuejs/core/issues/4251
        if (attr.type === 6 /* NodeTypes.ATTRIBUTE */ &&
            attr.value &&
            attr.name === 'class') {
            attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
        }
        if (type === 0 /* TagType.Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, '.');
        let dirName = match[1] ||
            (isPropShorthand || startsWith(name, ':')
                ? 'bind'
                : startsWith(name, '@')
                    ? 'on'
                    : 'slot');
        let arg;
        if (match[2]) {
            const isSlot = dirName === 'slot';
            const startOffset = name.lastIndexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                    content = content.slice(1);
                }
                else {
                    content = content.slice(1, content.length - 1);
                }
            }
            else if (isSlot) {
                // #1241 special case for v-slot: vuetify relies extensively on slot
                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                // supports such usage so we are keeping it consistent with 2.x.
                content += match[3] || '';
            }
            arg = {
                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                content,
                isStatic,
                constType: isStatic
                    ? 3 /* ConstantTypes.CAN_STRINGIFY */
                    : 0 /* ConstantTypes.NOT_CONSTANT */,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match[3] ? match[3].slice(1).split('.') : [];
        if (isPropShorthand)
            modifiers.push('prop');
        // 2.x compat v-bind:foo.sync -> v-model:foo
        if (dirName === 'bind' && arg) {
            if (modifiers.includes('sync') &&
                checkCompatEnabled("COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                dirName = 'model';
                modifiers.splice(modifiers.indexOf('sync'), 1);
            }
            if (modifiers.includes('prop')) {
                checkCompatEnabled("COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */, context, loc);
            }
        }
        return {
            type: 7 /* NodeTypes.DIRECTIVE */,
            name: dirName,
            exp: value && {
                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // other values by `transformExpression` to make it eligible for hoisting.
                constType: 0 /* ConstantTypes.NOT_CONSTANT */,
                loc: value.loc
            },
            arg,
            modifiers,
            loc
        };
    }
    // missing directive name or illegal directive name
    if (!context.inVPre && startsWith(name, 'v-')) {
        emitError(context, 26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */);
    }
    return {
        type: 6 /* NodeTypes.ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* NodeTypes.TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* TextModes.ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* TextModes.ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* TextModes.ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* NodeTypes.INTERPOLATION */,
        content: {
            type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0 /* ConstantTypes.NOT_CONSTANT */,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = mode === 3 /* TextModes.CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* NodeTypes.TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* TextModes.RAWTEXT */ ||
        mode === 3 /* TextModes.CDATA */ ||
        !rawText.includes('&')) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* TextModes.ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* TextModes.DATA */:
            if (startsWith(s, '</')) {
                // TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* TextModes.RCDATA */:
        case 2 /* TextModes.RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* TextModes.CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root, context, 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* NodeTypes.ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* NodeTypes.ELEMENT */ &&
            child.tagType === 0 /* ElementTypes.ELEMENT */) {
            const constantType = doNotHoistNode
                ? 0 /* ConstantTypes.NOT_CONSTANT */
                : getConstantType(child, context);
            if (constantType > 0 /* ConstantTypes.NOT_CONSTANT */) {
                if (constantType >= 2 /* ConstantTypes.CAN_HOIST */) {
                    child.codegenNode.patchFlag =
                        -1 /* PatchFlags.HOISTED */ + (` /* HOISTED */` );
                    child.codegenNode = context.hoist(child.codegenNode);
                    hoistedCount++;
                    continue;
                }
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* PatchFlags.NEED_PATCH */ ||
                        flag === 1 /* PatchFlags.TEXT */) &&
                        getGeneratedPropsConstantType(child, context) >=
                            2 /* ConstantTypes.CAN_HOIST */) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                    if (codegenNode.dynamicProps) {
                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                    }
                }
            }
        }
        // walk further
        if (child.type === 1 /* NodeTypes.ELEMENT */) {
            const isComponent = child.tagType === 1 /* ElementTypes.COMPONENT */;
            if (isComponent) {
                context.scopes.vSlot++;
            }
            walk(child, context);
            if (isComponent) {
                context.scopes.vSlot--;
            }
        }
        else if (child.type === 11 /* NodeTypes.FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child, context, child.children.length === 1);
        }
        else if (child.type === 9 /* NodeTypes.IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                // Do not hoist v-if single child because it has to be a block
                walk(child.branches[i], context, child.branches[i].children.length === 1);
            }
        }
    }
    if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
    }
    // all children were hoisted - the entire children array is hoistable.
    if (hoistedCount &&
        hoistedCount === originalCount &&
        node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        node.codegenNode &&
        node.codegenNode.type === 13 /* NodeTypes.VNODE_CALL */ &&
        isArray(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
}
function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
            if (node.tagType !== 0 /* ElementTypes.ELEMENT */) {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            const cached = constantCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* NodeTypes.VNODE_CALL */) {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            if (codegenNode.isBlock &&
                node.tag !== 'svg' &&
                node.tag !== 'foreignObject') {
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
                let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
                // Element itself has no patch flag. However we still need to check:
                // 1. Even for a node with no patch flag, it is possible for it to contain
                // non-hoistable expressions that refers to scope variables, e.g. compiler
                // injected keys or cached event handlers. Therefore we need to always
                // check the codegenNode's props to be sure.
                const generatedPropsType = getGeneratedPropsConstantType(node, context);
                if (generatedPropsType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                    return 0 /* ConstantTypes.NOT_CONSTANT */;
                }
                if (generatedPropsType < returnType) {
                    returnType = generatedPropsType;
                }
                // 2. its children.
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getConstantType(node.children[i], context);
                    if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                        constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                        return 0 /* ConstantTypes.NOT_CONSTANT */;
                    }
                    if (childType < returnType) {
                        returnType = childType;
                    }
                }
                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                // type, check if any of the props can cause the type to be lowered
                // we can skip can_patch because it's guaranteed by the absence of a
                // patchFlag.
                if (returnType > 1 /* ConstantTypes.CAN_SKIP_PATCH */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && p.exp) {
                            const expType = getConstantType(p.exp, context);
                            if (expType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                                return 0 /* ConstantTypes.NOT_CONSTANT */;
                            }
                            if (expType < returnType) {
                                returnType = expType;
                            }
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // static then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    // except set custom directives.
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                            constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                            return 0 /* ConstantTypes.NOT_CONSTANT */;
                        }
                    }
                    context.removeHelper(OPEN_BLOCK);
                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                    codegenNode.isBlock = false;
                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                }
                constantCache.set(node, returnType);
                return returnType;
            }
            else {
                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                return 0 /* ConstantTypes.NOT_CONSTANT */;
            }
        case 2 /* NodeTypes.TEXT */:
        case 3 /* NodeTypes.COMMENT */:
            return 3 /* ConstantTypes.CAN_STRINGIFY */;
        case 9 /* NodeTypes.IF */:
        case 11 /* NodeTypes.FOR */:
        case 10 /* NodeTypes.IF_BRANCH */:
            return 0 /* ConstantTypes.NOT_CONSTANT */;
        case 5 /* NodeTypes.INTERPOLATION */:
        case 12 /* NodeTypes.TEXT_CALL */:
            return getConstantType(node.content, context);
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            return node.constType;
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (isString(child) || isSymbol(child)) {
                    continue;
                }
                const childType = getConstantType(child, context);
                if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    return 0 /* ConstantTypes.NOT_CONSTANT */;
                }
                else if (childType < returnType) {
                    returnType = childType;
                }
            }
            return returnType;
        default:
            return 0 /* ConstantTypes.NOT_CONSTANT */;
    }
}
const allowHoistedHelperSet = new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ &&
        !isString(value.callee) &&
        allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
            return getConstantType(arg, context);
        }
        else if (arg.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
            return getConstantTypeOfHelperCall(arg, context);
        }
    }
    return 0 /* ConstantTypes.NOT_CONSTANT */;
}
function getGeneratedPropsConstantType(node, context) {
    let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
    const props = getNodeProps(node);
    if (props && props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
            const { key, value } = properties[i];
            const keyType = getConstantType(key, context);
            if (keyType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                return keyType;
            }
            if (keyType < returnType) {
                returnType = keyType;
            }
            let valueType;
            if (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                valueType = getConstantType(value, context);
            }
            else if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
                // some helper calls can be hoisted,
                // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                // in this case we need to respect the ConstantType of the helper's arguments
                valueType = getConstantTypeOfHelperCall(value, context);
            }
            else {
                valueType = 0 /* ConstantTypes.NOT_CONSTANT */;
            }
            if (valueType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                return valueType;
            }
            if (valueType < returnType) {
                returnType = valueType;
            }
        }
    }
    return returnType;
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
    const context = {
        // options
        selfName: nameMatch && capitalize(camelize(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        // state
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        // methods
        helper(name) {
            const count = context.helpers.get(name) || 0;
            context.helpers.set(name, count + 1);
            return name;
        },
        removeHelper(name) {
            const count = context.helpers.get(name);
            if (count) {
                const currentCount = count - 1;
                if (!currentCount) {
                    context.helpers.delete(name);
                }
                else {
                    context.helpers.set(name, currentCount);
                }
            }
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            {
                if (!context.currentNode) {
                    throw new Error(`Node being replaced is already removed.`);
                }
                if (!context.parent) {
                    throw new Error(`Cannot replace root node.`);
                }
            }
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (!context.parent) {
                throw new Error(`Cannot remove root node.`);
            }
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (removalIndex < 0) {
                throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            if (isString(exp))
                exp = createSimpleExpression(exp);
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* ConstantTypes.CAN_HOIST */);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(context.cached++, exp, isVNode);
        }
    };
    {
        context.filters = new Set();
    }
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = new Set([...context.helpers.keys()]);
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
        root.filters = [...context.filters];
    }
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
        const child = children[0];
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                makeBlock(codegenNode, context);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
        let patchFlagText = PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];
        // check if the fragment actually contains a single valid child with
        // the rest being comments
        if (children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
            patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
            patchFlagText += `, ${PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;
        }
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, undefined, false /* isComponent */);
    }
    else ;
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if (isString(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if (isArray(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* NodeTypes.COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* NodeTypes.INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* NodeTypes.IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* NodeTypes.IF_BRANCH */:
        case 11 /* NodeTypes.FOR */:
        case 1 /* NodeTypes.ELEMENT */:
        case 0 /* NodeTypes.ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = isString(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* NodeTypes.ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* ElementTypes.TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
        options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const helpers = Array.from(ast.helpers);
    const hasHelpers = helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    const isSetupInlined = !true ;
    // preambles
    // in setup() inline mode, the preamble is generated in a sub context
    // and returned separately.
    const preambleContext = isSetupInlined
        ? createCodegenContext(ast, options)
        : context;
    {
        genFunctionPreamble(ast, preambleContext);
    }
    // enter render function
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
    const signature = args.join(', ');
    {
        push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${helpers.map(aliasHelper).join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, 'filter', context);
        newline();
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        preamble: isSetupInlined ? preambleContext.code : ``,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
    const VueBinding = runtimeGlobalName;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    const helpers = Array.from(ast.helpers);
    if (helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_ELEMENT_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(type === 'filter'
        ? RESOLVE_FILTER
        : type === 'component'
            ? RESOLVE_COMPONENT
            : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        // potential component implicit self-reference inferred from SFC filename
        const maybeSelfReference = id.endsWith('__self');
        if (maybeSelfReference) {
            id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
            push(`const _hoisted_${i + 1} = ${``}`);
            genNode(exp, context);
            newline();
        }
    }
    context.pure = false;
}
function isText(n) {
    return (isString(n) ||
        n.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
        n.type === 2 /* NodeTypes.TEXT */ ||
        n.type === 5 /* NodeTypes.INTERPOLATION */ ||
        n.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        (nodes.some(n => isArray(n) || !isText(n)));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (isString(node)) {
            push(node);
        }
        else if (isArray(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if (isString(node)) {
        context.push(node);
        return;
    }
    if (isSymbol(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* NodeTypes.ELEMENT */:
        case 9 /* NodeTypes.IF */:
        case 11 /* NodeTypes.FOR */:
            assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                    `Apply appropriate transforms first.`);
            genNode(node.codegenNode, context);
            break;
        case 2 /* NodeTypes.TEXT */:
            genText(node, context);
            break;
        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* NodeTypes.INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* NodeTypes.TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* NodeTypes.COMMENT */:
            genComment(node, context);
            break;
        case 13 /* NodeTypes.VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* NodeTypes.JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* NodeTypes.JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        case 21 /* NodeTypes.JS_BLOCK_STATEMENT */:
            genNodeList(node.body, context, true, false);
            break;
        // SSR only types
        case 22 /* NodeTypes.JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* NodeTypes.JS_IF_STATEMENT */:
            break;
        case 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* NodeTypes.JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* NodeTypes.IF_BRANCH */:
            // noop
            break;
        default:
            {
                assert(false, `unhandled codegen node type: ${node.type}`);
                // make sure we exhaust all possible types
                const exhaustiveCheck = node;
                return exhaustiveCheck;
            }
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    const callHelper = isBlock
        ? getVNodeBlockHelper(context.inSSR, isComponent)
        : getVNodeHelper(context.inSSR, isComponent);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = isString(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        (properties.some(p => p.value.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */));
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        // wrap slot functions with owner context
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if (isArray(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if (isArray(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if (isSlot) {
        if (node.isNonScopedSlot) {
            push(`, undefined, true`);
        }
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
    {
        return;
    }
}
function isReferencedIdentifier(id, parent, parentStack) {
    {
        return false;
    }
}
function isInDestructureAssignment(parent, parentStack) {
    if (parent &&
        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
        let i = parentStack.length;
        while (i--) {
            const p = parentStack[i];
            if (p.type === 'AssignmentExpression') {
                return true;
            }
            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                break;
            }
        }
    }
    return false;
}
function walkFunctionParams(node, onIdent) {
    for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
            onIdent(id);
        }
    }
}
function walkBlockDeclarations(block, onIdent) {
    for (const stmt of block.body) {
        if (stmt.type === 'VariableDeclaration') {
            if (stmt.declare)
                continue;
            for (const decl of stmt.declarations) {
                for (const id of extractIdentifiers(decl.id)) {
                    onIdent(id);
                }
            }
        }
        else if (stmt.type === 'FunctionDeclaration' ||
            stmt.type === 'ClassDeclaration') {
            if (stmt.declare || !stmt.id)
                continue;
            onIdent(stmt.id);
        }
    }
}
function extractIdentifiers(param, nodes = []) {
    switch (param.type) {
        case 'Identifier':
            nodes.push(param);
            break;
        case 'MemberExpression':
            let object = param;
            while (object.type === 'MemberExpression') {
                object = object.object;
            }
            nodes.push(object);
            break;
        case 'ObjectPattern':
            for (const prop of param.properties) {
                if (prop.type === 'RestElement') {
                    extractIdentifiers(prop.argument, nodes);
                }
                else {
                    extractIdentifiers(prop.value, nodes);
                }
            }
            break;
        case 'ArrayPattern':
            param.elements.forEach(element => {
                if (element)
                    extractIdentifiers(element, nodes);
            });
            break;
        case 'RestElement':
            extractIdentifiers(param.argument, nodes);
            break;
        case 'AssignmentPattern':
            extractIdentifiers(param.left, nodes);
            break;
    }
    return nodes;
}
const isFunctionType = (node) => {
    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node &&
    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
    !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

// these keywords should not appear inside expressions, but operators like
// 'typeof', 'instanceof', and 'in' are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('arguments,await,break,case,catch,class,const,continue,debugger,default,' +
        'delete,do,else,export,extends,finally,for,function,if,import,let,new,' +
        'return,super,switch,throw,try,var,void,while,with,yield')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    // empty expressions are validated per-directive since some directives
    // do allow empty expressions.
    if (!exp.trim()) {
        return;
    }
    try {
        new Function(asRawStatements
            ? ` ${exp} `
            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    }
    catch (e) {
        let message = e.message;
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context.onError(createCompilerError(45 /* ErrorCodes.X_INVALID_EXPRESSION */, node.loc, undefined, message));
    }
}

const transformExpression = (node, context) => {
    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* NodeTypes.ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* NodeTypes.DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
        {
            // simple in-browser validation (same logic in 2.x)
            validateBrowserExpression(node, context, asParams, asRawStatements);
        }
        return node;
    }
}
function stringifyExpression(exp) {
    if (isString(exp)) {
        return exp;
    }
    else if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        return exp.content;
    }
    else {
        return exp.children
            .map(stringifyExpression)
            .join('');
    }
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // #1587: We need to dynamically increment the key based on the current
        // node's sibling nodes, since chained v-if/else branches are
        // rendered at the same depth
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                key += sibling.branches.length;
            }
        }
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                const parentCondition = getParentCondition(ifNode.codegenNode);
                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (dir.exp) {
        validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* NodeTypes.IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 3 /* NodeTypes.COMMENT */) {
                context.removeNode(sibling);
                comments.unshift(sibling);
                continue;
            }
            if (sibling &&
                sibling.type === 2 /* NodeTypes.TEXT */ &&
                !sibling.content.trim().length) {
                context.removeNode(sibling);
                continue;
            }
            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                // Check if v-else was followed by v-else-if
                if (dir.name === 'else-if' &&
                    sibling.branches[sibling.branches.length - 1].condition === undefined) {
                    context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                }
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (comments.length &&
                    // #3619 ignore comments if the v-if is direct child of <transition>
                    !(context.parent &&
                        context.parent.type === 1 /* NodeTypes.ELEMENT */ &&
                        isBuiltInType(context.parent.tag, 'transition'))) {
                    branch.children = [...comments, ...branch.children];
                }
                // check if user is forcing same key on different branches
                {
                    const key = branch.userKey;
                    if (key) {
                        sibling.branches.forEach(({ userKey }) => {
                            if (isSameKey(userKey, key)) {
                                context.onError(createCompilerError(29 /* ErrorCodes.X_V_IF_SAME_KEY */, branch.userKey.loc));
                            }
                        });
                    }
                }
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3 /* ElementTypes.TEMPLATE */;
    return {
        type: 10 /* NodeTypes.IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
        userKey: findProp(node, `key`),
        isTemplateIf
    };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            '"v-if"' ,
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, keyIndex, context);
    }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* ConstantTypes.CAN_HOIST */));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* NodeTypes.ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* NodeTypes.FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
            let patchFlagText = PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];
            // check if the fragment actually contains a single valid child with
            // the rest being comments
            if (!branch.isTemplateIf &&
                children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
                patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
                patchFlagText += `, ${PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;
            }
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, false, false /* isComponent */, branch.loc);
        }
    }
    else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* NodeTypes.VNODE_CALL */) {
            makeBlock(vnodeCall, context);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return ret;
    }
}
function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
        return false;
    }
    if (a.type === 6 /* NodeTypes.ATTRIBUTE */) {
        if (a.value.content !== b.value.content) {
            return false;
        }
    }
    else {
        // directive
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
            return false;
        }
        if (exp.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
            exp.isStatic !== branchExp.isStatic ||
            exp.content !== branchExp.content) {
            return false;
        }
    }
    return true;
}
function getParentCondition(node) {
    while (true) {
        if (node.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
            if (node.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                node = node.alternate;
            }
            else {
                return node;
            }
        }
        else if (node.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */) {
            node = node.value;
        }
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, 'memo');
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp &&
            (keyProp.type === 6 /* NodeTypes.ATTRIBUTE */
                ? createSimpleExpression(keyProp.value.content, true)
                : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
            forNode.source.constType > 0 /* ConstantTypes.NOT_CONSTANT */;
        const fragmentFlag = isStableFragment
            ? 64 /* PatchFlags.STABLE_FRAGMENT */
            : keyProp
                ? 128 /* PatchFlags.KEYED_FRAGMENT */
                : 256 /* PatchFlags.UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
            (` /* ${PatchFlagNames[fragmentFlag]} */` ), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const { children } = forNode;
            // check <template v-for> key placement
            if (isTemplate) {
                node.children.some(c => {
                    if (c.type === 1 /* NodeTypes.ELEMENT */) {
                        const key = findProp(c, 'key');
                        if (key) {
                            context.onError(createCompilerError(33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                            return true;
                        }
                    }
                });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* PatchFlags.STABLE_FRAGMENT */ +
                    (` /* ${PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */]} */`
                        ), undefined, undefined, true, undefined, false /* isComponent */);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                if (isTemplate && keyProperty) {
                    injectProp(childBlock, keyProperty, context);
                }
                if (childBlock.isBlock !== !isStableFragment) {
                    if (childBlock.isBlock) {
                        // switch from block to vnode
                        removeHelper(OPEN_BLOCK);
                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                    }
                    else {
                        // switch from vnode to block
                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                    }
                }
                childBlock.isBlock = !isStableFragment;
                if (childBlock.isBlock) {
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                }
                else {
                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
            }
            if (memo) {
                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                    createSimpleExpression(`_cached`)
                ]));
                loop.body = createBlockStatement([
                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                    createCompoundExpression([
                        `if (_cached`,
                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                    ]),
                    createCompoundExpression([`const _item = `, childBlock]),
                    createSimpleExpression(`_item.memo = _memo`),
                    createSimpleExpression(`return _item`)
                ]);
                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            }
            else {
                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp, context);
    if (!parseResult) {
        context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* NodeTypes.FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    {
        validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, '').trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            {
                validateBrowserExpression(result.key, context, true);
            }
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
                {
                    validateBrowserExpression(result.index, context, true);
                }
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        {
            validateBrowserExpression(result.value, context, true);
        }
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
    let i = args.length;
    while (i--) {
        if (args[i])
            break;
    }
    return args
        .slice(0, i + 1)
        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        (node.tagType === 1 /* ElementTypes.COMPONENT */ ||
            node.tagType === 3 /* ElementTypes.TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    let conditionalBranchIndex = 0;
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* NodeTypes.COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* NodeTypes.COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
            }
            else {
                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp, context);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children) => {
            const fn = buildSlotFn(props, children, loc);
            if (context.compatConfig) {
                fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length &&
            // #3766
            // with whitespace: 'preserve', whitespaces between slots will end up in
            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    const slotFlag = hasDynamicSlots
        ? 2 /* SlotFlags.DYNAMIC */
        : hasForwardedSlots(node.children)
            ? 3 /* SlotFlags.FORWARDED */
            : 1 /* SlotFlags.STABLE */;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
    // 2 = compiled but dynamic = can skip normalization, but must run diff
    // 1 = compiled and static = can skip normalization AND diff as optimized
    createSimpleExpression(slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ), false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn, index) {
    const props = [
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ];
    if (index != null) {
        props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
    }
    return createObjectExpression(props);
}
function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
            case 1 /* NodeTypes.ELEMENT */:
                if (child.tagType === 2 /* ElementTypes.SLOT */ ||
                    hasForwardedSlots(child.children)) {
                    return true;
                }
                break;
            case 9 /* NodeTypes.IF */:
                if (hasForwardedSlots(child.branches))
                    return true;
                break;
            case 10 /* NodeTypes.IF_BRANCH */:
            case 11 /* NodeTypes.FOR */:
                if (hasForwardedSlots(child.children))
                    return true;
                break;
        }
    }
    return false;
}
function isNonWhitespaceContent(node) {
    if (node.type !== 2 /* NodeTypes.TEXT */ && node.type !== 12 /* NodeTypes.TEXT_CALL */)
        return true;
    return node.type === 2 /* NodeTypes.TEXT */
        ? !!node.content.trim()
        : isNonWhitespaceContent(node.content);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 /* NodeTypes.ELEMENT */ &&
            (node.tagType === 0 /* ElementTypes.ELEMENT */ ||
                node.tagType === 1 /* ElementTypes.COMPONENT */))) {
            return;
        }
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* ElementTypes.COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        let vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            vnodeTag === TELEPORT ||
            vnodeTag === SUSPENSE ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' || tag === 'foreignObject'));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
            if (propsBuildResult.shouldUseBlock) {
                shouldUseBlock = true;
            }
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                if (node.children.length > 1) {
                    context.onError(createCompilerError(46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* NodeTypes.INTERPOLATION */ ||
                    type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild &&
                    getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                    patchFlag |= 1 /* PatchFlags.TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* NodeTypes.TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            {
                if (patchFlag < 0) {
                    // special flags (negative and mutually exclusive)
                    vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
                }
                else {
                    // bitwise flags
                    const flagNames = Object.keys(PatchFlagNames)
                        .map(Number)
                        .filter(n => n > 0 && patchFlag & n)
                        .map(n => PatchFlagNames[n])
                        .join(`, `);
                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                }
            }
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    // 1. dynamic component
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, 'is');
    if (isProp) {
        if (isExplicitDynamic ||
            (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {
            const exp = isProp.type === 6 /* NodeTypes.ATTRIBUTE */
                ? isProp.value && createSimpleExpression(isProp.value.content, true)
                : isProp.exp;
            if (exp) {
                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                    exp
                ]);
            }
        }
        else if (isProp.type === 6 /* NodeTypes.ATTRIBUTE */ &&
            isProp.value.content.startsWith('vue:')) {
            // <button is="vue:xxx">
            // if not <component>, only is value that starts with "vue:" will be
            // treated as component by the parse phase and reach here, unless it's
            // compat mode where all is values are considered components
            tag = isProp.value.content.slice(4);
        }
    }
    // 1.5 v-is (TODO: Deprecate)
    const isDir = !isExplicitDynamic && findDir(node, 'is');
    if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
        ]);
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // so we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 5. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const pushMergeArg = (arg) => {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
        }
        if (arg)
            mergeArgs.push(arg);
    };
    const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = isOn(name);
            if (isEventHandler &&
                (!isComponent || isDynamicComponent) &&
                // omit the flag for click handlers because hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue' &&
                // omit onVnodeXXX hooks
                !isReservedProp(name)) {
                hasHydrationEventBinding = true;
            }
            if (isEventHandler && isReservedProp(name)) {
                hasVnodeHook = true;
            }
            if (value.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) &&
                    getConstantType(value, context) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class') {
                hasClassBinding = true;
            }
            else if (name === 'style') {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
            // treat the dynamic class and style binding of the component as dynamic props
            if (isComponent &&
                (name === 'class' || name === 'style') &&
                !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* NodeTypes.ATTRIBUTE */) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === 'ref') {
                hasRef = true;
                if (context.scopes.vFor > 0) {
                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                }
            }
            // skip is on <component>, or is="vue:xxx"
            if (name === 'is' &&
                (isComponentTag(tag) ||
                    (value && value.content.startsWith('vue:')) ||
                    (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context)))) {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isVBind = name === 'bind';
            const isVOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once/v-memo - they are handled by dedicated transforms.
            if (name === 'once' || name === 'memo') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isVBind &&
                    isStaticArgOf(arg, 'is') &&
                    (isComponentTag(tag) ||
                        (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isVOn && ssr) {
                continue;
            }
            if (
            // #938: elements with dynamic keys should be forced into blocks
            (isVBind && isStaticArgOf(arg, 'key')) ||
                // inline before-update hooks need to force block so that it is invoked
                // before children
                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isVBind || isVOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (isVBind) {
                        // have to merge early for compat build check
                        pushMergeArg();
                        {
                            // 2.x v-bind object order compat
                            {
                                const hasOverridableKeys = mergeArgs.some(arg => {
                                    if (arg.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
                                        return arg.properties.some(({ key }) => {
                                            if (key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                                                !key.isStatic) {
                                                return true;
                                            }
                                            return (key.content !== 'class' &&
                                                key.content !== 'style' &&
                                                !isOn(key.content));
                                        });
                                    }
                                    else {
                                        // dynamic expression
                                        return true;
                                    }
                                });
                                if (hasOverridableKeys) {
                                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                }
                            }
                            if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                mergeArgs.unshift(exp);
                                continue;
                            }
                        }
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        pushMergeArg({
                            type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: isComponent ? [exp] : [exp, `true`]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isVBind
                        ? 34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */
                        : 35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                if (isVOn && arg && !isStaticExp(arg)) {
                    pushMergeArg(createObjectExpression(props, elementLoc));
                }
                else {
                    properties.push(...props);
                }
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if (isSymbol(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else if (!isBuiltInDirective(name)) {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
                // custom dirs may use beforeUpdate so they need to force blocks
                // to ensure before-update gets called before children update
                if (hasChildren) {
                    shouldUseBlock = true;
                }
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        // close up any not-yet-merged props
        pushMergeArg();
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* PatchFlags.FULL_PROPS */;
    }
    else {
        if (hasClassBinding && !isComponent) {
            patchFlag |= 2 /* PatchFlags.CLASS */;
        }
        if (hasStyleBinding && !isComponent) {
            patchFlag |= 4 /* PatchFlags.STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PatchFlags.PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* PatchFlags.HYDRATE_EVENTS */;
        }
    }
    if (!shouldUseBlock &&
        (patchFlag === 0 || patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) &&
        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* PatchFlags.NEED_PATCH */;
    }
    // pre-normalize props, SSR is skipped for now
    if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
            case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
                // means that there is no v-bind,
                // but still need to deal with dynamic key binding
                let classKeyIndex = -1;
                let styleKeyIndex = -1;
                let hasDynamicKey = false;
                for (let i = 0; i < propsExpression.properties.length; i++) {
                    const key = propsExpression.properties[i].key;
                    if (isStaticExp(key)) {
                        if (key.content === 'class') {
                            classKeyIndex = i;
                        }
                        else if (key.content === 'style') {
                            styleKeyIndex = i;
                        }
                    }
                    else if (!key.isHandlerKey) {
                        hasDynamicKey = true;
                    }
                }
                const classProp = propsExpression.properties[classKeyIndex];
                const styleProp = propsExpression.properties[styleKeyIndex];
                // no dynamic key
                if (!hasDynamicKey) {
                    if (classProp && !isStaticExp(classProp.value)) {
                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                    }
                    if (styleProp &&
                        // the static style is compiled into an object,
                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                        (hasStyleBinding ||
                            (styleProp.value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                                styleProp.value.content.trim()[0] === `[`) ||
                            // v-bind:style and style both exist,
                            // v-bind:style with static literal object
                            styleProp.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */)) {
                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                    }
                }
                else {
                    // dynamic key binding, wrap with `normalizeProps`
                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                }
                break;
            case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
                // mergeProps call, do nothing
                break;
            default:
                // single v-bind
                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                        propsExpression
                    ])
                ]);
                break;
        }
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || isOn(name)) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        // built-in directive with runtime
        dirArgs.push(context.helperString(runtime));
    }
    else {
        {
            // inject statement for resolving directive
            context.helper(RESOLVE_DIRECTIVE);
            context.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}
function isComponentTag(tag) {
    return tag === 'component' || tag === 'Component';
}

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            '{}',
            'undefined',
            'true'
        ];
        let expectedLen = 2;
        if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
        }
        if (children.length) {
            slotArgs[3] = createFunctionExpression([], children, false, false, loc);
            expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
            expectedLen = 5;
        }
        slotArgs.splice(expectedLen); // remove unused arguments
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
            if (p.value) {
                if (p.name === 'name') {
                    slotName = JSON.stringify(p.value.content);
                }
                else {
                    p.name = camelize(p.name);
                    nonNameProps.push(p);
                }
            }
        }
        else {
            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                if (p.exp)
                    slotName = p.exp;
            }
            else {
                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                    p.arg.content = camelize(p.arg.content);
                }
                nonNameProps.push(p);
            }
        }
    }
    if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps, false, false);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn$1 = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            let rawName = arg.content;
            // TODO deprecate @vnodeXXX usage
            if (rawName.startsWith('vue:')) {
                rawName = `vnode-${rawName.slice(4)}`;
            }
            const eventString = node.tagType !== 0 /* ElementTypes.ELEMENT */ ||
                rawName.startsWith('vnode') ||
                !/[A-Z]/.test(rawName)
                ? // for non-element and vnode lifecycle event listeners, auto convert
                    // it to camelCase. See issue #2249
                    toHandlerKey(camelize(rawName))
                : // preserve case for plain element listeners that have uppercase
                    // letters, as these may be custom elements' custom events
                    `on:${rawName}`;
            eventName = createSimpleExpression(eventString, true, arg.loc);
        }
        else {
            // #2388
            eventName = createCompoundExpression([
                `${context.helperString(TO_HANDLER_KEY)}(`,
                arg,
                `)`
            ]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || (shouldCache && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (shouldCache) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    // mark the key as handler for props normalization check
    ret.props.forEach(p => (p.key.isHandlerKey = true));
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
    }
    else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
    }
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = camelize(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    if (!context.inSSR) {
        if (modifiers.includes('prop')) {
            injectPrefix(arg, '.');
        }
        if (modifiers.includes('attr')) {
            injectPrefix(arg, '^');
        }
    }
    if (!exp ||
        (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !exp.content.trim())) {
        context.onError(createCompilerError(34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */, loc));
        return {
            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
        };
    }
    return {
        props: [createObjectProperty(arg, exp)]
    };
};
const injectPrefix = (arg, prefix) => {
    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            arg.content = prefix + arg.content;
        }
        else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
        }
    }
    else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
    }
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* NodeTypes.ROOT */ ||
        node.type === 1 /* NodeTypes.ELEMENT */ ||
        node.type === 11 /* NodeTypes.FOR */ ||
        node.type === 10 /* NodeTypes.IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText$1(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText$1(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = createCompoundExpression([child], child.loc);
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* NodeTypes.ROOT */ ||
                        (node.type === 1 /* NodeTypes.ELEMENT */ &&
                            node.tagType === 0 /* ElementTypes.ELEMENT */ &&
                            // #3756
                            // custom directives can potentially add DOM elements arbitrarily,
                            // we need to avoid setting textContent of the element at runtime
                            // to avoid accidentally overwriting the DOM elements added
                            // by the user through custom directives.
                            !node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                                !context.directiveTransforms[p.name]) &&
                            // in compat mode, <template> tags with no special directives
                            // will be rendered as a fragment so its children must be
                            // converted into vnodes.
                            !(node.tag === 'template'))))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText$1(child) || child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* NodeTypes.TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr &&
                        getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                        callArgs.push(1 /* PatchFlags.TEXT */ +
                            (` /* ${PatchFlagNames[1 /* PatchFlags.TEXT */]} */` ));
                    }
                    children[i] = {
                        type: 12 /* NodeTypes.TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const seen$1 = new WeakSet();
const transformOnce = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ && findDir(node, 'once', true)) {
        if (seen$1.has(node) || context.inVOnce) {
            return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel$1 = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? exp.content : rawExp;
    // im SFC <script setup> inline mode, the exp may have been transformed into
    // _unref(exp)
    const bindingType = context.bindingMetadata[rawExp];
    // check props
    if (bindingType === "props" /* BindingTypes.PROPS */ ||
        bindingType === "props-aliased" /* BindingTypes.PROPS_ALIASED */) {
        context.onError(createCompilerError(44 /* ErrorCodes.X_V_MODEL_ON_PROPS */, exp.loc));
        return createTransformProps();
    }
    const maybeRef = !true  ;
    if (!expString.trim() ||
        (!isMemberExpression(expString) && !maybeRef)) {
        context.onError(createCompilerError(42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? isStaticExp(arg)
            ? `onUpdate:${camelize(arg.content)}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
        assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
        ]);
    }
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? isStaticExp(arg)
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* ConstantTypes.CAN_HOIST */)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context)) {
        return;
    }
    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
        // filter rewrite is applied before expression transform so only
        // simple expressions are possible at this stage
        rewriteFilter(node.content, context);
    }
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((prop) => {
            if (prop.type === 7 /* NodeTypes.DIRECTIVE */ &&
                prop.name !== 'for' &&
                prop.exp) {
                rewriteFilter(prop.exp, context);
            }
        });
    }
};
function rewriteFilter(node, context) {
    if (node.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
        parseFilter(node, context);
    }
    else {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (typeof child !== 'object')
                continue;
            if (child.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                parseFilter(child, context);
            }
            else if (child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                rewriteFilter(node, context);
            }
            else if (child.type === 5 /* NodeTypes.INTERPOLATION */) {
                rewriteFilter(child.content, context);
            }
        }
    }
}
function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters.length) {
        warnDeprecation("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context, node.loc);
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
    }
}
function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf('(');
    if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, 'filter')}(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

const seen = new WeakSet();
const transformMemo = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        const dir = findDir(node, 'memo');
        if (!dir || seen.has(node)) {
            return;
        }
        seen.add(node);
        return () => {
            const codegenNode = node.codegenNode ||
                context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                // non-component sub tree should be turned into a block
                if (node.tagType !== 1 /* ElementTypes.COMPONENT */) {
                    makeBlock(codegenNode, context);
                }
                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                    dir.exp,
                    createFunctionExpression(undefined, codegenNode),
                    `_cache`,
                    String(context.cached++)
                ]);
            }
        };
    }
};

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...([transformFilter] ),
            ...([transformExpression]
                    ),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn$1,
            bind: transformBind,
            model: transformModel$1
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if (options.cacheHandlers) {
        onError(createCompilerError(49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = isString(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, extend({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms
        )
    }));
    return generate(ast, extend({}, options, {
        prefixIdentifiers
    }));
}

const noopDirectiveTransform = () => ({ props: [] });

const V_MODEL_RADIO = Symbol(`vModelRadio` );
const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );
const V_MODEL_TEXT = Symbol(`vModelText` );
const V_MODEL_SELECT = Symbol(`vModelSelect` );
const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );
const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );
const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );
const V_SHOW = Symbol(`vShow` );
const TRANSITION = Symbol(`Transition` );
const TRANSITION_GROUP = Symbol(`TransitionGroup` );
registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
});

/* eslint-disable no-restricted-globals */
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
        decoder = document.createElement('div');
    }
    if (asAttr) {
        decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
        return decoder.children[0].getAttribute('foo');
    }
    else {
        decoder.innerHTML = raw;
        return decoder.textContent;
    }
}

const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
const parserOptions = {
    isVoidTag,
    isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
    isPreTag: tag => tag === 'pre',
    decodeEntities: decodeHtmlBrowser ,
    isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
        }
        else if (isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
        }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
            if (parent.tag === 'annotation-xml') {
                if (tag === 'svg') {
                    return 1 /* DOMNamespaces.SVG */;
                }
                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                    a.name === 'encoding' &&
                    a.value != null &&
                    (a.value.content === 'text/html' ||
                        a.value.content === 'application/xhtml+xml'))) {
                    ns = 0 /* DOMNamespaces.HTML */;
                }
            }
            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                tag !== 'mglyph' &&
                tag !== 'malignmark') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
            if (parent.tag === 'foreignObject' ||
                parent.tag === 'desc' ||
                parent.tag === 'title') {
                ns = 0 /* DOMNamespaces.HTML */;
            }
        }
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'svg') {
                return 1 /* DOMNamespaces.SVG */;
            }
            if (tag === 'math') {
                return 2 /* DOMNamespaces.MATH_ML */;
            }
        }
        return ns;
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
    getTextMode({ tag, ns }) {
        if (ns === 0 /* DOMNamespaces.HTML */) {
            if (tag === 'textarea' || tag === 'title') {
                return 1 /* TextModes.RCDATA */;
            }
            if (isRawTextContainer(tag)) {
                return 2 /* TextModes.RAWTEXT */;
            }
        }
        return 0 /* TextModes.DATA */;
    }
};

// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
const transformStyle = node => {
    if (node.type === 1 /* NodeTypes.ELEMENT */) {
        node.props.forEach((p, i) => {
            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                // replace p with an expression node
                node.props[i] = {
                    type: 7 /* NodeTypes.DIRECTIVE */,
                    name: `bind`,
                    arg: createSimpleExpression(`style`, true, p.loc),
                    exp: parseInlineCSS(p.value.content, p.loc),
                    modifiers: [],
                    loc: p.loc
                };
            }
        });
    }
};
const parseInlineCSS = (cssText, loc) => {
    const normalized = parseStringStyle(cssText);
    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
};

function createDOMCompilerError(code, loc) {
    return createCompilerError(code, loc, DOMErrorMessages );
}
const DOMErrorMessages = {
    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
        ]
    };
};

const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
    }
    if (node.children.length) {
        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
        node.children.length = 0;
    }
    return {
        props: [
            createObjectProperty(createSimpleExpression(`textContent`, true), exp
                ? getConstantType(exp, context) > 0
                    ? exp
                    : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
                : createSimpleExpression('', true))
        ]
    };
};

const transformModel = (dir, node, context) => {
    const baseResult = transformModel$1(dir, node, context);
    // base transform has errors OR component v-model (only need props)
    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
        return baseResult;
    }
    if (dir.arg) {
        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
    }
    function checkDuplicatedValue() {
        const value = findProp(node, 'value');
        if (value) {
            context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
        }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === 'input' ||
        tag === 'textarea' ||
        tag === 'select' ||
        isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === 'input' || isCustomElement) {
            const type = findProp(node, `type`);
            if (type) {
                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                    // :type="foo"
                    directiveToUse = V_MODEL_DYNAMIC;
                }
                else if (type.value) {
                    switch (type.value.content) {
                        case 'radio':
                            directiveToUse = V_MODEL_RADIO;
                            break;
                        case 'checkbox':
                            directiveToUse = V_MODEL_CHECKBOX;
                            break;
                        case 'file':
                            isInvalidType = true;
                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                            break;
                        default:
                            // text type
                            checkDuplicatedValue();
                            break;
                    }
                }
            }
            else if (hasDynamicKeyVBind(node)) {
                // element has bindings with dynamic keys, which can possibly contain
                // "type".
                directiveToUse = V_MODEL_DYNAMIC;
            }
            else {
                // text type
                checkDuplicatedValue();
            }
        }
        else if (tag === 'select') {
            directiveToUse = V_MODEL_SELECT;
        }
        else {
            // textarea
            checkDuplicatedValue();
        }
        // inject runtime directive
        // by returning the helper symbol via needRuntime
        // the import will replaced a resolveDirective call.
        if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
        }
    }
    else {
        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
    }
    // native vmodel doesn't need the `modelValue` props since they are also
    // passed to the runtime as `binding.value`. removing it reduces code size.
    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
        p.key.content === 'modelValue'));
    return baseResult;
};

const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
const isNonKeyModifier = /*#__PURE__*/ makeMap(
// event propagation management
`stop,prevent,self,` +
    // system modifiers + exact
    `ctrl,shift,alt,meta,exact,` +
    // mouse
    `middle`);
// left & right could be mouse or key modifiers based on event type
const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === 'native' &&
            checkCompatEnabled("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
            eventOptionModifiers.push(modifier);
        }
        else if (isEventOptionModifier(modifier)) {
            // eventOptionModifiers: modifiers for addEventListener() options,
            // e.g. .passive & .capture
            eventOptionModifiers.push(modifier);
        }
        else {
            // runtimeModifiers: modifiers that needs runtime guards
            if (maybeKeyModifier(modifier)) {
                if (isStaticExp(key)) {
                    if (isKeyboardEvent(key.content)) {
                        keyModifiers.push(modifier);
                    }
                    else {
                        nonKeyModifiers.push(modifier);
                    }
                }
                else {
                    keyModifiers.push(modifier);
                    nonKeyModifiers.push(modifier);
                }
            }
            else {
                if (isNonKeyModifier(modifier)) {
                    nonKeyModifiers.push(modifier);
                }
                else {
                    keyModifiers.push(modifier);
                }
            }
        }
    }
    return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
    };
};
const transformClick = (key, event) => {
    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
    return isStaticClick
        ? createSimpleExpression(event, true)
        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
            ? createCompoundExpression([
                `(`,
                key,
                `) === "onClick" ? "${event}" : (`,
                key,
                `)`
            ])
            : key;
};
const transformOn = (dir, node, context) => {
    return transformOn$1(dir, node, context, baseResult => {
        const { modifiers } = dir;
        if (!modifiers.length)
            return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        // normalize click.right and click.middle since they don't actually fire
        if (nonKeyModifiers.includes('right')) {
            key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes('middle')) {
            key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                handlerExp,
                JSON.stringify(nonKeyModifiers)
            ]);
        }
        if (keyModifiers.length &&
            // if event name is dynamic, always wrap with keys guard
            (!isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                handlerExp,
                JSON.stringify(keyModifiers)
            ]);
        }
        if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
            key = isStaticExp(key)
                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
            props: [createObjectProperty(key, handlerExp)]
        };
    });
};

const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
    }
    return {
        props: [],
        needRuntime: context.helper(V_SHOW)
    };
};

const transformTransition = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 1 /* ElementTypes.COMPONENT */) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
            return () => {
                if (!node.children.length) {
                    return;
                }
                // warn multiple transition children
                if (hasMultipleChildren(node)) {
                    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {
                        start: node.children[0].loc.start,
                        end: node.children[node.children.length - 1].loc.end,
                        source: ''
                    }));
                }
                // check if it's s single child w/ v-show
                // if yes, inject "persisted: true" to the transition props
                const child = node.children[0];
                if (child.type === 1 /* NodeTypes.ELEMENT */) {
                    for (const p of child.props) {
                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {
                            node.props.push({
                                type: 6 /* NodeTypes.ATTRIBUTE */,
                                name: 'persisted',
                                value: undefined,
                                loc: node.loc
                            });
                        }
                    }
                }
            };
        }
    }
};
function hasMultipleChildren(node) {
    // #1352 filter out potential comment nodes.
    const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&
        !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));
    const child = children[0];
    return (children.length !== 1 ||
        child.type === 11 /* NodeTypes.FOR */ ||
        (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));
}

const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 /* NodeTypes.ELEMENT */ &&
        node.tagType === 0 /* ElementTypes.ELEMENT */ &&
        (node.tag === 'script' || node.tag === 'style')) {
        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
        context.removeNode();
    }
};

const DOMNodeTransforms = [
    transformStyle,
    ...([transformTransition] )
];
const DOMDirectiveTransforms = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel,
    on: transformOn,
    show: transformShow
};
function compile(template, options = {}) {
    return baseCompile(template, extend({}, parserOptions, options, {
        nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...(options.nodeTransforms || [])
        ],
        directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: null 
    }));
}
function parse(template, options = {}) {
    return baseParse(template, extend({}, parserOptions, options));
}

export { BASE_TRANSITION, CAMELIZE, CAPITALIZE, CREATE_BLOCK, CREATE_COMMENT, CREATE_ELEMENT_BLOCK, CREATE_ELEMENT_VNODE, CREATE_SLOTS, CREATE_STATIC, CREATE_TEXT, CREATE_VNODE, DOMDirectiveTransforms, DOMNodeTransforms, FRAGMENT, GUARD_REACTIVE_PROPS, IS_MEMO_SAME, IS_REF, KEEP_ALIVE, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_PROPS, NORMALIZE_STYLE, OPEN_BLOCK, POP_SCOPE_ID, PUSH_SCOPE_ID, RENDER_LIST, RENDER_SLOT, RESOLVE_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_FILTER, SET_BLOCK_TRACKING, SUSPENSE, TELEPORT, TO_DISPLAY_STRING, TO_HANDLERS, TO_HANDLER_KEY, TRANSITION, TRANSITION_GROUP, UNREF, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, WITH_CTX, WITH_DIRECTIVES, WITH_MEMO, advancePositionWithClone, advancePositionWithMutation, assert, baseCompile, baseParse, buildDirectiveArgs, buildProps, buildSlots, checkCompatEnabled, compile, createArrayExpression, createAssignmentExpression, createBlockStatement, createCacheExpression, createCallExpression, createCompilerError, createCompoundExpression, createConditionalExpression, createDOMCompilerError, createForLoopParams, createFunctionExpression, createIfStatement, createInterpolation, createObjectExpression, createObjectProperty, createReturnStatement, createRoot, createSequenceExpression, createSimpleExpression, createStructuralDirectiveTransform, createTemplateLiteral, createTransformContext, createVNodeCall, extractIdentifiers, findDir, findProp, generate, generateCodeFrame, getBaseTransformPreset, getConstantType, getInnerRange, getMemoedVNodeCall, getVNodeBlockHelper, getVNodeHelper, hasDynamicKeyVBind, hasScopeRef, helperNameMap, injectProp, isBuiltInType, isCoreComponent, isFunctionType, isInDestructureAssignment, isMemberExpression, isMemberExpressionBrowser, isMemberExpressionNode, isReferencedIdentifier, isSimpleIdentifier, isSlotOutlet, isStaticArgOf, isStaticExp, isStaticProperty, isStaticPropertyKey, isTemplateNode, isText$1 as isText, isVSlot, locStub, makeBlock, noopDirectiveTransform, parse, parserOptions, processExpression, processFor, processIf, processSlotOutlet, registerRuntimeHelpers, resolveComponentType, stringifyExpression, toValidAssetId, trackSlotScopes, trackVForSlotScopes, transform, transformBind, transformElement, transformExpression, transformModel$1 as transformModel, transformOn$1 as transformOn, transformStyle, traverseNode, walkBlockDeclarations, walkFunctionParams, walkIdentifiers, warnDeprecation };
¼/dist/compiler-dom.global.jsÆ œövar VueCompilerDOM = (function (exports) {
  'use strict';

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  function makeMap(str, expectsLowerCase) {
      const map = Object.create(null);
      const list = str.split(',');
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
  }

  /**
   * dev only flag -> name mapping
   */
  const PatchFlagNames = {
      [1 /* PatchFlags.TEXT */]: `TEXT`,
      [2 /* PatchFlags.CLASS */]: `CLASS`,
      [4 /* PatchFlags.STYLE */]: `STYLE`,
      [8 /* PatchFlags.PROPS */]: `PROPS`,
      [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,
      [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
      [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
      [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
      [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
      [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,
      [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
      [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
      [-1 /* PatchFlags.HOISTED */]: `HOISTED`,
      [-2 /* PatchFlags.BAIL */]: `BAIL`
  };

  /**
   * Dev only
   */
  const slotFlagsText = {
      [1 /* SlotFlags.STABLE */]: 'STABLE',
      [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',
      [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'
  };

  const range = 2;
  function generateCodeFrame(source, start = 0, end = source.length) {
      // Split the content into individual lines but capture the newline sequence
      // that separated each line. This is important because the actual sequence is
      // needed to properly take into account the full line length for offset
      // comparison
      let lines = source.split(/(\r?\n)/);
      // Separate the lines and newline sequences into separate arrays for easier referencing
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
          count +=
              lines[i].length +
                  ((newlineSequences[i] && newlineSequences[i].length) || 0);
          if (count >= start) {
              for (let j = i - range; j <= i + range || end > count; j++) {
                  if (j < 0 || j >= lines.length)
                      continue;
                  const line = j + 1;
                  res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                  const lineLength = lines[j].length;
                  const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                  if (j === i) {
                      // push underline
                      const pad = start - (count - (lineLength + newLineSeqLength));
                      const length = Math.max(1, end > count ? lineLength - pad : end - start);
                      res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                  }
                  else if (j > i) {
                      if (end > count) {
                          const length = Math.max(Math.min(end - count, lineLength), 1);
                          res.push(`   |  ` + '^'.repeat(length));
                      }
                      count += lineLength + newLineSeqLength;
                  }
              }
              break;
          }
      }
      return res.join('\n');
  }

  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*.*?\*\//gs;
  function parseStringStyle(cssText) {
      const ret = {};
      cssText
          .replace(styleCommentRE, '')
          .split(listDelimiterRE)
          .forEach(item => {
          if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
      });
      return ret;
  }

  // These tag configs are shared between compiler-dom and runtime-dom, so they
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
  const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
      'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
      'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
      'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
      'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
      'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
      'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
      'option,output,progress,select,textarea,details,dialog,menu,' +
      'summary,template,blockquote,iframe,tfoot';
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
      'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
      'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
      'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
      'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
      'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
      'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
      'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
      'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
      'text,textPath,title,tspan,unknown,use,view';
  const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

  const EMPTY_OBJ = Object.freeze({})
      ;
  const NOOP = () => { };
  /**
   * Always return false.
   */
  const NO = () => false;
  const onRE = /^on[^a-z]/;
  const isOn = (key) => onRE.test(key);
  const extend = Object.assign;
  const isArray = Array.isArray;
  const isString = (val) => typeof val === 'string';
  const isSymbol = (val) => typeof val === 'symbol';
  const isObject = (val) => val !== null && typeof val === 'object';
  const isReservedProp = /*#__PURE__*/ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ',key,ref,ref_for,ref_key,' +
      'onVnodeBeforeMount,onVnodeMounted,' +
      'onVnodeBeforeUpdate,onVnodeUpdated,' +
      'onVnodeBeforeUnmount,onVnodeUnmounted');
  const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
  const cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return ((str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
      });
  };
  const camelizeRE = /-(\w)/g;
  /**
   * @private
   */
  const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
  });
  const hyphenateRE = /\B([A-Z])/g;
  /**
   * @private
   */
  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
  /**
   * @private
   */
  const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  /**
   * @private
   */
  const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);

  function defaultOnError(error) {
      throw error;
  }
  function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``)
          ;
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
  }
  const errorMessages = {
      // parse errors
      [0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
      [1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
      [2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
      [3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
      [4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
      [5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
      [6 /* ErrorCodes.EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
      [7 /* ErrorCodes.EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
      [8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
      [9 /* ErrorCodes.EOF_IN_TAG */]: 'Unexpected EOF in tag.',
      [10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
      [11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
      [12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
      [14 /* ErrorCodes.MISSING_END_TAG_NAME */]: 'End tag name was expected.',
      [15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
      [16 /* ErrorCodes.NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
      [17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
      [18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
      [19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
      [21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
      [20 /* ErrorCodes.UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
      [22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23 /* ErrorCodes.X_INVALID_END_TAG */]: 'Invalid end tag.',
      [24 /* ErrorCodes.X_MISSING_END_TAG */]: 'Element is missing end tag.',
      [25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
      [27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
          'Note that dynamic directive argument cannot contain spaces.',
      [26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
      // transform errors
      [28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
      [29 /* ErrorCodes.X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
      [30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
      [32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
      [33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
      [34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
      [35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
      [36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
      [37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>. ` +
          `When there are multiple named slots, all slots should use <template> ` +
          `syntax to avoid scope ambiguity.`,
      [38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
      [39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
          `default slot. These children will be ignored.`,
      [40 /* ErrorCodes.X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
      [41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
      [42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
      [43 /* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44 /* ErrorCodes.X_V_MODEL_ON_PROPS */]: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45 /* ErrorCodes.X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
      [46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
      // generic errors
      [47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
      [49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [51 /* ErrorCodes.__EXTEND_POINT__ */]: ``
  };

  const FRAGMENT = Symbol(`Fragment` );
  const TELEPORT = Symbol(`Teleport` );
  const SUSPENSE = Symbol(`Suspense` );
  const KEEP_ALIVE = Symbol(`KeepAlive` );
  const BASE_TRANSITION = Symbol(`BaseTransition` );
  const OPEN_BLOCK = Symbol(`openBlock` );
  const CREATE_BLOCK = Symbol(`createBlock` );
  const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock` );
  const CREATE_VNODE = Symbol(`createVNode` );
  const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode` );
  const CREATE_COMMENT = Symbol(`createCommentVNode` );
  const CREATE_TEXT = Symbol(`createTextVNode` );
  const CREATE_STATIC = Symbol(`createStaticVNode` );
  const RESOLVE_COMPONENT = Symbol(`resolveComponent` );
  const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent` );
  const RESOLVE_DIRECTIVE = Symbol(`resolveDirective` );
  const RESOLVE_FILTER = Symbol(`resolveFilter` );
  const WITH_DIRECTIVES = Symbol(`withDirectives` );
  const RENDER_LIST = Symbol(`renderList` );
  const RENDER_SLOT = Symbol(`renderSlot` );
  const CREATE_SLOTS = Symbol(`createSlots` );
  const TO_DISPLAY_STRING = Symbol(`toDisplayString` );
  const MERGE_PROPS = Symbol(`mergeProps` );
  const NORMALIZE_CLASS = Symbol(`normalizeClass` );
  const NORMALIZE_STYLE = Symbol(`normalizeStyle` );
  const NORMALIZE_PROPS = Symbol(`normalizeProps` );
  const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps` );
  const TO_HANDLERS = Symbol(`toHandlers` );
  const CAMELIZE = Symbol(`camelize` );
  const CAPITALIZE = Symbol(`capitalize` );
  const TO_HANDLER_KEY = Symbol(`toHandlerKey` );
  const SET_BLOCK_TRACKING = Symbol(`setBlockTracking` );
  const PUSH_SCOPE_ID = Symbol(`pushScopeId` );
  const POP_SCOPE_ID = Symbol(`popScopeId` );
  const WITH_CTX = Symbol(`withCtx` );
  const UNREF = Symbol(`unref` );
  const IS_REF = Symbol(`isRef` );
  const WITH_MEMO = Symbol(`withMemo` );
  const IS_MEMO_SAME = Symbol(`isMemoSame` );
  // Name mapping for runtime helpers that need to be imported from 'vue' in
  // generated code. Make sure these are correctly exported in the runtime!
  const helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach(s => {
          helperNameMap[s] = helpers[s];
      });
  }

  // AST Utilities ---------------------------------------------------------------
  // Some expressions, e.g. sequence and conditional expressions, are never
  // associated with template nodes, so their source locations are just a stub.
  // Container types like CompoundExpression also don't need a real location.
  const locStub = {
      source: '',
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
  };
  function createRoot(children, loc = locStub) {
      return {
          type: 0 /* NodeTypes.ROOT */,
          children,
          helpers: new Set(),
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: undefined,
          loc
      };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
      if (context) {
          if (isBlock) {
              context.helper(OPEN_BLOCK);
              context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
          }
          else {
              context.helper(getVNodeHelper(context.inSSR, isComponent));
          }
          if (directives) {
              context.helper(WITH_DIRECTIVES);
          }
      }
      return {
          type: 13 /* NodeTypes.VNODE_CALL */,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          isComponent,
          loc
      };
  }
  function createArrayExpression(elements, loc = locStub) {
      return {
          type: 17 /* NodeTypes.JS_ARRAY_EXPRESSION */,
          loc,
          elements
      };
  }
  function createObjectExpression(properties, loc = locStub) {
      return {
          type: 15 /* NodeTypes.JS_OBJECT_EXPRESSION */,
          loc,
          properties
      };
  }
  function createObjectProperty(key, value) {
      return {
          type: 16 /* NodeTypes.JS_PROPERTY */,
          loc: locStub,
          key: isString(key) ? createSimpleExpression(key, true) : key,
          value
      };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* ConstantTypes.NOT_CONSTANT */) {
      return {
          type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : constType
      };
  }
  function createInterpolation(content, loc) {
      return {
          type: 5 /* NodeTypes.INTERPOLATION */,
          loc,
          content: isString(content)
              ? createSimpleExpression(content, false, loc)
              : content
      };
  }
  function createCompoundExpression(children, loc = locStub) {
      return {
          type: 8 /* NodeTypes.COMPOUND_EXPRESSION */,
          loc,
          children
      };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
      return {
          type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
          loc,
          callee,
          arguments: args
      };
  }
  function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
      return {
          type: 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */,
          params,
          returns,
          newline,
          isSlot,
          loc
      };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
          type: 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */,
          test,
          consequent,
          alternate,
          newline,
          loc: locStub
      };
  }
  function createCacheExpression(index, value, isVNode = false) {
      return {
          type: 20 /* NodeTypes.JS_CACHE_EXPRESSION */,
          index,
          value,
          isVNode,
          loc: locStub
      };
  }
  function createBlockStatement(body) {
      return {
          type: 21 /* NodeTypes.JS_BLOCK_STATEMENT */,
          body,
          loc: locStub
      };
  }
  function createTemplateLiteral(elements) {
      return {
          type: 22 /* NodeTypes.JS_TEMPLATE_LITERAL */,
          elements,
          loc: locStub
      };
  }
  function createIfStatement(test, consequent, alternate) {
      return {
          type: 23 /* NodeTypes.JS_IF_STATEMENT */,
          test,
          consequent,
          alternate,
          loc: locStub
      };
  }
  function createAssignmentExpression(left, right) {
      return {
          type: 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */,
          left,
          right,
          loc: locStub
      };
  }
  function createSequenceExpression(expressions) {
      return {
          type: 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */,
          expressions,
          loc: locStub
      };
  }
  function createReturnStatement(returns) {
      return {
          type: 26 /* NodeTypes.JS_RETURN_STATEMENT */,
          returns,
          loc: locStub
      };
  }

  const isStaticExp = (p) => p.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.isStatic;
  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
  function isCoreComponent(tag) {
      if (isBuiltInType(tag, 'Teleport')) {
          return TELEPORT;
      }
      else if (isBuiltInType(tag, 'Suspense')) {
          return SUSPENSE;
      }
      else if (isBuiltInType(tag, 'KeepAlive')) {
          return KEEP_ALIVE;
      }
      else if (isBuiltInType(tag, 'BaseTransition')) {
          return BASE_TRANSITION;
      }
  }
  const nonIdentifierRE = /^\d|[^\$\w]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  /**
   * Simple lexer to check if an expression is a member expression. This is
   * lax and only checks validity at the root level (i.e. does not validate exps
   * inside square brackets), but it's ok since these are only used on template
   * expressions and false positives are invalid expressions in the first place.
   */
  const isMemberExpressionBrowser = (path) => {
      // remove whitespaces around . or [ first
      path = path.trim().replace(whitespaceRE, s => s.trim());
      let state = 0 /* MemberExpLexState.inMemberExp */;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
          const char = path.charAt(i);
          switch (state) {
              case 0 /* MemberExpLexState.inMemberExp */:
                  if (char === '[') {
                      stateStack.push(state);
                      state = 1 /* MemberExpLexState.inBrackets */;
                      currentOpenBracketCount++;
                  }
                  else if (char === '(') {
                      stateStack.push(state);
                      state = 2 /* MemberExpLexState.inParens */;
                      currentOpenParensCount++;
                  }
                  else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                      return false;
                  }
                  break;
              case 1 /* MemberExpLexState.inBrackets */:
                  if (char === `'` || char === `"` || char === '`') {
                      stateStack.push(state);
                      state = 3 /* MemberExpLexState.inString */;
                      currentStringType = char;
                  }
                  else if (char === `[`) {
                      currentOpenBracketCount++;
                  }
                  else if (char === `]`) {
                      if (!--currentOpenBracketCount) {
                          state = stateStack.pop();
                      }
                  }
                  break;
              case 2 /* MemberExpLexState.inParens */:
                  if (char === `'` || char === `"` || char === '`') {
                      stateStack.push(state);
                      state = 3 /* MemberExpLexState.inString */;
                      currentStringType = char;
                  }
                  else if (char === `(`) {
                      currentOpenParensCount++;
                  }
                  else if (char === `)`) {
                      // if the exp ends as a call then it should not be considered valid
                      if (i === path.length - 1) {
                          return false;
                      }
                      if (!--currentOpenParensCount) {
                          state = stateStack.pop();
                      }
                  }
                  break;
              case 3 /* MemberExpLexState.inString */:
                  if (char === currentStringType) {
                      state = stateStack.pop();
                      currentStringType = null;
                  }
                  break;
          }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
  };
  const isMemberExpressionNode = NOOP
      ;
  const isMemberExpression = isMemberExpressionBrowser
      ;
  function getInnerRange(loc, offset, length) {
      const source = loc.source.slice(offset, offset + length);
      const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
      };
      if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
          }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column =
          lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
      return pos;
  }
  function assert(condition, msg) {
      /* istanbul ignore if */
      if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
      }
  }
  function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
              (allowEmpty || p.exp) &&
              (isString(name) ? p.name === name : name.test(p.name))) {
              return p;
          }
      }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
              if (dynamicOnly)
                  continue;
              if (p.name === name && (p.value || allowEmpty)) {
                  return p;
              }
          }
          else if (p.name === 'bind' &&
              (p.exp || allowEmpty) &&
              isStaticArgOf(p.arg, name)) {
              return p;
          }
      }
  }
  function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
      return node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
          p.name === 'bind' &&
          (!p.arg || // v-bind="obj"
              p.arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
              !p.arg.isStatic) // v-bind:[foo]
      );
  }
  function isText$1(node) {
      return node.type === 5 /* NodeTypes.INTERPOLATION */ || node.type === 2 /* NodeTypes.TEXT */;
  }
  function isVSlot(p) {
      return p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'slot';
  }
  function isTemplateNode(node) {
      return (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 3 /* ElementTypes.TEMPLATE */);
  }
  function isSlotOutlet(node) {
      return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 2 /* ElementTypes.SLOT */;
  }
  function getVNodeHelper(ssr, isComponent) {
      return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent) {
      return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
      if (props &&
          !isString(props) &&
          props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
          const callee = props.callee;
          if (!isString(callee) && propsHelperSet.has(callee)) {
              return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
          }
      }
      return [props, callPath];
  }
  function injectProp(node, prop, context) {
      let propsWithInjection;
      /**
       * 1. mergeProps(...)
       * 2. toHandlers(...)
       * 3. normalizeProps(...)
       * 4. normalizeProps(guardReactiveProps(...))
       *
       * we need to get the real props before normalization
       */
      let props = node.type === 13 /* NodeTypes.VNODE_CALL */ ? node.props : node.arguments[2];
      let callPath = [];
      let parentCall;
      if (props &&
          !isString(props) &&
          props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
          const ret = getUnnormalizedProps(props);
          props = ret[0];
          callPath = ret[1];
          parentCall = callPath[callPath.length - 1];
      }
      if (props == null || isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
      }
      else if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
          // merged props... add ours
          // only inject key to object literal if it's the first argument so that
          // if doesn't override user provided keys
          const first = props.arguments[0];
          if (!isString(first) && first.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
              // #6631
              if (!hasProp(prop, first)) {
                  first.properties.unshift(prop);
              }
          }
          else {
              if (props.callee === TO_HANDLERS) {
                  // #2366
                  propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                      createObjectExpression([prop]),
                      props
                  ]);
              }
              else {
                  props.arguments.unshift(createObjectExpression([prop]));
              }
          }
          !propsWithInjection && (propsWithInjection = props);
      }
      else if (props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
          if (!hasProp(prop, props)) {
              props.properties.unshift(prop);
          }
          propsWithInjection = props;
      }
      else {
          // single v-bind with expression, return a merged replacement
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
          ]);
          // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
          // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
          // the `guardReactiveProps` will no longer be needed
          if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
              parentCall = callPath[callPath.length - 2];
          }
      }
      if (node.type === 13 /* NodeTypes.VNODE_CALL */) {
          if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
          }
          else {
              node.props = propsWithInjection;
          }
      }
      else {
          if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
          }
          else {
              node.arguments[2] = propsWithInjection;
          }
      }
  }
  // check existing key to avoid overriding user provided keys
  function hasProp(prop, props) {
      let result = false;
      if (prop.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          const propKeyName = prop.key.content;
          result = props.properties.some(p => p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
              p.key.content === propKeyName);
      }
      return result;
  }
  function toValidAssetId(name, type) {
      // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
  }
  // Check if a node contains expressions that reference current context scope ids
  function hasScopeRef(node, ids) {
      if (!node || Object.keys(ids).length === 0) {
          return false;
      }
      switch (node.type) {
          case 1 /* NodeTypes.ELEMENT */:
              for (let i = 0; i < node.props.length; i++) {
                  const p = node.props[i];
                  if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                      (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                      return true;
                  }
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 11 /* NodeTypes.FOR */:
              if (hasScopeRef(node.source, ids)) {
                  return true;
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 9 /* NodeTypes.IF */:
              return node.branches.some(b => hasScopeRef(b, ids));
          case 10 /* NodeTypes.IF_BRANCH */:
              if (hasScopeRef(node.condition, ids)) {
                  return true;
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
              return (!node.isStatic &&
                  isSimpleIdentifier(node.content) &&
                  !!ids[node.content]);
          case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
              return node.children.some(c => isObject(c) && hasScopeRef(c, ids));
          case 5 /* NodeTypes.INTERPOLATION */:
          case 12 /* NodeTypes.TEXT_CALL */:
              return hasScopeRef(node.content, ids);
          case 2 /* NodeTypes.TEXT */:
          case 3 /* NodeTypes.COMMENT */:
              return false;
          default:
              return false;
      }
  }
  function getMemoedVNodeCall(node) {
      if (node.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
          return node.arguments[1].returns;
      }
      else {
          return node;
      }
  }
  function makeBlock(node, { helper, removeHelper, inSSR }) {
      if (!node.isBlock) {
          node.isBlock = true;
          removeHelper(getVNodeHelper(inSSR, node.isComponent));
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(inSSR, node.isComponent));
      }
  }

  const deprecationData = {
      ["COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */]: {
          message: `Platform-native elements with "is" prop will no longer be ` +
              `treated as components in Vue 3 unless the "is" value is explicitly ` +
              `prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */]: {
          message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
              `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
              `\`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
              `Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
              `object spread: it will now overwrite an existing non-mergeable attribute ` +
              `that appears before v-bind in the case of conflict. ` +
              `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
              `You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
          message: `v-if / v-for precedence when used on the same element has changed ` +
              `in Vue 3: v-if now takes higher precedence and will no longer have ` +
              `access to v-for scope variables. It is best to avoid the ambiguity ` +
              `with <template> tags or use a computed property that filters v-for ` +
              `data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */]: {
          message: `<template> with no special directives will render as a native template ` +
              `element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */]: {
          message: `filters have been removed in Vue 3. ` +
              `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
              `Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
  };
  function getCompatValue(key, context) {
      const config = context.options
          ? context.options.compatConfig
          : context.compatConfig;
      const value = config && config[key];
      if (key === 'MODE') {
          return value || 3; // compiler defaults to v3 behavior
      }
      else {
          return value;
      }
  }
  function isCompatEnabled(key, context) {
      const mode = getCompatValue('MODE', context);
      const value = getCompatValue(key, context);
      // in v3 mode, only enable if explicitly set to true
      // otherwise enable for any non-false value
      return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      if (enabled) {
          warnDeprecation(key, context, loc, ...args);
      }
      return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === 'suppress-warning') {
          return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
          err.loc = loc;
      context.onWarn(err);
  }

  // The default decoder only provides escapes for characters reserved as part of
  // the template syntax, and is only used if the custom renderer did not provide
  // a platform-specific decoder.
  const decodeRE = /&(gt|lt|amp|apos|quot);/g;
  const decodeMap = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  };
  const defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0 /* Namespaces.HTML */,
      getTextMode: () => 0 /* TextModes.DATA */,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
  };
  function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0 /* TextModes.DATA */, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
      const options = extend({}, defaultParserOptions);
      let key;
      for (key in rawOptions) {
          // @ts-ignore
          options[key] =
              rawOptions[key] === undefined
                  ? defaultParserOptions[key]
                  : rawOptions[key];
      }
      return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false,
          onWarn: options.onWarn
      };
  }
  function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0 /* Namespaces.HTML */;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node = undefined;
          if (mode === 0 /* TextModes.DATA */ || mode === 1 /* TextModes.RCDATA */) {
              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                  // '{{'
                  node = parseInterpolation(context, mode);
              }
              else if (mode === 0 /* TextModes.DATA */ && s[0] === '<') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                  if (s.length === 1) {
                      emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 1);
                  }
                  else if (s[1] === '!') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                      if (startsWith(s, '<!--')) {
                          node = parseComment(context);
                      }
                      else if (startsWith(s, '<!DOCTYPE')) {
                          // Ignore DOCTYPE by a limitation.
                          node = parseBogusComment(context);
                      }
                      else if (startsWith(s, '<![CDATA[')) {
                          if (ns !== 0 /* Namespaces.HTML */) {
                              node = parseCDATA(context, ancestors);
                          }
                          else {
                              emitError(context, 1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */);
                              node = parseBogusComment(context);
                          }
                      }
                      else {
                          emitError(context, 11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (s[1] === '/') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                      if (s.length === 2) {
                          emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 2);
                      }
                      else if (s[2] === '>') {
                          emitError(context, 14 /* ErrorCodes.MISSING_END_TAG_NAME */, 2);
                          advanceBy(context, 3);
                          continue;
                      }
                      else if (/[a-z]/i.test(s[2])) {
                          emitError(context, 23 /* ErrorCodes.X_INVALID_END_TAG */);
                          parseTag(context, 1 /* TagType.End */, parent);
                          continue;
                      }
                      else {
                          emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (/[a-z]/i.test(s[1])) {
                      node = parseElement(context, ancestors);
                      // 2.x <template> with no directive compat
                      if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context) &&
                          node &&
                          node.tag === 'template' &&
                          !node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                              isSpecialTemplateDirective(p.name))) {
                          warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                          node = node.children;
                      }
                  }
                  else if (s[1] === '?') {
                      emitError(context, 21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                      node = parseBogusComment(context);
                  }
                  else {
                      emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                  }
              }
          }
          if (!node) {
              node = parseText(context, mode);
          }
          if (isArray(node)) {
              for (let i = 0; i < node.length; i++) {
                  pushNode(nodes, node[i]);
              }
          }
          else {
              pushNode(nodes, node);
          }
      }
      // Whitespace handling strategy like v2
      let removedWhitespace = false;
      if (mode !== 2 /* TextModes.RAWTEXT */ && mode !== 1 /* TextModes.RCDATA */) {
          const shouldCondense = context.options.whitespace !== 'preserve';
          for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (node.type === 2 /* NodeTypes.TEXT */) {
                  if (!context.inPre) {
                      if (!/[^\t\r\n\f ]/.test(node.content)) {
                          const prev = nodes[i - 1];
                          const next = nodes[i + 1];
                          // Remove if:
                          // - the whitespace is the first or last node, or:
                          // - (condense mode) the whitespace is between twos comments, or:
                          // - (condense mode) the whitespace is between comment and element, or:
                          // - (condense mode) the whitespace is between two elements AND contains newline
                          if (!prev ||
                              !next ||
                              (shouldCondense &&
                                  ((prev.type === 3 /* NodeTypes.COMMENT */ &&
                                      next.type === 3 /* NodeTypes.COMMENT */) ||
                                      (prev.type === 3 /* NodeTypes.COMMENT */ &&
                                          next.type === 1 /* NodeTypes.ELEMENT */) ||
                                      (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                          next.type === 3 /* NodeTypes.COMMENT */) ||
                                      (prev.type === 1 /* NodeTypes.ELEMENT */ &&
                                          next.type === 1 /* NodeTypes.ELEMENT */ &&
                                          /[\r\n]/.test(node.content))))) {
                              removedWhitespace = true;
                              nodes[i] = null;
                          }
                          else {
                              // Otherwise, the whitespace is condensed into a single space
                              node.content = ' ';
                          }
                      }
                      else if (shouldCondense) {
                          // in condense mode, consecutive whitespaces in text are condensed
                          // down to a single space.
                          node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                      }
                  }
                  else {
                      // #6410 normalize windows newlines in <pre>:
                      // in SSR, browsers normalize server-rendered \r\n into a single \n
                      // in the DOM
                      node.content = node.content.replace(/\r\n/g, '\n');
                  }
              }
              // Remove comment nodes if desired by configuration.
              else if (node.type === 3 /* NodeTypes.COMMENT */ && !context.options.comments) {
                  removedWhitespace = true;
                  nodes[i] = null;
              }
          }
          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
              // remove leading newline per html spec
              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
              const first = nodes[0];
              if (first && first.type === 2 /* NodeTypes.TEXT */) {
                  first.content = first.content.replace(/^\r?\n/, '');
              }
          }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
      if (node.type === 2 /* NodeTypes.TEXT */) {
          const prev = last(nodes);
          // Merge if both this and the previous node are text and those are
          // consecutive. This happens for cases like "a < b".
          if (prev &&
              prev.type === 2 /* NodeTypes.TEXT */ &&
              prev.loc.end.offset === node.loc.start.offset) {
              prev.content += node.content;
              prev.loc.end = node.loc.end;
              prev.loc.source += node.loc.source;
              return;
          }
      }
      nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3 /* TextModes.CDATA */, ancestors);
      if (context.source.length === 0) {
          emitError(context, 6 /* ErrorCodes.EOF_IN_CDATA */);
      }
      else {
          advanceBy(context, 3);
      }
      return nodes;
  }
  function parseComment(context) {
      const start = getCursor(context);
      let content;
      // Regular comment.
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(context, 7 /* ErrorCodes.EOF_IN_COMMENT */);
      }
      else {
          if (match.index <= 3) {
              emitError(context, 0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
          }
          if (match[1]) {
              emitError(context, 10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */);
          }
          content = context.source.slice(4, match.index);
          // Advancing with reporting nested comments.
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
              advanceBy(context, nestedIndex - prevIndex + 1);
              if (nestedIndex + 4 < s.length) {
                  emitError(context, 16 /* ErrorCodes.NESTED_COMMENT */);
              }
              prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
          type: 3 /* NodeTypes.COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === '?' ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf('>');
      if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
      }
      else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
      }
      return {
          type: 3 /* NodeTypes.COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseElement(context, ancestors) {
      // Start tag.
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0 /* TagType.Start */, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          // #4030 self-closing <pre> tag
          if (isPreBoundary) {
              context.inPre = false;
          }
          if (isVPreBoundary) {
              context.inVPre = false;
          }
          return element;
      }
      // Children.
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      // 2.x inline-template compat
      {
          const inlineTemplateProp = element.props.find(p => p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'inline-template');
          if (inlineTemplateProp &&
              checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
              const loc = getSelection(context, element.loc.end);
              inlineTemplateProp.value = {
                  type: 2 /* NodeTypes.TEXT */,
                  content: loc.source,
                  loc
              };
          }
      }
      element.children = children;
      // End tag.
      if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, 1 /* TagType.End */, parent);
      }
      else {
          emitError(context, 24 /* ErrorCodes.X_MISSING_END_TAG */, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
              const first = children[0];
              if (first && startsWith(first.loc.source, '<!--')) {
                  emitError(context, 8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
              }
          }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
          context.inPre = false;
      }
      if (isVPreBoundary) {
          context.inVPre = false;
      }
      return element;
  }
  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
  function parseTag(context, type, parent) {
      // Tag open.
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      // save current state in case we need to re-parse attributes with v-pre
      const cursor = getCursor(context);
      const currentSource = context.source;
      // check <pre> tag
      if (context.options.isPreTag(tag)) {
          context.inPre = true;
      }
      // Attributes.
      let props = parseAttributes(context, type);
      // check v-pre
      if (type === 0 /* TagType.Start */ &&
          !context.inVPre &&
          props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'pre')) {
          context.inVPre = true;
          // reset context
          extend(context, cursor);
          context.source = currentSource;
          // re-parse attrs and filter out v-pre itself
          props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
      }
      // Tag close.
      let isSelfClosing = false;
      if (context.source.length === 0) {
          emitError(context, 9 /* ErrorCodes.EOF_IN_TAG */);
      }
      else {
          isSelfClosing = startsWith(context.source, '/>');
          if (type === 1 /* TagType.End */ && isSelfClosing) {
              emitError(context, 4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */);
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
      }
      if (type === 1 /* TagType.End */) {
          return;
      }
      // 2.x deprecation checks
      if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
          let hasIf = false;
          let hasFor = false;
          for (let i = 0; i < props.length; i++) {
              const p = props[i];
              if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                  if (p.name === 'if') {
                      hasIf = true;
                  }
                  else if (p.name === 'for') {
                      hasFor = true;
                  }
              }
              if (hasIf && hasFor) {
                  warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
                  break;
              }
          }
      }
      let tagType = 0 /* ElementTypes.ELEMENT */;
      if (!context.inVPre) {
          if (tag === 'slot') {
              tagType = 2 /* ElementTypes.SLOT */;
          }
          else if (tag === 'template') {
              if (props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                  tagType = 3 /* ElementTypes.TEMPLATE */;
              }
          }
          else if (isComponent(tag, props, context)) {
              tagType = 1 /* ElementTypes.COMPONENT */;
          }
      }
      return {
          type: 1 /* NodeTypes.ELEMENT */,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      };
  }
  function isComponent(tag, props, context) {
      const options = context.options;
      if (options.isCustomElement(tag)) {
          return false;
      }
      if (tag === 'component' ||
          /^[A-Z]/.test(tag) ||
          isCoreComponent(tag) ||
          (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
          (options.isNativeTag && !options.isNativeTag(tag))) {
          return true;
      }
      // at this point the tag should be a native tag, but check for potential "is"
      // casting
      for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
              if (p.name === 'is' && p.value) {
                  if (p.value.content.startsWith('vue:')) {
                      return true;
                  }
                  else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                      return true;
                  }
              }
          }
          else {
              // directive
              // v-is (TODO Deprecate)
              if (p.name === 'is') {
                  return true;
              }
              else if (
              // :is on plain element - only treat as component in compat mode
              p.name === 'bind' &&
                  isStaticArgOf(p.arg, 'is') &&
                  true &&
                  checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                  return true;
              }
          }
      }
  }
  function parseAttributes(context, type) {
      const props = [];
      const attributeNames = new Set();
      while (context.source.length > 0 &&
          !startsWith(context.source, '>') &&
          !startsWith(context.source, '/>')) {
          if (startsWith(context.source, '/')) {
              emitError(context, 22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */);
              advanceBy(context, 1);
              advanceSpaces(context);
              continue;
          }
          if (type === 1 /* TagType.End */) {
              emitError(context, 3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */);
          }
          const attr = parseAttribute(context, attributeNames);
          // Trim whitespace between class
          // https://github.com/vuejs/core/issues/4251
          if (attr.type === 6 /* NodeTypes.ATTRIBUTE */ &&
              attr.value &&
              attr.name === 'class') {
              attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
          }
          if (type === 0 /* TagType.Start */) {
              props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
              emitError(context, 15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
          }
          advanceSpaces(context);
      }
      return props;
  }
  function parseAttribute(context, nameSet) {
      // Name.
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
          emitError(context, 2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */);
      }
      nameSet.add(name);
      if (name[0] === '=') {
          emitError(context, 19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
      }
      {
          const pattern = /["'<]/g;
          let m;
          while ((m = pattern.exec(name))) {
              emitError(context, 17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
          }
      }
      advanceBy(context, name.length);
      // Value
      let value = undefined;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
              emitError(context, 13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */);
          }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
          let isPropShorthand = startsWith(name, '.');
          let dirName = match[1] ||
              (isPropShorthand || startsWith(name, ':')
                  ? 'bind'
                  : startsWith(name, '@')
                      ? 'on'
                      : 'slot');
          let arg;
          if (match[2]) {
              const isSlot = dirName === 'slot';
              const startOffset = name.lastIndexOf(match[2]);
              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
              let content = match[2];
              let isStatic = true;
              if (content.startsWith('[')) {
                  isStatic = false;
                  if (!content.endsWith(']')) {
                      emitError(context, 27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                      content = content.slice(1);
                  }
                  else {
                      content = content.slice(1, content.length - 1);
                  }
              }
              else if (isSlot) {
                  // #1241 special case for v-slot: vuetify relies extensively on slot
                  // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                  // supports such usage so we are keeping it consistent with 2.x.
                  content += match[3] || '';
              }
              arg = {
                  type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                  content,
                  isStatic,
                  constType: isStatic
                      ? 3 /* ConstantTypes.CAN_STRINGIFY */
                      : 0 /* ConstantTypes.NOT_CONSTANT */,
                  loc
              };
          }
          if (value && value.isQuoted) {
              const valueLoc = value.loc;
              valueLoc.start.offset++;
              valueLoc.start.column++;
              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
              valueLoc.source = valueLoc.source.slice(1, -1);
          }
          const modifiers = match[3] ? match[3].slice(1).split('.') : [];
          if (isPropShorthand)
              modifiers.push('prop');
          // 2.x compat v-bind:foo.sync -> v-model:foo
          if (dirName === 'bind' && arg) {
              if (modifiers.includes('sync') &&
                  checkCompatEnabled("COMPILER_V_BIND_SYNC" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                  dirName = 'model';
                  modifiers.splice(modifiers.indexOf('sync'), 1);
              }
              if (modifiers.includes('prop')) {
                  checkCompatEnabled("COMPILER_V_BIND_PROP" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */, context, loc);
              }
          }
          return {
              type: 7 /* NodeTypes.DIRECTIVE */,
              name: dirName,
              exp: value && {
                  type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
                  content: value.content,
                  isStatic: false,
                  // Treat as non-constant by default. This can be potentially set to
                  // other values by `transformExpression` to make it eligible for hoisting.
                  constType: 0 /* ConstantTypes.NOT_CONSTANT */,
                  loc: value.loc
              },
              arg,
              modifiers,
              loc
          };
      }
      // missing directive name or illegal directive name
      if (!context.inVPre && startsWith(name, 'v-')) {
          emitError(context, 26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */);
      }
      return {
          type: 6 /* NodeTypes.ATTRIBUTE */,
          name,
          value: value && {
              type: 2 /* NodeTypes.TEXT */,
              content: value.content,
              loc: value.loc
          },
          loc
      };
  }
  function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
          // Quoted value.
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
              content = parseTextData(context, context.source.length, 4 /* TextModes.ATTRIBUTE_VALUE */);
          }
          else {
              content = parseTextData(context, endIndex, 4 /* TextModes.ATTRIBUTE_VALUE */);
              advanceBy(context, 1);
          }
      }
      else {
          // Unquoted
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
              return undefined;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while ((m = unexpectedChars.exec(match[0]))) {
              emitError(context, 18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
          }
          content = parseTextData(context, match[0].length, 4 /* TextModes.ATTRIBUTE_VALUE */);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
          emitError(context, 25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */);
          return undefined;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
          type: 5 /* NodeTypes.INTERPOLATION */,
          content: {
              type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,
              isStatic: false,
              // Set `isConstant` to false by default and will decide in transformExpression
              constType: 0 /* ConstantTypes.NOT_CONSTANT */,
              content,
              loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
      };
  }
  function parseText(context, mode) {
      const endTokens = mode === 3 /* TextModes.CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
              endIndex = index;
          }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
          type: 2 /* NodeTypes.TEXT */,
          content,
          loc: getSelection(context, start)
      };
  }
  /**
   * Get text data with a given length from the current location.
   * This translates HTML entities in the text data.
   */
  function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 /* TextModes.RAWTEXT */ ||
          mode === 3 /* TextModes.CDATA */ ||
          !rawText.includes('&')) {
          return rawText;
      }
      else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          return context.options.decodeEntities(rawText, mode === 4 /* TextModes.ATTRIBUTE_VALUE */);
      }
  }
  function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
  }
  function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      };
  }
  function last(xs) {
      return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
      return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
          advanceBy(context, match[0].length);
      }
  }
  function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
          loc.offset += offset;
          loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ''
      }));
  }
  function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
          case 0 /* TextModes.DATA */:
              if (startsWith(s, '</')) {
                  // TODO: probably bad performance
                  for (let i = ancestors.length - 1; i >= 0; --i) {
                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                          return true;
                      }
                  }
              }
              break;
          case 1 /* TextModes.RCDATA */:
          case 2 /* TextModes.RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                  return true;
              }
              break;
          }
          case 3 /* TextModes.CDATA */:
              if (startsWith(s, ']]>')) {
                  return true;
              }
              break;
      }
      return !s;
  }
  function startsWithEndTagOpen(source, tag) {
      return (startsWith(source, '</') &&
          source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
          /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
  }

  function hoistStatic(root, context) {
      walk(root, context, 
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
      const { children } = root;
      return (children.length === 1 &&
          child.type === 1 /* NodeTypes.ELEMENT */ &&
          !isSlotOutlet(child));
  }
  function walk(node, context, doNotHoistNode = false) {
      const { children } = node;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          // only plain elements & text calls are eligible for hoisting.
          if (child.type === 1 /* NodeTypes.ELEMENT */ &&
              child.tagType === 0 /* ElementTypes.ELEMENT */) {
              const constantType = doNotHoistNode
                  ? 0 /* ConstantTypes.NOT_CONSTANT */
                  : getConstantType(child, context);
              if (constantType > 0 /* ConstantTypes.NOT_CONSTANT */) {
                  if (constantType >= 2 /* ConstantTypes.CAN_HOIST */) {
                      child.codegenNode.patchFlag =
                          -1 /* PatchFlags.HOISTED */ + (` /* HOISTED */` );
                      child.codegenNode = context.hoist(child.codegenNode);
                      hoistedCount++;
                      continue;
                  }
              }
              else {
                  // node may contain dynamic children, but its props may be eligible for
                  // hoisting.
                  const codegenNode = child.codegenNode;
                  if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                      const flag = getPatchFlag(codegenNode);
                      if ((!flag ||
                          flag === 512 /* PatchFlags.NEED_PATCH */ ||
                          flag === 1 /* PatchFlags.TEXT */) &&
                          getGeneratedPropsConstantType(child, context) >=
                              2 /* ConstantTypes.CAN_HOIST */) {
                          const props = getNodeProps(child);
                          if (props) {
                              codegenNode.props = context.hoist(props);
                          }
                      }
                      if (codegenNode.dynamicProps) {
                          codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                      }
                  }
              }
          }
          // walk further
          if (child.type === 1 /* NodeTypes.ELEMENT */) {
              const isComponent = child.tagType === 1 /* ElementTypes.COMPONENT */;
              if (isComponent) {
                  context.scopes.vSlot++;
              }
              walk(child, context);
              if (isComponent) {
                  context.scopes.vSlot--;
              }
          }
          else if (child.type === 11 /* NodeTypes.FOR */) {
              // Do not hoist v-for single child because it has to be a block
              walk(child, context, child.children.length === 1);
          }
          else if (child.type === 9 /* NodeTypes.IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                  // Do not hoist v-if single child because it has to be a block
                  walk(child.branches[i], context, child.branches[i].children.length === 1);
              }
          }
      }
      if (hoistedCount && context.transformHoist) {
          context.transformHoist(children, context, node);
      }
      // all children were hoisted - the entire children array is hoistable.
      if (hoistedCount &&
          hoistedCount === originalCount &&
          node.type === 1 /* NodeTypes.ELEMENT */ &&
          node.tagType === 0 /* ElementTypes.ELEMENT */ &&
          node.codegenNode &&
          node.codegenNode.type === 13 /* NodeTypes.VNODE_CALL */ &&
          isArray(node.codegenNode.children)) {
          node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
      }
  }
  function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
          case 1 /* NodeTypes.ELEMENT */:
              if (node.tagType !== 0 /* ElementTypes.ELEMENT */) {
                  return 0 /* ConstantTypes.NOT_CONSTANT */;
              }
              const cached = constantCache.get(node);
              if (cached !== undefined) {
                  return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* NodeTypes.VNODE_CALL */) {
                  return 0 /* ConstantTypes.NOT_CONSTANT */;
              }
              if (codegenNode.isBlock &&
                  node.tag !== 'svg' &&
                  node.tag !== 'foreignObject') {
                  return 0 /* ConstantTypes.NOT_CONSTANT */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag) {
                  let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
                  // Element itself has no patch flag. However we still need to check:
                  // 1. Even for a node with no patch flag, it is possible for it to contain
                  // non-hoistable expressions that refers to scope variables, e.g. compiler
                  // injected keys or cached event handlers. Therefore we need to always
                  // check the codegenNode's props to be sure.
                  const generatedPropsType = getGeneratedPropsConstantType(node, context);
                  if (generatedPropsType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                      constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                      return 0 /* ConstantTypes.NOT_CONSTANT */;
                  }
                  if (generatedPropsType < returnType) {
                      returnType = generatedPropsType;
                  }
                  // 2. its children.
                  for (let i = 0; i < node.children.length; i++) {
                      const childType = getConstantType(node.children[i], context);
                      if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                          constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                          return 0 /* ConstantTypes.NOT_CONSTANT */;
                      }
                      if (childType < returnType) {
                          returnType = childType;
                      }
                  }
                  // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                  // type, check if any of the props can cause the type to be lowered
                  // we can skip can_patch because it's guaranteed by the absence of a
                  // patchFlag.
                  if (returnType > 1 /* ConstantTypes.CAN_SKIP_PATCH */) {
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && p.exp) {
                              const expType = getConstantType(p.exp, context);
                              if (expType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                                  constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                                  return 0 /* ConstantTypes.NOT_CONSTANT */;
                              }
                              if (expType < returnType) {
                                  returnType = expType;
                              }
                          }
                      }
                  }
                  // only svg/foreignObject could be block here, however if they are
                  // static then they don't need to be blocks since there will be no
                  // nested updates.
                  if (codegenNode.isBlock) {
                      // except set custom directives.
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* NodeTypes.DIRECTIVE */) {
                              constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                              return 0 /* ConstantTypes.NOT_CONSTANT */;
                          }
                      }
                      context.removeHelper(OPEN_BLOCK);
                      context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                      codegenNode.isBlock = false;
                      context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                  }
                  constantCache.set(node, returnType);
                  return returnType;
              }
              else {
                  constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);
                  return 0 /* ConstantTypes.NOT_CONSTANT */;
              }
          case 2 /* NodeTypes.TEXT */:
          case 3 /* NodeTypes.COMMENT */:
              return 3 /* ConstantTypes.CAN_STRINGIFY */;
          case 9 /* NodeTypes.IF */:
          case 11 /* NodeTypes.FOR */:
          case 10 /* NodeTypes.IF_BRANCH */:
              return 0 /* ConstantTypes.NOT_CONSTANT */;
          case 5 /* NodeTypes.INTERPOLATION */:
          case 12 /* NodeTypes.TEXT_CALL */:
              return getConstantType(node.content, context);
          case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
              return node.constType;
          case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
              let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  if (isString(child) || isSymbol(child)) {
                      continue;
                  }
                  const childType = getConstantType(child, context);
                  if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                      return 0 /* ConstantTypes.NOT_CONSTANT */;
                  }
                  else if (childType < returnType) {
                      returnType = childType;
                  }
              }
              return returnType;
          default:
              return 0 /* ConstantTypes.NOT_CONSTANT */;
      }
  }
  const allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
      if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ &&
          !isString(value.callee) &&
          allowHoistedHelperSet.has(value.callee)) {
          const arg = value.arguments[0];
          if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
              return getConstantType(arg, context);
          }
          else if (arg.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
              // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
              return getConstantTypeOfHelperCall(arg, context);
          }
      }
      return 0 /* ConstantTypes.NOT_CONSTANT */;
  }
  function getGeneratedPropsConstantType(node, context) {
      let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;
      const props = getNodeProps(node);
      if (props && props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
          const { properties } = props;
          for (let i = 0; i < properties.length; i++) {
              const { key, value } = properties[i];
              const keyType = getConstantType(key, context);
              if (keyType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                  return keyType;
              }
              if (keyType < returnType) {
                  returnType = keyType;
              }
              let valueType;
              if (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                  valueType = getConstantType(value, context);
              }
              else if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {
                  // some helper calls can be hoisted,
                  // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                  // in this case we need to respect the ConstantType of the helper's arguments
                  valueType = getConstantTypeOfHelperCall(value, context);
              }
              else {
                  valueType = 0 /* ConstantTypes.NOT_CONSTANT */;
              }
              if (valueType === 0 /* ConstantTypes.NOT_CONSTANT */) {
                  return valueType;
              }
              if (valueType < returnType) {
                  returnType = valueType;
              }
          }
      }
      return returnType;
  }
  function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
          return codegenNode.props;
      }
  }
  function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : undefined;
  }

  function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
      const context = {
          // options
          selfName: nameMatch && capitalize(camelize(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          inSSR,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          onWarn,
          compatConfig,
          // state
          root,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new Map(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: {
              vFor: 0,
              vSlot: 0,
              vPre: 0,
              vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          inVOnce: false,
          // methods
          helper(name) {
              const count = context.helpers.get(name) || 0;
              context.helpers.set(name, count + 1);
              return name;
          },
          removeHelper(name) {
              const count = context.helpers.get(name);
              if (count) {
                  const currentCount = count - 1;
                  if (!currentCount) {
                      context.helpers.delete(name);
                  }
                  else {
                      context.helpers.set(name, currentCount);
                  }
              }
          },
          helperString(name) {
              return `_${helperNameMap[context.helper(name)]}`;
          },
          replaceNode(node) {
              /* istanbul ignore if */
              {
                  if (!context.currentNode) {
                      throw new Error(`Node being replaced is already removed.`);
                  }
                  if (!context.parent) {
                      throw new Error(`Cannot replace root node.`);
                  }
              }
              context.parent.children[context.childIndex] = context.currentNode = node;
          },
          removeNode(node) {
              if (!context.parent) {
                  throw new Error(`Cannot remove root node.`);
              }
              const list = context.parent.children;
              const removalIndex = node
                  ? list.indexOf(node)
                  : context.currentNode
                      ? context.childIndex
                      : -1;
              /* istanbul ignore if */
              if (removalIndex < 0) {
                  throw new Error(`node being removed is not a child of current parent`);
              }
              if (!node || node === context.currentNode) {
                  // current node removed
                  context.currentNode = null;
                  context.onNodeRemoved();
              }
              else {
                  // sibling node removed
                  if (context.childIndex > removalIndex) {
                      context.childIndex--;
                      context.onNodeRemoved();
                  }
              }
              context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => { },
          addIdentifiers(exp) {
          },
          removeIdentifiers(exp) {
          },
          hoist(exp) {
              if (isString(exp))
                  exp = createSimpleExpression(exp);
              context.hoists.push(exp);
              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* ConstantTypes.CAN_HOIST */);
              identifier.hoisted = exp;
              return identifier;
          },
          cache(exp, isVNode = false) {
              return createCacheExpression(context.cached++, exp, isVNode);
          }
      };
      {
          context.filters = new Set();
      }
      return context;
  }
  function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
          hoistStatic(root, context);
      }
      if (!options.ssr) {
          createRootCodegen(root, context);
      }
      // finalize meta information
      root.helpers = new Set([...context.helpers.keys()]);
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
      {
          root.filters = [...context.filters];
      }
  }
  function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
          const child = children[0];
          // if the single child is an element, turn it into a block.
          if (isSingleElementRoot(root, child) && child.codegenNode) {
              // single element root is never hoisted so codegenNode will never be
              // SimpleExpressionNode
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                  makeBlock(codegenNode, context);
              }
              root.codegenNode = codegenNode;
          }
          else {
              // - single <slot/>, IfNode, ForNode: already blocks.
              // - single text node: always patched.
              // root codegen falls through via genNode()
              root.codegenNode = child;
          }
      }
      else if (children.length > 1) {
          // root has multiple nodes - return a fragment block.
          let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
          let patchFlagText = PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];
          // check if the fragment actually contains a single valid child with
          // the rest being comments
          if (children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
              patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
              patchFlagText += `, ${PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;
          }
          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, undefined, false /* isComponent */);
      }
      else ;
  }
  function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
          i--;
      };
      for (; i < parent.children.length; i++) {
          const child = parent.children[i];
          if (isString(child))
              continue;
          context.parent = parent;
          context.childIndex = i;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
      }
  }
  function traverseNode(node, context) {
      context.currentNode = node;
      // apply transform plugins
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i = 0; i < nodeTransforms.length; i++) {
          const onExit = nodeTransforms[i](node, context);
          if (onExit) {
              if (isArray(onExit)) {
                  exitFns.push(...onExit);
              }
              else {
                  exitFns.push(onExit);
              }
          }
          if (!context.currentNode) {
              // node was removed
              return;
          }
          else {
              // node may have been replaced
              node = context.currentNode;
          }
      }
      switch (node.type) {
          case 3 /* NodeTypes.COMMENT */:
              if (!context.ssr) {
                  // inject import for the Comment symbol, which is needed for creating
                  // comment nodes with `createVNode`
                  context.helper(CREATE_COMMENT);
              }
              break;
          case 5 /* NodeTypes.INTERPOLATION */:
              // no need to traverse, but we need to inject toString helper
              if (!context.ssr) {
                  context.helper(TO_DISPLAY_STRING);
              }
              break;
          // for container types, further traverse downwards
          case 9 /* NodeTypes.IF */:
              for (let i = 0; i < node.branches.length; i++) {
                  traverseNode(node.branches[i], context);
              }
              break;
          case 10 /* NodeTypes.IF_BRANCH */:
          case 11 /* NodeTypes.FOR */:
          case 1 /* NodeTypes.ELEMENT */:
          case 0 /* NodeTypes.ROOT */:
              traverseChildren(node, context);
              break;
      }
      // exit transforms
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
          exitFns[i]();
      }
  }
  function createStructuralDirectiveTransform(name, fn) {
      const matches = isString(name)
          ? (n) => n === name
          : (n) => name.test(n);
      return (node, context) => {
          if (node.type === 1 /* NodeTypes.ELEMENT */) {
              const { props } = node;
              // structural directive transforms are not concerned with slots
              // as they are handled separately in vSlot.ts
              if (node.tagType === 3 /* ElementTypes.TEMPLATE */ && props.some(isVSlot)) {
                  return;
              }
              const exitFns = [];
              for (let i = 0; i < props.length; i++) {
                  const prop = props[i];
                  if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && matches(prop.name)) {
                      // structural directives are removed to avoid infinite recursion
                      // also we remove them *before* applying so that it can further
                      // traverse itself in case it moves the node around
                      props.splice(i, 1);
                      i--;
                      const onExit = fn(node, prop, context);
                      if (onExit)
                          exitFns.push(onExit);
                  }
              }
              return exitFns;
          }
      };
  }

  const PURE_ANNOTATION = `/*#__PURE__*/`;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
      const context = {
          mode,
          prefixIdentifiers,
          sourceMap,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssrRuntimeModuleName,
          ssr,
          isTS,
          inSSR,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: undefined,
          helper(key) {
              return `_${helperNameMap[key]}`;
          },
          push(code, node) {
              context.code += code;
          },
          indent() {
              newline(++context.indentLevel);
          },
          deindent(withoutNewLine = false) {
              if (withoutNewLine) {
                  --context.indentLevel;
              }
              else {
                  newline(--context.indentLevel);
              }
          },
          newline() {
              newline(context.indentLevel);
          }
      };
      function newline(n) {
          context.push('\n' + `  `.repeat(n));
      }
      return context;
  }
  function generate(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
          options.onContextCreated(context);
      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
      const helpers = Array.from(ast.helpers);
      const hasHelpers = helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== 'module';
      const isSetupInlined = !true ;
      // preambles
      // in setup() inline mode, the preamble is generated in a sub context
      // and returned separately.
      const preambleContext = isSetupInlined
          ? createCodegenContext(ast, options)
          : context;
      {
          genFunctionPreamble(ast, preambleContext);
      }
      // enter render function
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
      const signature = args.join(', ');
      {
          push(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
          push(`with (_ctx) {`);
          indent();
          // function mode const declarations should be inside with block
          // also they should be renamed to avoid collision with user properties
          if (hasHelpers) {
              push(`const { ${helpers.map(aliasHelper).join(', ')} } = _Vue`);
              push(`\n`);
              newline();
          }
      }
      // generate asset resolution statements
      if (ast.components.length) {
          genAssets(ast.components, 'component', context);
          if (ast.directives.length || ast.temps > 0) {
              newline();
          }
      }
      if (ast.directives.length) {
          genAssets(ast.directives, 'directive', context);
          if (ast.temps > 0) {
              newline();
          }
      }
      if (ast.filters && ast.filters.length) {
          newline();
          genAssets(ast.filters, 'filter', context);
          newline();
      }
      if (ast.temps > 0) {
          push(`let `);
          for (let i = 0; i < ast.temps; i++) {
              push(`${i > 0 ? `, ` : ``}_temp${i}`);
          }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
          push(`\n`);
          newline();
      }
      // generate the VNode tree expression
      if (!ssr) {
          push(`return `);
      }
      if (ast.codegenNode) {
          genNode(ast.codegenNode, context);
      }
      else {
          push(`null`);
      }
      if (useWithBlock) {
          deindent();
          push(`}`);
      }
      deindent();
      push(`}`);
      return {
          ast,
          code: context.code,
          preamble: isSetupInlined ? preambleContext.code : ``,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context.map ? context.map.toJSON() : undefined
      };
  }
  function genFunctionPreamble(ast, context) {
      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
      const VueBinding = runtimeGlobalName;
      // Generate const declaration for helpers
      // In prefix mode, we place the const declaration at top so it's done
      // only once; But if we not prefixing, we place the declaration inside the
      // with block so it doesn't incur the `in` check cost for every helper access.
      const helpers = Array.from(ast.helpers);
      if (helpers.length > 0) {
          {
              // "with" mode.
              // save Vue in a separate variable to avoid collision
              push(`const _Vue = ${VueBinding}\n`);
              // in "with" mode, helpers are declared inside the with block to avoid
              // has check cost, but hoists are lifted out of the function - we need
              // to provide the helper here.
              if (ast.hoists.length) {
                  const staticHelpers = [
                      CREATE_VNODE,
                      CREATE_ELEMENT_VNODE,
                      CREATE_COMMENT,
                      CREATE_TEXT,
                      CREATE_STATIC
                  ]
                      .filter(helper => helpers.includes(helper))
                      .map(aliasHelper)
                      .join(', ');
                  push(`const { ${staticHelpers} } = _Vue\n`);
              }
          }
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
      const resolver = helper(type === 'filter'
          ? RESOLVE_FILTER
          : type === 'component'
              ? RESOLVE_COMPONENT
              : RESOLVE_DIRECTIVE);
      for (let i = 0; i < assets.length; i++) {
          let id = assets[i];
          // potential component implicit self-reference inferred from SFC filename
          const maybeSelfReference = id.endsWith('__self');
          if (maybeSelfReference) {
              id = id.slice(0, -6);
          }
          push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
          if (i < assets.length - 1) {
              newline();
          }
      }
  }
  function genHoists(hoists, context) {
      if (!hoists.length) {
          return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      newline();
      for (let i = 0; i < hoists.length; i++) {
          const exp = hoists[i];
          if (exp) {
              push(`const _hoisted_${i + 1} = ${``}`);
              genNode(exp, context);
              newline();
          }
      }
      context.pure = false;
  }
  function isText(n) {
      return (isString(n) ||
          n.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
          n.type === 2 /* NodeTypes.TEXT */ ||
          n.type === 5 /* NodeTypes.INTERPOLATION */ ||
          n.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */);
  }
  function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 ||
          (nodes.some(n => isArray(n) || !isText(n)));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (isString(node)) {
              push(node);
          }
          else if (isArray(node)) {
              genNodeListAsArray(node, context);
          }
          else {
              genNode(node, context);
          }
          if (i < nodes.length - 1) {
              if (multilines) {
                  comma && push(',');
                  newline();
              }
              else {
                  comma && push(', ');
              }
          }
      }
  }
  function genNode(node, context) {
      if (isString(node)) {
          context.push(node);
          return;
      }
      if (isSymbol(node)) {
          context.push(context.helper(node));
          return;
      }
      switch (node.type) {
          case 1 /* NodeTypes.ELEMENT */:
          case 9 /* NodeTypes.IF */:
          case 11 /* NodeTypes.FOR */:
              assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                      `Apply appropriate transforms first.`);
              genNode(node.codegenNode, context);
              break;
          case 2 /* NodeTypes.TEXT */:
              genText(node, context);
              break;
          case 4 /* NodeTypes.SIMPLE_EXPRESSION */:
              genExpression(node, context);
              break;
          case 5 /* NodeTypes.INTERPOLATION */:
              genInterpolation(node, context);
              break;
          case 12 /* NodeTypes.TEXT_CALL */:
              genNode(node.codegenNode, context);
              break;
          case 8 /* NodeTypes.COMPOUND_EXPRESSION */:
              genCompoundExpression(node, context);
              break;
          case 3 /* NodeTypes.COMMENT */:
              genComment(node, context);
              break;
          case 13 /* NodeTypes.VNODE_CALL */:
              genVNodeCall(node, context);
              break;
          case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
              genCallExpression(node, context);
              break;
          case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
              genObjectExpression(node, context);
              break;
          case 17 /* NodeTypes.JS_ARRAY_EXPRESSION */:
              genArrayExpression(node, context);
              break;
          case 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */:
              genFunctionExpression(node, context);
              break;
          case 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */:
              genConditionalExpression(node, context);
              break;
          case 20 /* NodeTypes.JS_CACHE_EXPRESSION */:
              genCacheExpression(node, context);
              break;
          case 21 /* NodeTypes.JS_BLOCK_STATEMENT */:
              genNodeList(node.body, context, true, false);
              break;
          // SSR only types
          case 22 /* NodeTypes.JS_TEMPLATE_LITERAL */:
              break;
          case 23 /* NodeTypes.JS_IF_STATEMENT */:
              break;
          case 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */:
              break;
          case 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */:
              break;
          case 26 /* NodeTypes.JS_RETURN_STATEMENT */:
              break;
          /* istanbul ignore next */
          case 10 /* NodeTypes.IF_BRANCH */:
              // noop
              break;
          default:
              {
                  assert(false, `unhandled codegen node type: ${node.type}`);
                  // make sure we exhaust all possible types
                  const exhaustiveCheck = node;
                  return exhaustiveCheck;
              }
      }
  }
  function genText(node, context) {
      context.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
          push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
  }
  function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child)) {
              context.push(child);
          }
          else {
              genNode(child, context);
          }
      }
  }
  function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
          push(`[`);
          genCompoundExpression(node, context);
          push(`]`);
      }
      else if (node.isStatic) {
          // only quote keys if necessary
          const text = isSimpleIdentifier(node.content)
              ? node.content
              : JSON.stringify(node.content);
          push(text, node);
      }
      else {
          push(`[${node.content}]`, node);
      }
  }
  function genComment(node, context) {
      const { push, helper, pure } = context;
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
  }
  function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
      if (directives) {
          push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
          push(PURE_ANNOTATION);
      }
      const callHelper = isBlock
          ? getVNodeBlockHelper(context.inSSR, isComponent)
          : getVNodeHelper(context.inSSR, isComponent);
      push(helper(callHelper) + `(`, node);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
      push(`)`);
      if (isBlock) {
          push(`)`);
      }
      if (directives) {
          push(`, `);
          genNode(directives, context);
          push(`)`);
      }
  }
  function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
          if (args[i] != null)
              break;
      }
      return args.slice(0, i + 1).map(arg => arg || `null`);
  }
  // JavaScript
  function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(callee + `(`, node);
      genNodeList(node.arguments, context);
      push(`)`);
  }
  function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
          push(`{}`, node);
          return;
      }
      const multilines = properties.length > 1 ||
          (properties.some(p => p.value.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */));
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          // key
          genExpressionAsPropertyKey(key, context);
          push(`: `);
          // value
          genNode(value, context);
          if (i < properties.length - 1) {
              // will only reach this if it's multilines
              push(`,`);
              newline();
          }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
      const { push, indent, deindent } = context;
      const { params, returns, body, newline, isSlot } = node;
      if (isSlot) {
          // wrap slot functions with owner context
          push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, node);
      if (isArray(params)) {
          genNodeList(params, context);
      }
      else if (params) {
          genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
          push(`{`);
          indent();
      }
      if (returns) {
          if (newline) {
              push(`return `);
          }
          if (isArray(returns)) {
              genNodeListAsArray(returns, context);
          }
          else {
              genNode(returns, context);
          }
      }
      else if (body) {
          genNode(body, context);
      }
      if (newline || body) {
          deindent();
          push(`}`);
      }
      if (isSlot) {
          if (node.isNonScopedSlot) {
              push(`, undefined, true`);
          }
          push(`)`);
      }
  }
  function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push(`(`);
          genExpression(test, context);
          needsParens && push(`)`);
      }
      else {
          push(`(`);
          genNode(test, context);
          push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */;
      if (!isNested) {
          context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
          context.indentLevel--;
      }
      needNewline && deindent(true /* without newline */);
  }
  function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
          indent();
          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
          push(`,`);
          newline();
          push(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline();
          push(`_cache[${node.index}]`);
          deindent();
      }
      push(`)`);
  }

  function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
      {
          return;
      }
  }
  function isReferencedIdentifier(id, parent, parentStack) {
      {
          return false;
      }
  }
  function isInDestructureAssignment(parent, parentStack) {
      if (parent &&
          (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {
          let i = parentStack.length;
          while (i--) {
              const p = parentStack[i];
              if (p.type === 'AssignmentExpression') {
                  return true;
              }
              else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
                  break;
              }
          }
      }
      return false;
  }
  function walkFunctionParams(node, onIdent) {
      for (const p of node.params) {
          for (const id of extractIdentifiers(p)) {
              onIdent(id);
          }
      }
  }
  function walkBlockDeclarations(block, onIdent) {
      for (const stmt of block.body) {
          if (stmt.type === 'VariableDeclaration') {
              if (stmt.declare)
                  continue;
              for (const decl of stmt.declarations) {
                  for (const id of extractIdentifiers(decl.id)) {
                      onIdent(id);
                  }
              }
          }
          else if (stmt.type === 'FunctionDeclaration' ||
              stmt.type === 'ClassDeclaration') {
              if (stmt.declare || !stmt.id)
                  continue;
              onIdent(stmt.id);
          }
      }
  }
  function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
          case 'Identifier':
              nodes.push(param);
              break;
          case 'MemberExpression':
              let object = param;
              while (object.type === 'MemberExpression') {
                  object = object.object;
              }
              nodes.push(object);
              break;
          case 'ObjectPattern':
              for (const prop of param.properties) {
                  if (prop.type === 'RestElement') {
                      extractIdentifiers(prop.argument, nodes);
                  }
                  else {
                      extractIdentifiers(prop.value, nodes);
                  }
              }
              break;
          case 'ArrayPattern':
              param.elements.forEach(element => {
                  if (element)
                      extractIdentifiers(element, nodes);
              });
              break;
          case 'RestElement':
              extractIdentifiers(param.argument, nodes);
              break;
          case 'AssignmentPattern':
              extractIdentifiers(param.left, nodes);
              break;
      }
      return nodes;
  }
  const isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
  };
  const isStaticProperty = (node) => node &&
      (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
      !node.computed;
  const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;

  // these keywords should not appear inside expressions, but operators like
  // 'typeof', 'instanceof', and 'in' are allowed
  const prohibitedKeywordRE = new RegExp('\\b' +
      ('arguments,await,break,case,catch,class,const,continue,debugger,default,' +
          'delete,do,else,export,extends,finally,for,function,if,import,let,new,' +
          'return,super,switch,throw,try,var,void,while,with,yield')
          .split(',')
          .join('\\b|\\b') +
      '\\b');
  // strip strings in expressions
  const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
  /**
   * Validate a non-prefixed expression.
   * This is only called when using the in-browser runtime compiler since it
   * doesn't prefix expressions.
   */
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
      const exp = node.content;
      // empty expressions are validated per-directive since some directives
      // do allow empty expressions.
      if (!exp.trim()) {
          return;
      }
      try {
          new Function(asRawStatements
              ? ` ${exp} `
              : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
      }
      catch (e) {
          let message = e.message;
          const keywordMatch = exp
              .replace(stripStringRE, '')
              .match(prohibitedKeywordRE);
          if (keywordMatch) {
              message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
          }
          context.onError(createCompilerError(45 /* ErrorCodes.X_INVALID_EXPRESSION */, node.loc, undefined, message));
      }
  }

  const transformExpression = (node, context) => {
      if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
          node.content = processExpression(node.content, context);
      }
      else if (node.type === 1 /* NodeTypes.ELEMENT */) {
          // handle directives on element
          for (let i = 0; i < node.props.length; i++) {
              const dir = node.props[i];
              // do not process for v-on & v-for since they are special handled
              if (dir.type === 7 /* NodeTypes.DIRECTIVE */ && dir.name !== 'for') {
                  const exp = dir.exp;
                  const arg = dir.arg;
                  // do not process exp if this is v-on:arg - we need special handling
                  // for wrapping inline statements.
                  if (exp &&
                      exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                      !(dir.name === 'on' && arg)) {
                      dir.exp = processExpression(exp, context, 
                      // slot args must be processed as function params
                      dir.name === 'slot');
                  }
                  if (arg && arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !arg.isStatic) {
                      dir.arg = processExpression(arg, context);
                  }
              }
          }
      }
  };
  // Important: since this function uses Node.js only dependencies, it should
  // always be used with a leading !true check so that it can be
  // tree-shaken from the browser build.
  function processExpression(node, context, 
  // some expressions like v-slot props & v-for aliases should be parsed as
  // function params
  asParams = false, 
  // v-on handler values may contain multiple statements
  asRawStatements = false, localVars = Object.create(context.identifiers)) {
      {
          {
              // simple in-browser validation (same logic in 2.x)
              validateBrowserExpression(node, context, asParams, asRawStatements);
          }
          return node;
      }
  }
  function stringifyExpression(exp) {
      if (isString(exp)) {
          return exp;
      }
      else if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          return exp.content;
      }
      else {
          return exp.children
              .map(stringifyExpression)
              .join('');
      }
  }

  const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          // #1587: We need to dynamically increment the key based on the current
          // node's sibling nodes, since chained v-if/else branches are
          // rendered at the same depth
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                  key += sibling.branches.length;
              }
          }
          // Exit callback. Complete the codegenNode when all children have been
          // transformed.
          return () => {
              if (isRoot) {
                  ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
              }
              else {
                  // attach this branch's codegen node to the v-if root.
                  const parentCondition = getParentCondition(ifNode.codegenNode);
                  parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
              }
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processIf(node, dir, context, processCodegen) {
      if (dir.name !== 'else' &&
          (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node.loc;
          context.onError(createCompilerError(28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */, dir.loc));
          dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (dir.exp) {
          validateBrowserExpression(dir.exp, context);
      }
      if (dir.name === 'if') {
          const branch = createIfBranch(node, dir);
          const ifNode = {
              type: 9 /* NodeTypes.IF */,
              loc: node.loc,
              branches: [branch]
          };
          context.replaceNode(ifNode);
          if (processCodegen) {
              return processCodegen(ifNode, branch, true);
          }
      }
      else {
          // locate the adjacent v-if
          const siblings = context.parent.children;
          const comments = [];
          let i = siblings.indexOf(node);
          while (i-- >= -1) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 3 /* NodeTypes.COMMENT */) {
                  context.removeNode(sibling);
                  comments.unshift(sibling);
                  continue;
              }
              if (sibling &&
                  sibling.type === 2 /* NodeTypes.TEXT */ &&
                  !sibling.content.trim().length) {
                  context.removeNode(sibling);
                  continue;
              }
              if (sibling && sibling.type === 9 /* NodeTypes.IF */) {
                  // Check if v-else was followed by v-else-if
                  if (dir.name === 'else-if' &&
                      sibling.branches[sibling.branches.length - 1].condition === undefined) {
                      context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                  }
                  // move the node to the if node's branches
                  context.removeNode();
                  const branch = createIfBranch(node, dir);
                  if (comments.length &&
                      // #3619 ignore comments if the v-if is direct child of <transition>
                      !(context.parent &&
                          context.parent.type === 1 /* NodeTypes.ELEMENT */ &&
                          isBuiltInType(context.parent.tag, 'transition'))) {
                      branch.children = [...comments, ...branch.children];
                  }
                  // check if user is forcing same key on different branches
                  {
                      const key = branch.userKey;
                      if (key) {
                          sibling.branches.forEach(({ userKey }) => {
                              if (isSameKey(userKey, key)) {
                                  context.onError(createCompilerError(29 /* ErrorCodes.X_V_IF_SAME_KEY */, branch.userKey.loc));
                              }
                          });
                      }
                  }
                  sibling.branches.push(branch);
                  const onExit = processCodegen && processCodegen(sibling, branch, false);
                  // since the branch was removed, it will not be traversed.
                  // make sure to traverse here.
                  traverseNode(branch, context);
                  // call on exit
                  if (onExit)
                      onExit();
                  // make sure to reset currentNode after traversal to indicate this
                  // node has been removed.
                  context.currentNode = null;
              }
              else {
                  context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));
              }
              break;
          }
      }
  }
  function createIfBranch(node, dir) {
      const isTemplateIf = node.tagType === 3 /* ElementTypes.TEMPLATE */;
      return {
          type: 10 /* NodeTypes.IF_BRANCH */,
          loc: node.loc,
          condition: dir.name === 'else' ? undefined : dir.exp,
          children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
          userKey: findProp(node, `key`),
          isTemplateIf
      };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
          return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
          // make sure to pass in asBlock: true so that the comment node call
          // closes the current block.
          createCallExpression(context.helper(CREATE_COMMENT), [
              '"v-if"' ,
              'true'
          ]));
      }
      else {
          return createChildrenCodegenNode(branch, keyIndex, context);
      }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* ConstantTypes.CAN_HOIST */));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* NodeTypes.ELEMENT */;
      if (needFragmentWrapper) {
          if (children.length === 1 && firstChild.type === 11 /* NodeTypes.FOR */) {
              // optimize away nested fragments when child is a ForNode
              const vnodeCall = firstChild.codegenNode;
              injectProp(vnodeCall, keyProperty, context);
              return vnodeCall;
          }
          else {
              let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;
              let patchFlagText = PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];
              // check if the fragment actually contains a single valid child with
              // the rest being comments
              if (!branch.isTemplateIf &&
                  children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {
                  patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;
                  patchFlagText += `, ${PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;
              }
              return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, false, false /* isComponent */, branch.loc);
          }
      }
      else {
          const ret = firstChild.codegenNode;
          const vnodeCall = getMemoedVNodeCall(ret);
          // Change createVNode to createBlock.
          if (vnodeCall.type === 13 /* NodeTypes.VNODE_CALL */) {
              makeBlock(vnodeCall, context);
          }
          // inject branch key
          injectProp(vnodeCall, keyProperty, context);
          return ret;
      }
  }
  function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
          return false;
      }
      if (a.type === 6 /* NodeTypes.ATTRIBUTE */) {
          if (a.value.content !== b.value.content) {
              return false;
          }
      }
      else {
          // directive
          const exp = a.exp;
          const branchExp = b.exp;
          if (exp.type !== branchExp.type) {
              return false;
          }
          if (exp.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
              exp.isStatic !== branchExp.isStatic ||
              exp.content !== branchExp.content) {
              return false;
          }
      }
      return true;
  }
  function getParentCondition(node) {
      while (true) {
          if (node.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
              if (node.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                  node = node.alternate;
              }
              else {
                  return node;
              }
          }
          else if (node.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */) {
              node = node.value;
          }
      }
  }

  const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, forNode => {
          // create the loop render function expression now, and add the
          // iterator on exit after all children have been traversed
          const renderExp = createCallExpression(helper(RENDER_LIST), [
              forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, 'memo');
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp &&
              (keyProp.type === 6 /* NodeTypes.ATTRIBUTE */
                  ? createSimpleExpression(keyProp.value.content, true)
                  : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
              forNode.source.constType > 0 /* ConstantTypes.NOT_CONSTANT */;
          const fragmentFlag = isStableFragment
              ? 64 /* PatchFlags.STABLE_FRAGMENT */
              : keyProp
                  ? 128 /* PatchFlags.KEYED_FRAGMENT */
                  : 256 /* PatchFlags.UNKEYED_FRAGMENT */;
          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
              (` /* ${PatchFlagNames[fragmentFlag]} */` ), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
          return () => {
              // finish the codegen now that all children have been traversed
              let childBlock;
              const { children } = forNode;
              // check <template v-for> key placement
              if (isTemplate) {
                  node.children.some(c => {
                      if (c.type === 1 /* NodeTypes.ELEMENT */) {
                          const key = findProp(c, 'key');
                          if (key) {
                              context.onError(createCompilerError(33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                              return true;
                          }
                      }
                  });
              }
              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */;
              const slotOutlet = isSlotOutlet(node)
                  ? node
                  : isTemplate &&
                      node.children.length === 1 &&
                      isSlotOutlet(node.children[0])
                      ? node.children[0] // api-extractor somehow fails to infer this
                      : null;
              if (slotOutlet) {
                  // <slot v-for="..."> or <template v-for="..."><slot/></template>
                  childBlock = slotOutlet.codegenNode;
                  if (isTemplate && keyProperty) {
                      // <template v-for="..." :key="..."><slot/></template>
                      // we need to inject the key to the renderSlot() call.
                      // the props for renderSlot is passed as the 3rd argument.
                      injectProp(childBlock, keyProperty, context);
                  }
              }
              else if (needFragmentWrapper) {
                  // <template v-for="..."> with text or multi-elements
                  // should generate a fragment block for each loop
                  childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* PatchFlags.STABLE_FRAGMENT */ +
                      (` /* ${PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */]} */`
                          ), undefined, undefined, true, undefined, false /* isComponent */);
              }
              else {
                  // Normal element v-for. Directly use the child's codegenNode
                  // but mark it as a block.
                  childBlock = children[0]
                      .codegenNode;
                  if (isTemplate && keyProperty) {
                      injectProp(childBlock, keyProperty, context);
                  }
                  if (childBlock.isBlock !== !isStableFragment) {
                      if (childBlock.isBlock) {
                          // switch from block to vnode
                          removeHelper(OPEN_BLOCK);
                          removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                      }
                      else {
                          // switch from vnode to block
                          removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                      }
                  }
                  childBlock.isBlock = !isStableFragment;
                  if (childBlock.isBlock) {
                      helper(OPEN_BLOCK);
                      helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                  }
                  else {
                      helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                  }
              }
              if (memo) {
                  const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                      createSimpleExpression(`_cached`)
                  ]));
                  loop.body = createBlockStatement([
                      createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                      createCompoundExpression([
                          `if (_cached`,
                          ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                          ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                      ]),
                      createCompoundExpression([`const _item = `, childBlock]),
                      createSimpleExpression(`_item.memo = _memo`),
                      createSimpleExpression(`return _item`)
                  ]);
                  renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
              }
              else {
                  renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
              }
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
          context.onError(createCompilerError(31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */, dir.loc));
          return;
      }
      const parseResult = parseForExpression(
      // can only be simple expression because vFor transform is applied
      // before expression transform.
      dir.exp, context);
      if (!parseResult) {
          context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
          return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
          type: 11 /* NodeTypes.FOR */,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index,
          parseResult,
          children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      // bookkeeping
      scopes.vFor++;
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
          scopes.vFor--;
          if (onExit)
              onExit();
      };
  }
  const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  // This regex doesn't cover the case if key or index aliases have destructuring,
  // but those do not make sense in the first place, so this works in practice.
  const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  function parseForExpression(input, context) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
          return;
      const [, LHS, RHS] = inMatch;
      const result = {
          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
          value: undefined,
          key: undefined,
          index: undefined
      };
      {
          validateBrowserExpression(result.source, context);
      }
      let valueContent = LHS.trim().replace(stripParensRE, '').trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, '').trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
              keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
              result.key = createAliasExpression(loc, keyContent, keyOffset);
              {
                  validateBrowserExpression(result.key, context, true);
              }
          }
          if (iteratorMatch[2]) {
              const indexContent = iteratorMatch[2].trim();
              if (indexContent) {
                  result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                      ? keyOffset + keyContent.length
                      : trimmedOffset + valueContent.length));
                  {
                      validateBrowserExpression(result.index, context, true);
                  }
              }
          }
      }
      if (valueContent) {
          result.value = createAliasExpression(loc, valueContent, trimmedOffset);
          {
              validateBrowserExpression(result.value, context, true);
          }
      }
      return result;
  }
  function createAliasExpression(range, content, offset) {
      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
  }
  function createForLoopParams({ value, key, index }, memoArgs = []) {
      return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
      let i = args.length;
      while (i--) {
          if (args[i])
              break;
      }
      return args
          .slice(0, i + 1)
          .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
  }

  const defaultFallback = createSimpleExpression(`undefined`, false);
  // A NodeTransform that:
  // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
  //    by transformExpression. This is only applied in non-browser builds with
  //    { prefixIdentifiers: true }.
  // 2. Track v-slot depths so that we know a slot is inside another slot.
  //    Note the exit callback is executed before buildSlots() on the same node,
  //    so only nested slots see positive numbers.
  const trackSlotScopes = (node, context) => {
      if (node.type === 1 /* NodeTypes.ELEMENT */ &&
          (node.tagType === 1 /* ElementTypes.COMPONENT */ ||
              node.tagType === 3 /* ElementTypes.TEMPLATE */)) {
          // We are only checking non-empty v-slot here
          // since we only care about slots that introduce scope variables.
          const vSlot = findDir(node, 'slot');
          if (vSlot) {
              vSlot.exp;
              context.scopes.vSlot++;
              return () => {
                  context.scopes.vSlot--;
              };
          }
      }
  };
  // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
  // This transform is only applied in non-browser builds with { prefixIdentifiers: true }
  const trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) &&
          node.props.some(isVSlot) &&
          (vFor = findDir(node, 'for'))) {
          const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
          if (result) {
              const { value, key, index } = result;
              const { addIdentifiers, removeIdentifiers } = context;
              value && addIdentifiers(value);
              key && addIdentifiers(key);
              index && addIdentifiers(index);
              return () => {
                  value && removeIdentifiers(value);
                  key && removeIdentifiers(key);
                  index && removeIdentifiers(index);
              };
          }
      }
  };
  const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
  // Instead of being a DirectiveTransform, v-slot processing is called during
  // transformElement to build the slots object for a component.
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      // If the slot is inside a v-for or another v-slot, force it to be dynamic
      // since it likely uses a scope variable.
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      // 1. Check for slot with slotProps on component itself.
      //    <Comp v-slot="{ prop }"/>
      const onComponentSlot = findDir(node, 'slot', true);
      if (onComponentSlot) {
          const { arg, exp } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
              hasDynamicSlots = true;
          }
          slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
      }
      // 2. Iterate through children and check for template slots
      //    <template v-slot:foo="{ prop }">
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = new Set();
      let conditionalBranchIndex = 0;
      for (let i = 0; i < children.length; i++) {
          const slotElement = children[i];
          let slotDir;
          if (!isTemplateNode(slotElement) ||
              !(slotDir = findDir(slotElement, 'slot', true))) {
              // not a <template v-slot>, skip.
              if (slotElement.type !== 3 /* NodeTypes.COMMENT */) {
                  implicitDefaultChildren.push(slotElement);
              }
              continue;
          }
          if (onComponentSlot) {
              // already has on-component slot - this is incorrect usage.
              context.onError(createCompilerError(37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
              break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
          // check if name is dynamic.
          let staticSlotName;
          if (isStaticExp(slotName)) {
              staticSlotName = slotName ? slotName.content : `default`;
          }
          else {
              hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          // check if this slot is conditional (v-if/v-for)
          let vIf;
          let vElse;
          let vFor;
          if ((vIf = findDir(slotElement, 'if'))) {
              hasDynamicSlots = true;
              dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
          }
          else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
              // find adjacent v-if
              let j = i;
              let prev;
              while (j--) {
                  prev = children[j];
                  if (prev.type !== 3 /* NodeTypes.COMMENT */) {
                      break;
                  }
              }
              if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                  // remove node
                  children.splice(i, 1);
                  i--;
                  // attach this slot to previous conditional
                  let conditional = dynamicSlots[dynamicSlots.length - 1];
                  while (conditional.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {
                      conditional = conditional.alternate;
                  }
                  conditional.alternate = vElse.exp
                      ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback)
                      : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
              }
              else {
                  context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
              }
          }
          else if ((vFor = findDir(slotElement, 'for'))) {
              hasDynamicSlots = true;
              const parseResult = vFor.parseResult ||
                  parseForExpression(vFor.exp, context);
              if (parseResult) {
                  // Render the dynamic slots as an array and add it to the createSlot()
                  // args. The runtime knows how to handle it appropriately.
                  dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                      parseResult.source,
                      createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                  ]));
              }
              else {
                  context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
              }
          }
          else {
              // check duplicate static names
              if (staticSlotName) {
                  if (seenSlotNames.has(staticSlotName)) {
                      context.onError(createCompilerError(38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                      continue;
                  }
                  seenSlotNames.add(staticSlotName);
                  if (staticSlotName === 'default') {
                      hasNamedDefaultSlot = true;
                  }
              }
              slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
      }
      if (!onComponentSlot) {
          const buildDefaultSlotProperty = (props, children) => {
              const fn = buildSlotFn(props, children, loc);
              if (context.compatConfig) {
                  fn.isNonScopedSlot = true;
              }
              return createObjectProperty(`default`, fn);
          };
          if (!hasTemplateSlots) {
              // implicit default slot (on component)
              slotsProperties.push(buildDefaultSlotProperty(undefined, children));
          }
          else if (implicitDefaultChildren.length &&
              // #3766
              // with whitespace: 'preserve', whitespaces between slots will end up in
              // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
              implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
              // implicit default slot (mixed with named slots)
              if (hasNamedDefaultSlot) {
                  context.onError(createCompilerError(39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
              }
              else {
                  slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
              }
          }
      }
      const slotFlag = hasDynamicSlots
          ? 2 /* SlotFlags.DYNAMIC */
          : hasForwardedSlots(node.children)
              ? 3 /* SlotFlags.FORWARDED */
              : 1 /* SlotFlags.STABLE */;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
      // 2 = compiled but dynamic = can skip normalization, but must run diff
      // 1 = compiled and static = can skip normalization AND diff as optimized
      createSimpleExpression(slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ), false))), loc);
      if (dynamicSlots.length) {
          slots = createCallExpression(context.helper(CREATE_SLOTS), [
              slots,
              createArrayExpression(dynamicSlots)
          ]);
      }
      return {
          slots,
          hasDynamicSlots
      };
  }
  function buildDynamicSlot(name, fn, index) {
      const props = [
          createObjectProperty(`name`, name),
          createObjectProperty(`fn`, fn)
      ];
      if (index != null) {
          props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));
      }
      return createObjectExpression(props);
  }
  function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          switch (child.type) {
              case 1 /* NodeTypes.ELEMENT */:
                  if (child.tagType === 2 /* ElementTypes.SLOT */ ||
                      hasForwardedSlots(child.children)) {
                      return true;
                  }
                  break;
              case 9 /* NodeTypes.IF */:
                  if (hasForwardedSlots(child.branches))
                      return true;
                  break;
              case 10 /* NodeTypes.IF_BRANCH */:
              case 11 /* NodeTypes.FOR */:
                  if (hasForwardedSlots(child.children))
                      return true;
                  break;
          }
      }
      return false;
  }
  function isNonWhitespaceContent(node) {
      if (node.type !== 2 /* NodeTypes.TEXT */ && node.type !== 12 /* NodeTypes.TEXT_CALL */)
          return true;
      return node.type === 2 /* NodeTypes.TEXT */
          ? !!node.content.trim()
          : isNonWhitespaceContent(node.content);
  }

  // some directive transforms (e.g. v-model) may return a symbol for runtime
  // import, which should be used instead of a resolveDirective call.
  const directiveImportMap = new WeakMap();
  // generate a JavaScript AST for this element's codegen
  const transformElement = (node, context) => {
      // perform the work on exit, after all child expressions have been
      // processed and merged.
      return function postTransformElement() {
          node = context.currentNode;
          if (!(node.type === 1 /* NodeTypes.ELEMENT */ &&
              (node.tagType === 0 /* ElementTypes.ELEMENT */ ||
                  node.tagType === 1 /* ElementTypes.COMPONENT */))) {
              return;
          }
          const { tag, props } = node;
          const isComponent = node.tagType === 1 /* ElementTypes.COMPONENT */;
          // The goal of the transform is to create a codegenNode implementing the
          // VNodeCall interface.
          let vnodeTag = isComponent
              ? resolveComponentType(node, context)
              : `"${tag}"`;
          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = 
          // dynamic component may resolve to plain elements
          isDynamicComponent ||
              vnodeTag === TELEPORT ||
              vnodeTag === SUSPENSE ||
              (!isComponent &&
                  // <svg> and <foreignObject> must be forced into blocks so that block
                  // updates inside get proper isSVG flag at runtime. (#639, #643)
                  // This is technically web-specific, but splitting the logic out of core
                  // leads to too much unnecessary complexity.
                  (tag === 'svg' || tag === 'foreignObject'));
          // props
          if (props.length > 0) {
              const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
              vnodeProps = propsBuildResult.props;
              patchFlag = propsBuildResult.patchFlag;
              dynamicPropNames = propsBuildResult.dynamicPropNames;
              const directives = propsBuildResult.directives;
              vnodeDirectives =
                  directives && directives.length
                      ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                      : undefined;
              if (propsBuildResult.shouldUseBlock) {
                  shouldUseBlock = true;
              }
          }
          // children
          if (node.children.length > 0) {
              if (vnodeTag === KEEP_ALIVE) {
                  // Although a built-in component, we compile KeepAlive with raw children
                  // instead of slot functions so that it can be used inside Transition
                  // or other Transition-wrapping HOCs.
                  // To ensure correct updates with block optimizations, we need to:
                  // 1. Force keep-alive into a block. This avoids its children being
                  //    collected by a parent block.
                  shouldUseBlock = true;
                  // 2. Force keep-alive to always be updated, since it uses raw children.
                  patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                  if (node.children.length > 1) {
                      context.onError(createCompilerError(46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              }
              const shouldBuildAsSlots = isComponent &&
                  // Teleport is not a real component and has dedicated runtime handling
                  vnodeTag !== TELEPORT &&
                  // explained above.
                  vnodeTag !== KEEP_ALIVE;
              if (shouldBuildAsSlots) {
                  const { slots, hasDynamicSlots } = buildSlots(node, context);
                  vnodeChildren = slots;
                  if (hasDynamicSlots) {
                      patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;
                  }
              }
              else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                  const child = node.children[0];
                  const type = child.type;
                  // check for dynamic text children
                  const hasDynamicTextChild = type === 5 /* NodeTypes.INTERPOLATION */ ||
                      type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;
                  if (hasDynamicTextChild &&
                      getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                      patchFlag |= 1 /* PatchFlags.TEXT */;
                  }
                  // pass directly if the only child is a text node
                  // (plain / interpolation / expression)
                  if (hasDynamicTextChild || type === 2 /* NodeTypes.TEXT */) {
                      vnodeChildren = child;
                  }
                  else {
                      vnodeChildren = node.children;
                  }
              }
              else {
                  vnodeChildren = node.children;
              }
          }
          // patchFlag & dynamicPropNames
          if (patchFlag !== 0) {
              {
                  if (patchFlag < 0) {
                      // special flags (negative and mutually exclusive)
                      vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
                  }
                  else {
                      // bitwise flags
                      const flagNames = Object.keys(PatchFlagNames)
                          .map(Number)
                          .filter(n => n > 0 && patchFlag & n)
                          .map(n => PatchFlagNames[n])
                          .join(`, `);
                      vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                  }
              }
              if (dynamicPropNames && dynamicPropNames.length) {
                  vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
              }
          }
          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
      };
  };
  function resolveComponentType(node, context, ssr = false) {
      let { tag } = node;
      // 1. dynamic component
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node, 'is');
      if (isProp) {
          if (isExplicitDynamic ||
              (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {
              const exp = isProp.type === 6 /* NodeTypes.ATTRIBUTE */
                  ? isProp.value && createSimpleExpression(isProp.value.content, true)
                  : isProp.exp;
              if (exp) {
                  return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                      exp
                  ]);
              }
          }
          else if (isProp.type === 6 /* NodeTypes.ATTRIBUTE */ &&
              isProp.value.content.startsWith('vue:')) {
              // <button is="vue:xxx">
              // if not <component>, only is value that starts with "vue:" will be
              // treated as component by the parse phase and reach here, unless it's
              // compat mode where all is values are considered components
              tag = isProp.value.content.slice(4);
          }
      }
      // 1.5 v-is (TODO: Deprecate)
      const isDir = !isExplicitDynamic && findDir(node, 'is');
      if (isDir && isDir.exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              isDir.exp
          ]);
      }
      // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
          // built-ins are simply fallthroughs / have special handling during ssr
          // so we don't need to import their runtime equivalents
          if (!ssr)
              context.helper(builtIn);
          return builtIn;
      }
      // 5. user component (resolve)
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
      const { tag, loc: elementLoc, children } = node;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      // patchFlag analysis
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const pushMergeArg = (arg) => {
          if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
              properties = [];
          }
          if (arg)
              mergeArgs.push(arg);
      };
      const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
              const name = key.content;
              const isEventHandler = isOn(name);
              if (isEventHandler &&
                  (!isComponent || isDynamicComponent) &&
                  // omit the flag for click handlers because hydration gives click
                  // dedicated fast path.
                  name.toLowerCase() !== 'onclick' &&
                  // omit v-model handlers
                  name !== 'onUpdate:modelValue' &&
                  // omit onVnodeXXX hooks
                  !isReservedProp(name)) {
                  hasHydrationEventBinding = true;
              }
              if (isEventHandler && isReservedProp(name)) {
                  hasVnodeHook = true;
              }
              if (value.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */ ||
                  ((value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                      value.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) &&
                      getConstantType(value, context) > 0)) {
                  // skip if the prop is a cached handler or has constant value
                  return;
              }
              if (name === 'ref') {
                  hasRef = true;
              }
              else if (name === 'class') {
                  hasClassBinding = true;
              }
              else if (name === 'style') {
                  hasStyleBinding = true;
              }
              else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                  dynamicPropNames.push(name);
              }
              // treat the dynamic class and style binding of the component as dynamic props
              if (isComponent &&
                  (name === 'class' || name === 'style') &&
                  !dynamicPropNames.includes(name)) {
                  dynamicPropNames.push(name);
              }
          }
          else {
              hasDynamicKeys = true;
          }
      };
      for (let i = 0; i < props.length; i++) {
          // static attribute
          const prop = props[i];
          if (prop.type === 6 /* NodeTypes.ATTRIBUTE */) {
              const { loc, name, value } = prop;
              let isStatic = true;
              if (name === 'ref') {
                  hasRef = true;
                  if (context.scopes.vFor > 0) {
                      properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                  }
              }
              // skip is on <component>, or is="vue:xxx"
              if (name === 'is' &&
                  (isComponentTag(tag) ||
                      (value && value.content.startsWith('vue:')) ||
                      (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context)))) {
                  continue;
              }
              properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
          }
          else {
              // directives
              const { name, arg, exp, loc } = prop;
              const isVBind = name === 'bind';
              const isVOn = name === 'on';
              // skip v-slot - it is handled by its dedicated transform.
              if (name === 'slot') {
                  if (!isComponent) {
                      context.onError(createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, loc));
                  }
                  continue;
              }
              // skip v-once/v-memo - they are handled by dedicated transforms.
              if (name === 'once' || name === 'memo') {
                  continue;
              }
              // skip v-is and :is on <component>
              if (name === 'is' ||
                  (isVBind &&
                      isStaticArgOf(arg, 'is') &&
                      (isComponentTag(tag) ||
                          (isCompatEnabled("COMPILER_IS_ON_ELEMENT" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))))) {
                  continue;
              }
              // skip v-on in SSR compilation
              if (isVOn && ssr) {
                  continue;
              }
              if (
              // #938: elements with dynamic keys should be forced into blocks
              (isVBind && isStaticArgOf(arg, 'key')) ||
                  // inline before-update hooks need to force block so that it is invoked
                  // before children
                  (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                  shouldUseBlock = true;
              }
              if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                  properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
              }
              // special case for v-bind and v-on with no argument
              if (!arg && (isVBind || isVOn)) {
                  hasDynamicKeys = true;
                  if (exp) {
                      if (isVBind) {
                          // have to merge early for compat build check
                          pushMergeArg();
                          {
                              // 2.x v-bind object order compat
                              {
                                  const hasOverridableKeys = mergeArgs.some(arg => {
                                      if (arg.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {
                                          return arg.properties.some(({ key }) => {
                                              if (key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||
                                                  !key.isStatic) {
                                                  return true;
                                              }
                                              return (key.content !== 'class' &&
                                                  key.content !== 'style' &&
                                                  !isOn(key.content));
                                          });
                                      }
                                      else {
                                          // dynamic expression
                                          return true;
                                      }
                                  });
                                  if (hasOverridableKeys) {
                                      checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context, loc);
                                  }
                              }
                              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context)) {
                                  mergeArgs.unshift(exp);
                                  continue;
                              }
                          }
                          mergeArgs.push(exp);
                      }
                      else {
                          // v-on="obj" -> toHandlers(obj)
                          pushMergeArg({
                              type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,
                              loc,
                              callee: context.helper(TO_HANDLERS),
                              arguments: isComponent ? [exp] : [exp, `true`]
                          });
                      }
                  }
                  else {
                      context.onError(createCompilerError(isVBind
                          ? 34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */
                          : 35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
                  }
                  continue;
              }
              const directiveTransform = context.directiveTransforms[name];
              if (directiveTransform) {
                  // has built-in directive transform.
                  const { props, needRuntime } = directiveTransform(prop, node, context);
                  !ssr && props.forEach(analyzePatchFlag);
                  if (isVOn && arg && !isStaticExp(arg)) {
                      pushMergeArg(createObjectExpression(props, elementLoc));
                  }
                  else {
                      properties.push(...props);
                  }
                  if (needRuntime) {
                      runtimeDirectives.push(prop);
                      if (isSymbol(needRuntime)) {
                          directiveImportMap.set(prop, needRuntime);
                      }
                  }
              }
              else if (!isBuiltInDirective(name)) {
                  // no built-in transform, this is a user custom directive.
                  runtimeDirectives.push(prop);
                  // custom dirs may use beforeUpdate so they need to force blocks
                  // to ensure before-update gets called before children update
                  if (hasChildren) {
                      shouldUseBlock = true;
                  }
              }
          }
      }
      let propsExpression = undefined;
      // has v-bind="object" or v-on="object", wrap with mergeProps
      if (mergeArgs.length) {
          // close up any not-yet-merged props
          pushMergeArg();
          if (mergeArgs.length > 1) {
              propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
          }
          else {
              // single v-bind with nothing else - no need for a mergeProps call
              propsExpression = mergeArgs[0];
          }
      }
      else if (properties.length) {
          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      // patchFlag analysis
      if (hasDynamicKeys) {
          patchFlag |= 16 /* PatchFlags.FULL_PROPS */;
      }
      else {
          if (hasClassBinding && !isComponent) {
              patchFlag |= 2 /* PatchFlags.CLASS */;
          }
          if (hasStyleBinding && !isComponent) {
              patchFlag |= 4 /* PatchFlags.STYLE */;
          }
          if (dynamicPropNames.length) {
              patchFlag |= 8 /* PatchFlags.PROPS */;
          }
          if (hasHydrationEventBinding) {
              patchFlag |= 32 /* PatchFlags.HYDRATE_EVENTS */;
          }
      }
      if (!shouldUseBlock &&
          (patchFlag === 0 || patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) &&
          (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512 /* PatchFlags.NEED_PATCH */;
      }
      // pre-normalize props, SSR is skipped for now
      if (!context.inSSR && propsExpression) {
          switch (propsExpression.type) {
              case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:
                  // means that there is no v-bind,
                  // but still need to deal with dynamic key binding
                  let classKeyIndex = -1;
                  let styleKeyIndex = -1;
                  let hasDynamicKey = false;
                  for (let i = 0; i < propsExpression.properties.length; i++) {
                      const key = propsExpression.properties[i].key;
                      if (isStaticExp(key)) {
                          if (key.content === 'class') {
                              classKeyIndex = i;
                          }
                          else if (key.content === 'style') {
                              styleKeyIndex = i;
                          }
                      }
                      else if (!key.isHandlerKey) {
                          hasDynamicKey = true;
                      }
                  }
                  const classProp = propsExpression.properties[classKeyIndex];
                  const styleProp = propsExpression.properties[styleKeyIndex];
                  // no dynamic key
                  if (!hasDynamicKey) {
                      if (classProp && !isStaticExp(classProp.value)) {
                          classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                      }
                      if (styleProp &&
                          // the static style is compiled into an object,
                          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                          (hasStyleBinding ||
                              (styleProp.value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
                                  styleProp.value.content.trim()[0] === `[`) ||
                              // v-bind:style and style both exist,
                              // v-bind:style with static literal object
                              styleProp.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */)) {
                          styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                      }
                  }
                  else {
                      // dynamic key binding, wrap with `normalizeProps`
                      propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                  }
                  break;
              case 14 /* NodeTypes.JS_CALL_EXPRESSION */:
                  // mergeProps call, do nothing
                  break;
              default:
                  // single v-bind
                  propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                      createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                          propsExpression
                      ])
                  ]);
                  break;
          }
      }
      return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames,
          shouldUseBlock
      };
  }
  // Dedupe props in an object literal.
  // Literal duplicated attributes would have been warned during the parse phase,
  // however, it's possible to encounter duplicated `onXXX` handlers with different
  // modifiers. We also need to merge static and dynamic class / style attributes.
  // - onXXX handlers / style: merge into array
  // - class: merge into single expression with concatenation
  function dedupeProperties(properties) {
      const knownProps = new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
          const prop = properties[i];
          // dynamic keys are always allowed
          if (prop.key.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
              deduped.push(prop);
              continue;
          }
          const name = prop.key.content;
          const existing = knownProps.get(name);
          if (existing) {
              if (name === 'style' || name === 'class' || isOn(name)) {
                  mergeAsArray(existing, prop);
              }
              // unexpected duplicate, should have emitted error during parse
          }
          else {
              knownProps.set(name, prop);
              deduped.push(prop);
          }
      }
      return deduped;
  }
  function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {
          existing.value.elements.push(incoming.value);
      }
      else {
          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
  }
  function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
          // built-in directive with runtime
          dirArgs.push(context.helperString(runtime));
      }
      else {
          {
              // inject statement for resolving directive
              context.helper(RESOLVE_DIRECTIVE);
              context.directives.add(dir.name);
              dirArgs.push(toValidAssetId(dir.name, `directive`));
          }
      }
      const { loc } = dir;
      if (dir.exp)
          dirArgs.push(dir.exp);
      if (dir.arg) {
          if (!dir.exp) {
              dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
              if (!dir.exp) {
                  dirArgs.push(`void 0`);
              }
              dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
          propsNamesString += JSON.stringify(props[i]);
          if (i < l - 1)
              propsNamesString += ', ';
      }
      return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
      return tag === 'component' || tag === 'Component';
  }

  const transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context);
          const slotArgs = [
              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
              slotName,
              '{}',
              'undefined',
              'true'
          ];
          let expectedLen = 2;
          if (slotProps) {
              slotArgs[2] = slotProps;
              expectedLen = 3;
          }
          if (children.length) {
              slotArgs[3] = createFunctionExpression([], children, false, false, loc);
              expectedLen = 4;
          }
          if (context.scopeId && !context.slotted) {
              expectedLen = 5;
          }
          slotArgs.splice(expectedLen); // remove unused arguments
          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
  };
  function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = undefined;
      const nonNameProps = [];
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {
              if (p.value) {
                  if (p.name === 'name') {
                      slotName = JSON.stringify(p.value.content);
                  }
                  else {
                      p.name = camelize(p.name);
                      nonNameProps.push(p);
                  }
              }
          }
          else {
              if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                  if (p.exp)
                      slotName = p.exp;
              }
              else {
                  if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                      p.arg.content = camelize(p.arg.content);
                  }
                  nonNameProps.push(p);
              }
          }
      }
      if (nonNameProps.length > 0) {
          const { props, directives } = buildProps(node, context, nonNameProps, false, false);
          slotProps = props;
          if (directives.length) {
              context.onError(createCompilerError(36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
          }
      }
      return {
          slotName,
          slotProps
      };
  }

  const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
  const transformOn$1 = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));
      }
      let eventName;
      if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          if (arg.isStatic) {
              let rawName = arg.content;
              // TODO deprecate @vnodeXXX usage
              if (rawName.startsWith('vue:')) {
                  rawName = `vnode-${rawName.slice(4)}`;
              }
              const eventString = node.tagType !== 0 /* ElementTypes.ELEMENT */ ||
                  rawName.startsWith('vnode') ||
                  !/[A-Z]/.test(rawName)
                  ? // for non-element and vnode lifecycle event listeners, auto convert
                      // it to camelCase. See issue #2249
                      toHandlerKey(camelize(rawName))
                  : // preserve case for plain element listeners that have uppercase
                      // letters, as these may be custom elements' custom events
                      `on:${rawName}`;
              eventName = createSimpleExpression(eventString, true, arg.loc);
          }
          else {
              // #2388
              eventName = createCompoundExpression([
                  `${context.helperString(TO_HANDLER_KEY)}(`,
                  arg,
                  `)`
              ]);
          }
      }
      else {
          // already a compound expression.
          eventName = arg;
          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
      }
      // handler processing
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
          exp = undefined;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
          const isMemberExp = isMemberExpression(exp.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          {
              validateBrowserExpression(exp, context, false, hasMultipleStatements);
          }
          if (isInlineStatement || (shouldCache && isMemberExp)) {
              // wrap inline statement in a function expression
              exp = createCompoundExpression([
                  `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                  exp,
                  hasMultipleStatements ? `}` : `)`
              ]);
          }
      }
      let ret = {
          props: [
              createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
      };
      // apply extended compiler augmentor
      if (augmentor) {
          ret = augmentor(ret);
      }
      if (shouldCache) {
          // cache handlers so that it's always the same handler being passed down.
          // this avoids unnecessary re-renders when users use inline handlers on
          // components.
          ret.props[0].value = context.cache(ret.props[0].value);
      }
      // mark the key as handler for props normalization check
      ret.props.forEach(p => (p.key.isHandlerKey = true));
      return ret;
  };

  // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
  // codegen for the entire props object. This transform here is only for v-bind
  // *with* args.
  const transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
      }
      else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
      }
      // .sync is replaced by v-model:arg
      if (modifiers.includes('camel')) {
          if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
              if (arg.isStatic) {
                  arg.content = camelize(arg.content);
              }
              else {
                  arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
              }
          }
          else {
              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
              arg.children.push(`)`);
          }
      }
      if (!context.inSSR) {
          if (modifiers.includes('prop')) {
              injectPrefix(arg, '.');
          }
          if (modifiers.includes('attr')) {
              injectPrefix(arg, '^');
          }
      }
      if (!exp ||
          (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !exp.content.trim())) {
          context.onError(createCompilerError(34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */, loc));
          return {
              props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
          };
      }
      return {
          props: [createObjectProperty(arg, exp)]
      };
  };
  const injectPrefix = (arg, prefix) => {
      if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          if (arg.isStatic) {
              arg.content = prefix + arg.content;
          }
          else {
              arg.content = `\`${prefix}\${${arg.content}}\``;
          }
      }
      else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
      }
  };

  // Merge adjacent text nodes and expressions into a single expression
  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
  const transformText = (node, context) => {
      if (node.type === 0 /* NodeTypes.ROOT */ ||
          node.type === 1 /* NodeTypes.ELEMENT */ ||
          node.type === 11 /* NodeTypes.FOR */ ||
          node.type === 10 /* NodeTypes.IF_BRANCH */) {
          // perform the transform on node exit so that all expressions have already
          // been processed.
          return () => {
              const children = node.children;
              let currentContainer = undefined;
              let hasText = false;
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText$1(child)) {
                      hasText = true;
                      for (let j = i + 1; j < children.length; j++) {
                          const next = children[j];
                          if (isText$1(next)) {
                              if (!currentContainer) {
                                  currentContainer = children[i] = createCompoundExpression([child], child.loc);
                              }
                              // merge adjacent text node into current
                              currentContainer.children.push(` + `, next);
                              children.splice(j, 1);
                              j--;
                          }
                          else {
                              currentContainer = undefined;
                              break;
                          }
                      }
                  }
              }
              if (!hasText ||
                  // if this is a plain element with a single text child, leave it
                  // as-is since the runtime has dedicated fast path for this by directly
                  // setting textContent of the element.
                  // for component root it's always normalized anyway.
                  (children.length === 1 &&
                      (node.type === 0 /* NodeTypes.ROOT */ ||
                          (node.type === 1 /* NodeTypes.ELEMENT */ &&
                              node.tagType === 0 /* ElementTypes.ELEMENT */ &&
                              // #3756
                              // custom directives can potentially add DOM elements arbitrarily,
                              // we need to avoid setting textContent of the element at runtime
                              // to avoid accidentally overwriting the DOM elements added
                              // by the user through custom directives.
                              !node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&
                                  !context.directiveTransforms[p.name]) &&
                              // in compat mode, <template> tags with no special directives
                              // will be rendered as a fragment so its children must be
                              // converted into vnodes.
                              !(node.tag === 'template'))))) {
                  return;
              }
              // pre-convert text nodes into createTextVNode(text) calls to avoid
              // runtime normalization.
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText$1(child) || child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                      const callArgs = [];
                      // createTextVNode defaults to single whitespace, so if it is a
                      // single space the code could be an empty call to save bytes.
                      if (child.type !== 2 /* NodeTypes.TEXT */ || child.content !== ' ') {
                          callArgs.push(child);
                      }
                      // mark dynamic text with flag so it gets patched inside a block
                      if (!context.ssr &&
                          getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {
                          callArgs.push(1 /* PatchFlags.TEXT */ +
                              (` /* ${PatchFlagNames[1 /* PatchFlags.TEXT */]} */` ));
                      }
                      children[i] = {
                          type: 12 /* NodeTypes.TEXT_CALL */,
                          content: child,
                          loc: child.loc,
                          codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                      };
                  }
              }
          };
      }
  };

  const seen$1 = new WeakSet();
  const transformOnce = (node, context) => {
      if (node.type === 1 /* NodeTypes.ELEMENT */ && findDir(node, 'once', true)) {
          if (seen$1.has(node) || context.inVOnce) {
              return;
          }
          seen$1.add(node);
          context.inVOnce = true;
          context.helper(SET_BLOCK_TRACKING);
          return () => {
              context.inVOnce = false;
              const cur = context.currentNode;
              if (cur.codegenNode) {
                  cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
              }
          };
      }
  };

  const transformModel$1 = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
          context.onError(createCompilerError(41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */, dir.loc));
          return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? exp.content : rawExp;
      // im SFC <script setup> inline mode, the exp may have been transformed into
      // _unref(exp)
      const bindingType = context.bindingMetadata[rawExp];
      // check props
      if (bindingType === "props" /* BindingTypes.PROPS */ ||
          bindingType === "props-aliased" /* BindingTypes.PROPS_ALIASED */) {
          context.onError(createCompilerError(44 /* ErrorCodes.X_V_MODEL_ON_PROPS */, exp.loc));
          return createTransformProps();
      }
      const maybeRef = !true  ;
      if (!expString.trim() ||
          (!isMemberExpression(expString) && !maybeRef)) {
          context.onError(createCompilerError(42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
          return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression('modelValue', true);
      const eventName = arg
          ? isStaticExp(arg)
              ? `onUpdate:${camelize(arg.content)}`
              : createCompoundExpression(['"onUpdate:" + ', arg])
          : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
          assignmentExp = createCompoundExpression([
              `${eventArg} => ((`,
              exp,
              `) = $event)`
          ]);
      }
      const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, assignmentExp)
      ];
      // modelModifiers: { foo: true, "bar-baz": true }
      if (dir.modifiers.length && node.tagType === 1 /* ElementTypes.COMPONENT */) {
          const modifiers = dir.modifiers
              .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
              .join(`, `);
          const modifiersKey = arg
              ? isStaticExp(arg)
                  ? `${arg.content}Modifiers`
                  : createCompoundExpression([arg, ' + "Modifiers"'])
              : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* ConstantTypes.CAN_HOIST */)));
      }
      return createTransformProps(props);
  };
  function createTransformProps(props = []) {
      return { props };
  }

  const validDivisionCharRE = /[\w).+\-_$\]]/;
  const transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context)) {
          return;
      }
      if (node.type === 5 /* NodeTypes.INTERPOLATION */) {
          // filter rewrite is applied before expression transform so only
          // simple expressions are possible at this stage
          rewriteFilter(node.content, context);
      }
      if (node.type === 1 /* NodeTypes.ELEMENT */) {
          node.props.forEach((prop) => {
              if (prop.type === 7 /* NodeTypes.DIRECTIVE */ &&
                  prop.name !== 'for' &&
                  prop.exp) {
                  rewriteFilter(prop.exp, context);
              }
          });
      }
  };
  function rewriteFilter(node, context) {
      if (node.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
          parseFilter(node, context);
      }
      else {
          for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              if (typeof child !== 'object')
                  continue;
              if (child.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {
                  parseFilter(child, context);
              }
              else if (child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {
                  rewriteFilter(node, context);
              }
              else if (child.type === 5 /* NodeTypes.INTERPOLATION */) {
                  rewriteFilter(child.content, context);
              }
          }
      }
  }
  function parseFilter(node, context) {
      const exp = node.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c, prev, i, expression, filters = [];
      for (i = 0; i < exp.length; i++) {
          prev = c;
          c = exp.charCodeAt(i);
          if (inSingle) {
              if (c === 0x27 && prev !== 0x5c)
                  inSingle = false;
          }
          else if (inDouble) {
              if (c === 0x22 && prev !== 0x5c)
                  inDouble = false;
          }
          else if (inTemplateString) {
              if (c === 0x60 && prev !== 0x5c)
                  inTemplateString = false;
          }
          else if (inRegex) {
              if (c === 0x2f && prev !== 0x5c)
                  inRegex = false;
          }
          else if (c === 0x7c && // pipe
              exp.charCodeAt(i + 1) !== 0x7c &&
              exp.charCodeAt(i - 1) !== 0x7c &&
              !curly &&
              !square &&
              !paren) {
              if (expression === undefined) {
                  // first filter, end of expression
                  lastFilterIndex = i + 1;
                  expression = exp.slice(0, i).trim();
              }
              else {
                  pushFilter();
              }
          }
          else {
              switch (c) {
                  case 0x22:
                      inDouble = true;
                      break; // "
                  case 0x27:
                      inSingle = true;
                      break; // '
                  case 0x60:
                      inTemplateString = true;
                      break; // `
                  case 0x28:
                      paren++;
                      break; // (
                  case 0x29:
                      paren--;
                      break; // )
                  case 0x5b:
                      square++;
                      break; // [
                  case 0x5d:
                      square--;
                      break; // ]
                  case 0x7b:
                      curly++;
                      break; // {
                  case 0x7d:
                      curly--;
                      break; // }
              }
              if (c === 0x2f) {
                  // /
                  let j = i - 1;
                  let p;
                  // find first non-whitespace prev char
                  for (; j >= 0; j--) {
                      p = exp.charAt(j);
                      if (p !== ' ')
                          break;
                  }
                  if (!p || !validDivisionCharRE.test(p)) {
                      inRegex = true;
                  }
              }
          }
      }
      if (expression === undefined) {
          expression = exp.slice(0, i).trim();
      }
      else if (lastFilterIndex !== 0) {
          pushFilter();
      }
      function pushFilter() {
          filters.push(exp.slice(lastFilterIndex, i).trim());
          lastFilterIndex = i + 1;
      }
      if (filters.length) {
          warnDeprecation("COMPILER_FILTER" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context, node.loc);
          for (i = 0; i < filters.length; i++) {
              expression = wrapFilter(expression, filters[i], context);
          }
          node.content = expression;
      }
  }
  function wrapFilter(exp, filter, context) {
      context.helper(RESOLVE_FILTER);
      const i = filter.indexOf('(');
      if (i < 0) {
          context.filters.add(filter);
          return `${toValidAssetId(filter, 'filter')}(${exp})`;
      }
      else {
          const name = filter.slice(0, i);
          const args = filter.slice(i + 1);
          context.filters.add(name);
          return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;
      }
  }

  const seen = new WeakSet();
  const transformMemo = (node, context) => {
      if (node.type === 1 /* NodeTypes.ELEMENT */) {
          const dir = findDir(node, 'memo');
          if (!dir || seen.has(node)) {
              return;
          }
          seen.add(node);
          return () => {
              const codegenNode = node.codegenNode ||
                  context.currentNode.codegenNode;
              if (codegenNode && codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {
                  // non-component sub tree should be turned into a block
                  if (node.tagType !== 1 /* ElementTypes.COMPONENT */) {
                      makeBlock(codegenNode, context);
                  }
                  node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                      dir.exp,
                      createFunctionExpression(undefined, codegenNode),
                      `_cache`,
                      String(context.cached++)
                  ]);
              }
          };
      }
  };

  function getBaseTransformPreset(prefixIdentifiers) {
      return [
          [
              transformOnce,
              transformIf,
              transformMemo,
              transformFor,
              ...([transformFilter] ),
              ...([transformExpression]
                      ),
              transformSlotOutlet,
              transformElement,
              trackSlotScopes,
              transformText
          ],
          {
              on: transformOn$1,
              bind: transformBind,
              model: transformModel$1
          }
      ];
  }
  // we name it `baseCompile` so that higher order compilers like
  // @vue/compiler-dom can export `compile` while re-exporting everything else.
  function baseCompile(template, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === 'module';
      /* istanbul ignore if */
      {
          if (options.prefixIdentifiers === true) {
              onError(createCompilerError(47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */));
          }
          else if (isModuleMode) {
              onError(createCompilerError(48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */));
          }
      }
      const prefixIdentifiers = !true ;
      if (options.cacheHandlers) {
          onError(createCompilerError(49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */));
      }
      if (options.scopeId && !isModuleMode) {
          onError(createCompilerError(50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */));
      }
      const ast = isString(template) ? baseParse(template, options) : template;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
      transform(ast, extend({}, options, {
          prefixIdentifiers,
          nodeTransforms: [
              ...nodeTransforms,
              ...(options.nodeTransforms || []) // user transforms
          ],
          directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms
          )
      }));
      return generate(ast, extend({}, options, {
          prefixIdentifiers
      }));
  }

  const noopDirectiveTransform = () => ({ props: [] });

  const V_MODEL_RADIO = Symbol(`vModelRadio` );
  const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );
  const V_MODEL_TEXT = Symbol(`vModelText` );
  const V_MODEL_SELECT = Symbol(`vModelSelect` );
  const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );
  const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );
  const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );
  const V_SHOW = Symbol(`vShow` );
  const TRANSITION = Symbol(`Transition` );
  const TRANSITION_GROUP = Symbol(`TransitionGroup` );
  registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
  });

  /* eslint-disable no-restricted-globals */
  let decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
      if (!decoder) {
          decoder = document.createElement('div');
      }
      if (asAttr) {
          decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
          return decoder.children[0].getAttribute('foo');
      }
      else {
          decoder.innerHTML = raw;
          return decoder.textContent;
      }
  }

  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
  const parserOptions = {
      isVoidTag,
      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: tag => tag === 'pre',
      decodeEntities: decodeHtmlBrowser ,
      isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
              return TRANSITION;
          }
          else if (isBuiltInType(tag, `TransitionGroup`)) {
              return TRANSITION_GROUP;
          }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;
          if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                  if (tag === 'svg') {
                      return 1 /* DOMNamespaces.SVG */;
                  }
                  if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                          a.value.content === 'application/xhtml+xml'))) {
                      ns = 0 /* DOMNamespaces.HTML */;
                  }
              }
              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                  tag !== 'mglyph' &&
                  tag !== 'malignmark') {
                  ns = 0 /* DOMNamespaces.HTML */;
              }
          }
          else if (parent && ns === 1 /* DOMNamespaces.SVG */) {
              if (parent.tag === 'foreignObject' ||
                  parent.tag === 'desc' ||
                  parent.tag === 'title') {
                  ns = 0 /* DOMNamespaces.HTML */;
              }
          }
          if (ns === 0 /* DOMNamespaces.HTML */) {
              if (tag === 'svg') {
                  return 1 /* DOMNamespaces.SVG */;
              }
              if (tag === 'math') {
                  return 2 /* DOMNamespaces.MATH_ML */;
              }
          }
          return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
          if (ns === 0 /* DOMNamespaces.HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                  return 1 /* TextModes.RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                  return 2 /* TextModes.RAWTEXT */;
              }
          }
          return 0 /* TextModes.DATA */;
      }
  };

  // Parse inline CSS strings for static style attributes into an object.
  // This is a NodeTransform since it works on the static `style` attribute and
  // converts it into a dynamic equivalent:
  // style="color: red" -> :style='{ "color": "red" }'
  // It is then processed by `transformElement` and included in the generated
  // props.
  const transformStyle = node => {
      if (node.type === 1 /* NodeTypes.ELEMENT */) {
          node.props.forEach((p, i) => {
              if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {
                  // replace p with an expression node
                  node.props[i] = {
                      type: 7 /* NodeTypes.DIRECTIVE */,
                      name: `bind`,
                      arg: createSimpleExpression(`style`, true, p.loc),
                      exp: parseInlineCSS(p.value.content, p.loc),
                      modifiers: [],
                      loc: p.loc
                  };
              }
          });
      }
  };
  const parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);
  };

  function createDOMCompilerError(code, loc) {
      return createCompilerError(code, loc, DOMErrorMessages );
  }
  const DOMErrorMessages = {
      [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
      [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
      [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
      [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
      [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
      [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
      [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
      [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
          ]
      };
  };

  const transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`textContent`, true), exp
                  ? getConstantType(exp, context) > 0
                      ? exp
                      : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
                  : createSimpleExpression('', true))
          ]
      };
  };

  const transformModel = (dir, node, context) => {
      const baseResult = transformModel$1(dir, node, context);
      // base transform has errors OR component v-model (only need props)
      if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {
          return baseResult;
      }
      if (dir.arg) {
          context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
      }
      function checkDuplicatedValue() {
          const value = findProp(node, 'value');
          if (value) {
              context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
          }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === 'input' ||
          tag === 'textarea' ||
          tag === 'select' ||
          isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === 'input' || isCustomElement) {
              const type = findProp(node, `type`);
              if (type) {
                  if (type.type === 7 /* NodeTypes.DIRECTIVE */) {
                      // :type="foo"
                      directiveToUse = V_MODEL_DYNAMIC;
                  }
                  else if (type.value) {
                      switch (type.value.content) {
                          case 'radio':
                              directiveToUse = V_MODEL_RADIO;
                              break;
                          case 'checkbox':
                              directiveToUse = V_MODEL_CHECKBOX;
                              break;
                          case 'file':
                              isInvalidType = true;
                              context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                              break;
                          default:
                              // text type
                              checkDuplicatedValue();
                              break;
                      }
                  }
              }
              else if (hasDynamicKeyVBind(node)) {
                  // element has bindings with dynamic keys, which can possibly contain
                  // "type".
                  directiveToUse = V_MODEL_DYNAMIC;
              }
              else {
                  // text type
                  checkDuplicatedValue();
              }
          }
          else if (tag === 'select') {
              directiveToUse = V_MODEL_SELECT;
          }
          else {
              // textarea
              checkDuplicatedValue();
          }
          // inject runtime directive
          // by returning the helper symbol via needRuntime
          // the import will replaced a resolveDirective call.
          if (!isInvalidType) {
              baseResult.needRuntime = context.helper(directiveToUse);
          }
      }
      else {
          context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
      }
      // native vmodel doesn't need the `modelValue` props since they are also
      // passed to the runtime as `binding.value`. removing it reduces code size.
      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&
          p.key.content === 'modelValue'));
      return baseResult;
  };

  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
`stop,prevent,self,`   +
      // system modifiers + exact
      `ctrl,shift,alt,meta,exact,` +
      // mouse
      `middle`);
  // left & right could be mouse or key modifiers based on event type
  const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
  const resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (modifier === 'native' &&
              checkCompatEnabled("COMPILER_V_ON_NATIVE" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {
              eventOptionModifiers.push(modifier);
          }
          else if (isEventOptionModifier(modifier)) {
              // eventOptionModifiers: modifiers for addEventListener() options,
              // e.g. .passive & .capture
              eventOptionModifiers.push(modifier);
          }
          else {
              // runtimeModifiers: modifiers that needs runtime guards
              if (maybeKeyModifier(modifier)) {
                  if (isStaticExp(key)) {
                      if (isKeyboardEvent(key.content)) {
                          keyModifiers.push(modifier);
                      }
                      else {
                          nonKeyModifiers.push(modifier);
                      }
                  }
                  else {
                      keyModifiers.push(modifier);
                      nonKeyModifiers.push(modifier);
                  }
              }
              else {
                  if (isNonKeyModifier(modifier)) {
                      nonKeyModifiers.push(modifier);
                  }
                  else {
                      keyModifiers.push(modifier);
                  }
              }
          }
      }
      return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
      };
  };
  const transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
      return isStaticClick
          ? createSimpleExpression(event, true)
          : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */
              ? createCompoundExpression([
                  `(`,
                  key,
                  `) === "onClick" ? "${event}" : (`,
                  key,
                  `)`
              ])
              : key;
  };
  const transformOn = (dir, node, context) => {
      return transformOn$1(dir, node, context, baseResult => {
          const { modifiers } = dir;
          if (!modifiers.length)
              return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
          // normalize click.right and click.middle since they don't actually fire
          if (nonKeyModifiers.includes('right')) {
              key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes('middle')) {
              key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                  handlerExp,
                  JSON.stringify(nonKeyModifiers)
              ]);
          }
          if (keyModifiers.length &&
              // if event name is dynamic, always wrap with keys guard
              (!isStaticExp(key) || isKeyboardEvent(key.content))) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                  handlerExp,
                  JSON.stringify(keyModifiers)
              ]);
          }
          if (eventOptionModifiers.length) {
              const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
              key = isStaticExp(key)
                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                  : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
              props: [createObjectProperty(key, handlerExp)]
          };
      });
  };

  const transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));
      }
      return {
          props: [],
          needRuntime: context.helper(V_SHOW)
      };
  };

  const transformTransition = (node, context) => {
      if (node.type === 1 /* NodeTypes.ELEMENT */ &&
          node.tagType === 1 /* ElementTypes.COMPONENT */) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
              return () => {
                  if (!node.children.length) {
                      return;
                  }
                  // warn multiple transition children
                  if (hasMultipleChildren(node)) {
                      context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
                  // check if it's s single child w/ v-show
                  // if yes, inject "persisted: true" to the transition props
                  const child = node.children[0];
                  if (child.type === 1 /* NodeTypes.ELEMENT */) {
                      for (const p of child.props) {
                          if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {
                              node.props.push({
                                  type: 6 /* NodeTypes.ATTRIBUTE */,
                                  name: 'persisted',
                                  value: undefined,
                                  loc: node.loc
                              });
                          }
                      }
                  }
              };
          }
      }
  };
  function hasMultipleChildren(node) {
      // #1352 filter out potential comment nodes.
      const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&
          !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));
      const child = children[0];
      return (children.length !== 1 ||
          child.type === 11 /* NodeTypes.FOR */ ||
          (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));
  }

  const ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 /* NodeTypes.ELEMENT */ &&
          node.tagType === 0 /* ElementTypes.ELEMENT */ &&
          (node.tag === 'script' || node.tag === 'style')) {
          context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
          context.removeNode();
      }
  };

  const DOMNodeTransforms = [
      transformStyle,
      ...([transformTransition] )
  ];
  const DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel,
      on: transformOn,
      show: transformShow
  };
  function compile(template, options = {}) {
      return baseCompile(template, extend({}, parserOptions, options, {
          nodeTransforms: [
              // ignore <script> and <tag>
              // this is not put inside DOMNodeTransforms because that list is used
              // by compiler-ssr to generate vnode fallback branches
              ignoreSideEffectTags,
              ...DOMNodeTransforms,
              ...(options.nodeTransforms || [])
          ],
          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
          transformHoist: null 
      }));
  }
  function parse(template, options = {}) {
      return baseParse(template, extend({}, parserOptions, options));
  }

  exports.BASE_TRANSITION = BASE_TRANSITION;
  exports.CAMELIZE = CAMELIZE;
  exports.CAPITALIZE = CAPITALIZE;
  exports.CREATE_BLOCK = CREATE_BLOCK;
  exports.CREATE_COMMENT = CREATE_COMMENT;
  exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
  exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
  exports.CREATE_SLOTS = CREATE_SLOTS;
  exports.CREATE_STATIC = CREATE_STATIC;
  exports.CREATE_TEXT = CREATE_TEXT;
  exports.CREATE_VNODE = CREATE_VNODE;
  exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
  exports.DOMNodeTransforms = DOMNodeTransforms;
  exports.FRAGMENT = FRAGMENT;
  exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
  exports.IS_MEMO_SAME = IS_MEMO_SAME;
  exports.IS_REF = IS_REF;
  exports.KEEP_ALIVE = KEEP_ALIVE;
  exports.MERGE_PROPS = MERGE_PROPS;
  exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
  exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
  exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
  exports.OPEN_BLOCK = OPEN_BLOCK;
  exports.POP_SCOPE_ID = POP_SCOPE_ID;
  exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
  exports.RENDER_LIST = RENDER_LIST;
  exports.RENDER_SLOT = RENDER_SLOT;
  exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
  exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
  exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
  exports.RESOLVE_FILTER = RESOLVE_FILTER;
  exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
  exports.SUSPENSE = SUSPENSE;
  exports.TELEPORT = TELEPORT;
  exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
  exports.TO_HANDLERS = TO_HANDLERS;
  exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
  exports.TRANSITION = TRANSITION;
  exports.TRANSITION_GROUP = TRANSITION_GROUP;
  exports.UNREF = UNREF;
  exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
  exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
  exports.V_MODEL_RADIO = V_MODEL_RADIO;
  exports.V_MODEL_SELECT = V_MODEL_SELECT;
  exports.V_MODEL_TEXT = V_MODEL_TEXT;
  exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
  exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
  exports.V_SHOW = V_SHOW;
  exports.WITH_CTX = WITH_CTX;
  exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
  exports.WITH_MEMO = WITH_MEMO;
  exports.advancePositionWithClone = advancePositionWithClone;
  exports.advancePositionWithMutation = advancePositionWithMutation;
  exports.assert = assert;
  exports.baseCompile = baseCompile;
  exports.baseParse = baseParse;
  exports.buildDirectiveArgs = buildDirectiveArgs;
  exports.buildProps = buildProps;
  exports.buildSlots = buildSlots;
  exports.checkCompatEnabled = checkCompatEnabled;
  exports.compile = compile;
  exports.createArrayExpression = createArrayExpression;
  exports.createAssignmentExpression = createAssignmentExpression;
  exports.createBlockStatement = createBlockStatement;
  exports.createCacheExpression = createCacheExpression;
  exports.createCallExpression = createCallExpression;
  exports.createCompilerError = createCompilerError;
  exports.createCompoundExpression = createCompoundExpression;
  exports.createConditionalExpression = createConditionalExpression;
  exports.createDOMCompilerError = createDOMCompilerError;
  exports.createForLoopParams = createForLoopParams;
  exports.createFunctionExpression = createFunctionExpression;
  exports.createIfStatement = createIfStatement;
  exports.createInterpolation = createInterpolation;
  exports.createObjectExpression = createObjectExpression;
  exports.createObjectProperty = createObjectProperty;
  exports.createReturnStatement = createReturnStatement;
  exports.createRoot = createRoot;
  exports.createSequenceExpression = createSequenceExpression;
  exports.createSimpleExpression = createSimpleExpression;
  exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
  exports.createTemplateLiteral = createTemplateLiteral;
  exports.createTransformContext = createTransformContext;
  exports.createVNodeCall = createVNodeCall;
  exports.extractIdentifiers = extractIdentifiers;
  exports.findDir = findDir;
  exports.findProp = findProp;
  exports.generate = generate;
  exports.generateCodeFrame = generateCodeFrame;
  exports.getBaseTransformPreset = getBaseTransformPreset;
  exports.getConstantType = getConstantType;
  exports.getInnerRange = getInnerRange;
  exports.getMemoedVNodeCall = getMemoedVNodeCall;
  exports.getVNodeBlockHelper = getVNodeBlockHelper;
  exports.getVNodeHelper = getVNodeHelper;
  exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
  exports.hasScopeRef = hasScopeRef;
  exports.helperNameMap = helperNameMap;
  exports.injectProp = injectProp;
  exports.isBuiltInType = isBuiltInType;
  exports.isCoreComponent = isCoreComponent;
  exports.isFunctionType = isFunctionType;
  exports.isInDestructureAssignment = isInDestructureAssignment;
  exports.isMemberExpression = isMemberExpression;
  exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
  exports.isMemberExpressionNode = isMemberExpressionNode;
  exports.isReferencedIdentifier = isReferencedIdentifier;
  exports.isSimpleIdentifier = isSimpleIdentifier;
  exports.isSlotOutlet = isSlotOutlet;
  exports.isStaticArgOf = isStaticArgOf;
  exports.isStaticExp = isStaticExp;
  exports.isStaticProperty = isStaticProperty;
  exports.isStaticPropertyKey = isStaticPropertyKey;
  exports.isTemplateNode = isTemplateNode;
  exports.isText = isText$1;
  exports.isVSlot = isVSlot;
  exports.locStub = locStub;
  exports.makeBlock = makeBlock;
  exports.noopDirectiveTransform = noopDirectiveTransform;
  exports.parse = parse;
  exports.parserOptions = parserOptions;
  exports.processExpression = processExpression;
  exports.processFor = processFor;
  exports.processIf = processIf;
  exports.processSlotOutlet = processSlotOutlet;
  exports.registerRuntimeHelpers = registerRuntimeHelpers;
  exports.resolveComponentType = resolveComponentType;
  exports.stringifyExpression = stringifyExpression;
  exports.toValidAssetId = toValidAssetId;
  exports.trackSlotScopes = trackSlotScopes;
  exports.trackVForSlotScopes = trackVForSlotScopes;
  exports.transform = transform;
  exports.transformBind = transformBind;
  exports.transformElement = transformElement;
  exports.transformExpression = transformExpression;
  exports.transformModel = transformModel$1;
  exports.transformOn = transformOn$1;
  exports.transformStyle = transformStyle;
  exports.traverseNode = traverseNode;
  exports.walkBlockDeclarations = walkBlockDeclarations;
  exports.walkFunctionParams = walkFunctionParams;
  exports.walkIdentifiers = walkIdentifiers;
  exports.warnDeprecation = warnDeprecation;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
