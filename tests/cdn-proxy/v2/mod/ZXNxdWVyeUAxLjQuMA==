¸/dist/esquery.esm.min.jsÅˆ'function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,a=!1,o=void 0;try{for(var i,s=e[Symbol.iterator]();!(n=(i=s.next()).done)&&(r.push(i.value),!t||r.length!==t);n=!0);}catch(e){a=!0,o=e}finally{try{n||null==s.return||s.return()}finally{if(a)throw o}}return r}(e,t)||n(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function r(e){return function(e){if(Array.isArray(e))return a(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||n(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(e,t){if(e){if("string"==typeof e)return a(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?a(e,t):void 0}}function a(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function o(e,t){var r;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=n(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s=!0,l=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return s=e.done,e},e:function(e){l=!0,i=e},f:function(){try{s||null==r.return||r.return()}finally{if(l)throw i}}}}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function i(e,t){return e(t={exports:{}},t.exports),t.exports}var s=i((function(e,t){!function e(t){var r,n,a,o,i,s;function l(e){var t,r,n={};for(t in e)e.hasOwnProperty(t)&&(r=e[t],n[t]="object"==typeof r&&null!==r?l(r):r);return n}function u(e,t){this.parent=e,this.key=t}function c(e,t,r,n){this.node=e,this.path=t,this.wrap=r,this.ref=n}function f(){}function p(e){return null!=e&&("object"==typeof e&&"string"==typeof e.type)}function h(e,t){return(e===r.ObjectExpression||e===r.ObjectPattern)&&"properties"===t}function y(e,t){for(var r=e.length-1;r>=0;--r)if(e[r].node===t)return!0;return!1}function d(e,t){return(new f).traverse(e,t)}function m(e,t){var r;return r=function(e,t){var r,n,a,o;for(n=e.length,a=0;n;)t(e[o=a+(r=n>>>1)])?n=r:(a=o+1,n-=r+1);return a}(t,(function(t){return t.range[0]>e.range[0]})),e.extendedRange=[e.range[0],e.range[1]],r!==t.length&&(e.extendedRange[1]=t[r].range[0]),(r-=1)>=0&&(e.extendedRange[0]=t[r].range[1]),e}return r={AssignmentExpression:"AssignmentExpression",AssignmentPattern:"AssignmentPattern",ArrayExpression:"ArrayExpression",ArrayPattern:"ArrayPattern",ArrowFunctionExpression:"ArrowFunctionExpression",AwaitExpression:"AwaitExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ChainExpression:"ChainExpression",ClassBody:"ClassBody",ClassDeclaration:"ClassDeclaration",ClassExpression:"ClassExpression",ComprehensionBlock:"ComprehensionBlock",ComprehensionExpression:"ComprehensionExpression",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DebuggerStatement:"DebuggerStatement",DirectiveStatement:"DirectiveStatement",DoWhileStatement:"DoWhileStatement",EmptyStatement:"EmptyStatement",ExportAllDeclaration:"ExportAllDeclaration",ExportDefaultDeclaration:"ExportDefaultDeclaration",ExportNamedDeclaration:"ExportNamedDeclaration",ExportSpecifier:"ExportSpecifier",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",ForOfStatement:"ForOfStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",GeneratorExpression:"GeneratorExpression",Identifier:"Identifier",IfStatement:"IfStatement",ImportExpression:"ImportExpression",ImportDeclaration:"ImportDeclaration",ImportDefaultSpecifier:"ImportDefaultSpecifier",ImportNamespaceSpecifier:"ImportNamespaceSpecifier",ImportSpecifier:"ImportSpecifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",MetaProperty:"MetaProperty",MethodDefinition:"MethodDefinition",ModuleSpecifier:"ModuleSpecifier",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",ObjectPattern:"ObjectPattern",Program:"Program",Property:"Property",RestElement:"RestElement",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SpreadElement:"SpreadElement",Super:"Super",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",TaggedTemplateExpression:"TaggedTemplateExpression",TemplateElement:"TemplateElement",TemplateLiteral:"TemplateLiteral",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement",YieldExpression:"YieldExpression"},a={AssignmentExpression:["left","right"],AssignmentPattern:["left","right"],ArrayExpression:["elements"],ArrayPattern:["elements"],ArrowFunctionExpression:["params","body"],AwaitExpression:["argument"],BlockStatement:["body"],BinaryExpression:["left","right"],BreakStatement:["label"],CallExpression:["callee","arguments"],CatchClause:["param","body"],ChainExpression:["expression"],ClassBody:["body"],ClassDeclaration:["id","superClass","body"],ClassExpression:["id","superClass","body"],ComprehensionBlock:["left","right"],ComprehensionExpression:["blocks","filter","body"],ConditionalExpression:["test","consequent","alternate"],ContinueStatement:["label"],DebuggerStatement:[],DirectiveStatement:[],DoWhileStatement:["body","test"],EmptyStatement:[],ExportAllDeclaration:["source"],ExportDefaultDeclaration:["declaration"],ExportNamedDeclaration:["declaration","specifiers","source"],ExportSpecifier:["exported","local"],ExpressionStatement:["expression"],ForStatement:["init","test","update","body"],ForInStatement:["left","right","body"],ForOfStatement:["left","right","body"],FunctionDeclaration:["id","params","body"],FunctionExpression:["id","params","body"],GeneratorExpression:["blocks","filter","body"],Identifier:[],IfStatement:["test","consequent","alternate"],ImportExpression:["source"],ImportDeclaration:["specifiers","source"],ImportDefaultSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportSpecifier:["imported","local"],Literal:[],LabeledStatement:["label","body"],LogicalExpression:["left","right"],MemberExpression:["object","property"],MetaProperty:["meta","property"],MethodDefinition:["key","value"],ModuleSpecifier:[],NewExpression:["callee","arguments"],ObjectExpression:["properties"],ObjectPattern:["properties"],Program:["body"],Property:["key","value"],RestElement:["argument"],ReturnStatement:["argument"],SequenceExpression:["expressions"],SpreadElement:["argument"],Super:[],SwitchStatement:["discriminant","cases"],SwitchCase:["test","consequent"],TaggedTemplateExpression:["tag","quasi"],TemplateElement:[],TemplateLiteral:["quasis","expressions"],ThisExpression:[],ThrowStatement:["argument"],TryStatement:["block","handler","finalizer"],UnaryExpression:["argument"],UpdateExpression:["argument"],VariableDeclaration:["declarations"],VariableDeclarator:["id","init"],WhileStatement:["test","body"],WithStatement:["object","body"],YieldExpression:["argument"]},n={Break:o={},Skip:i={},Remove:s={}},u.prototype.replace=function(e){this.parent[this.key]=e},u.prototype.remove=function(){return Array.isArray(this.parent)?(this.parent.splice(this.key,1),!0):(this.replace(null),!1)},f.prototype.path=function(){var e,t,r,n,a;function o(e,t){if(Array.isArray(t))for(r=0,n=t.length;r<n;++r)e.push(t[r]);else e.push(t)}if(!this.__current.path)return null;for(a=[],e=2,t=this.__leavelist.length;e<t;++e)o(a,this.__leavelist[e].path);return o(a,this.__current.path),a},f.prototype.type=function(){return this.current().type||this.__current.wrap},f.prototype.parents=function(){var e,t,r;for(r=[],e=1,t=this.__leavelist.length;e<t;++e)r.push(this.__leavelist[e].node);return r},f.prototype.current=function(){return this.__current.node},f.prototype.__execute=function(e,t){var r,n;return n=void 0,r=this.__current,this.__current=t,this.__state=null,e&&(n=e.call(this,t.node,this.__leavelist[this.__leavelist.length-1].node)),this.__current=r,n},f.prototype.notify=function(e){this.__state=e},f.prototype.skip=function(){this.notify(i)},f.prototype.break=function(){this.notify(o)},f.prototype.remove=function(){this.notify(s)},f.prototype.__initialize=function(e,t){this.visitor=t,this.root=e,this.__worklist=[],this.__leavelist=[],this.__current=null,this.__state=null,this.__fallback=null,"iteration"===t.fallback?this.__fallback=Object.keys:"function"==typeof t.fallback&&(this.__fallback=t.fallback),this.__keys=a,t.keys&&(this.__keys=Object.assign(Object.create(this.__keys),t.keys))},f.prototype.traverse=function(e,t){var r,n,a,s,l,u,f,d,m,x,v,g;for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,r.push(new c(e,null,null,null)),n.push(new c(null,null,null,null));r.length;)if((a=r.pop())!==g){if(a.node){if(u=this.__execute(t.enter,a),this.__state===o||u===o)return;if(r.push(g),n.push(a),this.__state===i||u===i)continue;if(l=(s=a.node).type||a.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error("Unknown node type "+l+".");x=this.__fallback(s)}for(d=x.length;(d-=1)>=0;)if(v=s[f=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]&&!y(n,v[m])){if(h(l,x[d]))a=new c(v[m],[f,m],"Property",null);else{if(!p(v[m]))continue;a=new c(v[m],[f,m],null,null)}r.push(a)}}else if(p(v)){if(y(n,v))continue;r.push(new c(v,f,null,null))}}}else if(a=n.pop(),u=this.__execute(t.leave,a),this.__state===o||u===o)return},f.prototype.replace=function(e,t){var r,n,a,l,f,y,d,m,x,v,g,b,A;function E(e){var t,n,a,o;if(e.ref.remove())for(n=e.ref.key,o=e.ref.parent,t=r.length;t--;)if((a=r[t]).ref&&a.ref.parent===o){if(a.ref.key<n)break;--a.ref.key}}for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,y=new c(e,null,null,new u(b={root:e},"root")),r.push(y),n.push(y);r.length;)if((y=r.pop())!==g){if(void 0!==(f=this.__execute(t.enter,y))&&f!==o&&f!==i&&f!==s&&(y.ref.replace(f),y.node=f),this.__state!==s&&f!==s||(E(y),y.node=null),this.__state===o||f===o)return b.root;if((a=y.node)&&(r.push(g),n.push(y),this.__state!==i&&f!==i)){if(l=a.type||y.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error("Unknown node type "+l+".");x=this.__fallback(a)}for(d=x.length;(d-=1)>=0;)if(v=a[A=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]){if(h(l,x[d]))y=new c(v[m],[A,m],"Property",new u(v,m));else{if(!p(v[m]))continue;y=new c(v[m],[A,m],null,new u(v,m))}r.push(y)}}else p(v)&&r.push(new c(v,A,null,new u(a,A)))}}else if(y=n.pop(),void 0!==(f=this.__execute(t.leave,y))&&f!==o&&f!==i&&f!==s&&y.ref.replace(f),this.__state!==s&&f!==s||E(y),this.__state===o||f===o)return b.root;return b.root},t.Syntax=r,t.traverse=d,t.replace=function(e,t){return(new f).replace(e,t)},t.attachComments=function(e,t,r){var a,o,i,s,u=[];if(!e.range)throw new Error("attachComments needs range information");if(!r.length){if(t.length){for(i=0,o=t.length;i<o;i+=1)(a=l(t[i])).extendedRange=[0,e.range[0]],u.push(a);e.leadingComments=u}return e}for(i=0,o=t.length;i<o;i+=1)u.push(m(l(t[i]),r));return s=0,d(e,{enter:function(e){for(var t;s<u.length&&!((t=u[s]).extendedRange[1]>e.range[0]);)t.extendedRange[1]===e.range[0]?(e.leadingComments||(e.leadingComments=[]),e.leadingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),s=0,d(e,{leave:function(e){for(var t;s<u.length&&(t=u[s],!(e.range[1]<t.extendedRange[0]));)e.range[1]===t.extendedRange[0]?(e.trailingComments||(e.trailingComments=[]),e.trailingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),e},t.VisitorKeys=a,t.VisitorOption=n,t.Controller=f,t.cloneEnvironment=function(){return e({})},t}(t)})),l=i((function(e){e.exports&&(e.exports=function(){function e(t,r,n,a){this.message=t,this.expected=r,this.found=n,this.location=a,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,e)}return function(e,t){function r(){this.constructor=e}r.prototype=t.prototype,e.prototype=new r}(e,Error),e.buildMessage=function(e,t){var r={literal:function(e){return'"'+a(e.text)+'"'},class:function(e){var t,r="";for(t=0;t<e.parts.length;t++)r+=e.parts[t]instanceof Array?o(e.parts[t][0])+"-"+o(e.parts[t][1]):o(e.parts[t]);return"["+(e.inverted?"^":"")+r+"]"},any:function(e){return"any character"},end:function(e){return"end of input"},other:function(e){return e.description}};function n(e){return e.charCodeAt(0).toString(16).toUpperCase()}function a(e){return e.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(e){return"\\x0"+n(e)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(e){return"\\x"+n(e)}))}function o(e){return e.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(e){return"\\x0"+n(e)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(e){return"\\x"+n(e)}))}return"Expected "+function(e){var t,n,a,o=new Array(e.length);for(t=0;t<e.length;t++)o[t]=(a=e[t],r[a.type](a));if(o.sort(),o.length>0){for(t=1,n=1;t<o.length;t++)o[t-1]!==o[t]&&(o[n]=o[t],n++);o.length=n}switch(o.length){case 1:return o[0];case 2:return o[0]+" or "+o[1];default:return o.slice(0,-1).join(", ")+", or "+o[o.length-1]}}(e)+" but "+function(e){return e?'"'+a(e)+'"':"end of input"}(t)+" found."},{SyntaxError:e,parse:function(t,r){r=void 0!==r?r:{};var n,a,o,i,s={},l={start:be},u=be,c=de(" ",!1),f=/^[^ [\],():#!=><~+.]/,p=me([" ","[","]",",","(",")",":","#","!","=",">","<","~","+","."],!0,!1),h=de(">",!1),y=de("~",!1),d=de("+",!1),m=de(",",!1),x=de("!",!1),v=de("*",!1),g=de("#",!1),b=de("[",!1),A=de("]",!1),E=/^[><!]/,S=me([">","<","!"],!1,!1),_=de("=",!1),w=function(e){return(e||"")+"="},C=/^[><]/,P=me([">","<"],!1,!1),k=de(".",!1),D=function(e,t,r){return{type:"attribute",name:e,operator:t,value:r}},j=de('"',!1),I=/^[^\\"]/,T=me(["\\",'"'],!0,!1),F=de("\\",!1),L={type:"any"},O=function(e,t){return e+t},R=function(e){return{type:"literal",value:(t=e.join(""),t.replace(/\\(.)/g,(function(e,t){switch(t){case"b":return"\b";case"f":return"\f";case"n":return"\n";case"r":return"\r";case"t":return"\t";case"v":return"\v";default:return t}})))};var t},B=de("'",!1),M=/^[^\\']/,U=me(["\\","'"],!0,!1),V=/^[0-9]/,q=me([["0","9"]],!1,!1),N=de("type(",!1),W=/^[^ )]/,K=me([" ",")"],!0,!1),G=de(")",!1),z=/^[imsu]/,H=me(["i","m","s","u"],!1,!1),Y=de("/",!1),$=/^[^\/]/,J=me(["/"],!0,!1),Q=de(":not(",!1),X=de(":matches(",!1),Z=de(":has(",!1),ee=de(":first-child",!1),te=de(":last-child",!1),re=de(":nth-child(",!1),ne=de(":nth-last-child(",!1),ae=de(":",!1),oe=de("statement",!0),ie=de("expression",!0),se=de("declaration",!0),le=de("function",!0),ue=de("pattern",!0),ce=0,fe=[{line:1,column:1}],pe=0,he=[],ye={};if("startRule"in r){if(!(r.startRule in l))throw new Error("Can't start parsing from rule \""+r.startRule+'".');u=l[r.startRule]}function de(e,t){return{type:"literal",text:e,ignoreCase:t}}function me(e,t,r){return{type:"class",parts:e,inverted:t,ignoreCase:r}}function xe(e){var r,n=fe[e];if(n)return n;for(r=e-1;!fe[r];)r--;for(n={line:(n=fe[r]).line,column:n.column};r<e;)10===t.charCodeAt(r)?(n.line++,n.column=1):n.column++,r++;return fe[e]=n,n}function ve(e,t){var r=xe(e),n=xe(t);return{start:{offset:e,line:r.line,column:r.column},end:{offset:t,line:n.line,column:n.column}}}function ge(e){ce<pe||(ce>pe&&(pe=ce,he=[]),he.push(e))}function be(){var e,t,r,n,a=30*ce+0,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,(t=Ae())!==s&&(r=_e())!==s&&Ae()!==s?e=t=1===(n=r).length?n[0]:{type:"matches",selectors:n}:(ce=e,e=s),e===s&&(e=ce,(t=Ae())!==s&&(t=void 0),e=t),ye[a]={nextPos:ce,result:e},e)}function Ae(){var e,r,n=30*ce+1,a=ye[n];if(a)return ce=a.nextPos,a.result;for(e=[],32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c));r!==s;)e.push(r),32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c));return ye[n]={nextPos:ce,result:e},e}function Ee(){var e,r,n,a=30*ce+2,o=ye[a];if(o)return ce=o.nextPos,o.result;if(r=[],f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p)),n!==s)for(;n!==s;)r.push(n),f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p));else r=s;return r!==s&&(r=r.join("")),e=r,ye[a]={nextPos:ce,result:e},e}function Se(){var e,r,n,a=30*ce+3,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,(r=Ae())!==s?(62===t.charCodeAt(ce)?(n=">",ce++):(n=s,ge(h)),n!==s&&Ae()!==s?e=r="child":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(126===t.charCodeAt(ce)?(n="~",ce++):(n=s,ge(y)),n!==s&&Ae()!==s?e=r="sibling":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(43===t.charCodeAt(ce)?(n="+",ce++):(n=s,ge(d)),n!==s&&Ae()!==s?e=r="adjacent":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c)),r!==s&&(n=Ae())!==s?e=r="descendant":(ce=e,e=s)))),ye[a]={nextPos:ce,result:e},e)}function _e(){var e,r,n,a,o,i,l,u,c=30*ce+4,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=we())!==s){for(n=[],a=ce,(o=Ae())!==s?(44===t.charCodeAt(ce)?(i=",",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?a=o=[o,i,l,u]:(ce=a,a=s)):(ce=a,a=s);a!==s;)n.push(a),a=ce,(o=Ae())!==s?(44===t.charCodeAt(ce)?(i=",",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?a=o=[o,i,l,u]:(ce=a,a=s)):(ce=a,a=s);n!==s?e=r=[r].concat(n.map((function(e){return e[3]}))):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function we(){var e,t,r,n,a,o,i,l=30*ce+5,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,(t=Ce())!==s){for(r=[],n=ce,(a=Se())!==s&&(o=Ce())!==s?n=a=[a,o]:(ce=n,n=s);n!==s;)r.push(n),n=ce,(a=Se())!==s&&(o=Ce())!==s?n=a=[a,o]:(ce=n,n=s);r!==s?(i=t,e=t=r.reduce((function(e,t){return{type:t[0],left:e,right:t[1]}}),i)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}function Ce(){var e,r,n,a,o,i,l,u=30*ce+6,c=ye[u];if(c)return ce=c.nextPos,c.result;if(e=ce,33===t.charCodeAt(ce)?(r="!",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s){if(n=[],(a=Pe())!==s)for(;a!==s;)n.push(a),a=Pe();else n=s;n!==s?(o=r,l=1===(i=n).length?i[0]:{type:"compound",selectors:i},o&&(l.subject=!0),e=r=l):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}function Pe(){var e,r=30*ce+7,n=ye[r];return n?(ce=n.nextPos,n.result):((e=function(){var e,r,n=30*ce+8,a=ye[n];return a?(ce=a.nextPos,a.result):(42===t.charCodeAt(ce)?(r="*",ce++):(r=s,ge(v)),r!==s&&(r={type:"wildcard",value:r}),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a=30*ce+9,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,35===t.charCodeAt(ce)?(r="#",ce++):(r=s,ge(g)),r===s&&(r=null),r!==s&&(n=Ee())!==s?e=r={type:"identifier",value:n}:(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+10,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,91===t.charCodeAt(ce)?(r="[",ce++):(r=s,ge(b)),r!==s&&Ae()!==s&&(n=function(){var e,r,n,a,o=30*ce+14,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,a=30*ce+12,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,33===t.charCodeAt(ce)?(r="!",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n="=",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((a=function(){var e,r,n,a,o,i=30*ce+18,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,"type("===t.substr(ce,5)?(r="type(",ce+=5):(r=s,ge(N)),r!==s)if(Ae()!==s){if(n=[],W.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(K)),a!==s)for(;a!==s;)n.push(a),W.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(K));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?(r={type:"type",value:n.join("")},e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,r,n,a,o,i,l=30*ce+20,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,47===t.charCodeAt(ce)?(r="/",ce++):(r=s,ge(Y)),r!==s){if(n=[],$.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(J)),a!==s)for(;a!==s;)n.push(a),$.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(J));else n=s;n!==s?(47===t.charCodeAt(ce)?(a="/",ce++):(a=s,ge(Y)),a!==s?((o=function(){var e,r,n=30*ce+19,a=ye[n];if(a)return ce=a.nextPos,a.result;if(e=[],z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H)),r!==s)for(;r!==s;)e.push(r),z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H));else e=s;return ye[n]={nextPos:ce,result:e},e}())===s&&(o=null),o!==s?(i=o,r={type:"regexp",value:new RegExp(n.join(""),i?i.join(""):"")},e=r):(ce=e,e=s)):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}()),a!==s?(r=D(r,n,a),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,a=30*ce+11,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,E.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(S)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n="=",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(C.test(t.charAt(ce))?(e=t.charAt(ce),ce++):(e=s,ge(P))),ye[a]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((a=function(){var e,r,n,a,o,i,l=30*ce+15,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,34===t.charCodeAt(ce)?(r='"',ce++):(r=s,ge(j)),r!==s){for(n=[],I.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(T)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o="\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));a!==s;)n.push(a),I.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(T)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o="\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));n!==s?(34===t.charCodeAt(ce)?(a='"',ce++):(a=s,ge(j)),a!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;if(e===s)if(e=ce,39===t.charCodeAt(ce)?(r="'",ce++):(r=s,ge(B)),r!==s){for(n=[],M.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(U)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o="\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));a!==s;)n.push(a),M.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(U)),a===s&&(a=ce,92===t.charCodeAt(ce)?(o="\\",ce++):(o=s,ge(F)),o!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(o=O(o,i),a=o):(ce=a,a=s)):(ce=a,a=s));n!==s?(39===t.charCodeAt(ce)?(a="'",ce++):(a=s,ge(B)),a!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,r,n,a,o,i,l,u=30*ce+16,c=ye[u];if(c)return ce=c.nextPos,c.result;for(e=ce,r=ce,n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));if(n!==s?(46===t.charCodeAt(ce)?(a=".",ce++):(a=s,ge(k)),a!==s?r=n=[n,a]:(ce=r,r=s)):(ce=r,r=s),r===s&&(r=null),r!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s?(i=n,l=(o=r)?[].concat.apply([],o).join(""):"",r={type:"literal",value:parseFloat(l+i.join(""))},e=r):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}())===s&&(a=function(){var e,t,r=30*ce+17,n=ye[r];return n?(ce=n.nextPos,n.result):((t=Ee())!==s&&(t={type:"literal",value:t}),e=t,ye[r]={nextPos:ce,result:e},e)}()),a!==s?(r=D(r,n,a),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&(r={type:"attribute",name:r}),e=r)),ye[o]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?(93===t.charCodeAt(ce)?(a="]",ce++):(a=s,ge(A)),a!==s?e=r=n:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o,i,l,u,c=30*ce+21,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,46===t.charCodeAt(ce)?(r=".",ce++):(r=s,ge(k)),r!==s)if((n=Ee())!==s){for(a=[],o=ce,46===t.charCodeAt(ce)?(i=".",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?o=i=[i,l]:(ce=o,o=s);o!==s;)a.push(o),o=ce,46===t.charCodeAt(ce)?(i=".",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?o=i=[i,l]:(ce=o,o=s);a!==s?(u=n,r={type:"field",name:a.reduce((function(e,t){return e+t[0]+t[1]}),u)},e=r):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a,o=30*ce+22,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,":not("===t.substr(ce,5)?(r=":not(",ce+=5):(r=s,ge(Q)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?e=r={type:"not",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+23,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,":matches("===t.substr(ce,9)?(r=":matches(",ce+=9):(r=s,ge(X)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?e=r={type:"matches",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o=30*ce+24,i=ye[o];return i?(ce=i.nextPos,i.result):(e=ce,":has("===t.substr(ce,5)?(r=":has(",ce+=5):(r=s,ge(Z)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?e=r={type:"has",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+25,a=ye[n];return a?(ce=a.nextPos,a.result):(":first-child"===t.substr(ce,12)?(r=":first-child",ce+=12):(r=s,ge(ee)),r!==s&&(r=De(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+26,a=ye[n];return a?(ce=a.nextPos,a.result):(":last-child"===t.substr(ce,11)?(r=":last-child",ce+=11):(r=s,ge(te)),r!==s&&(r=je(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,a,o,i=30*ce+27,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,":nth-child("===t.substr(ce,11)?(r=":nth-child(",ce+=11):(r=s,ge(re)),r!==s)if(Ae()!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?(r=De(parseInt(n.join(""),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a,o,i=30*ce+28,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,":nth-last-child("===t.substr(ce,16)?(r=":nth-last-child(",ce+=16):(r=s,ge(ne)),r!==s)if(Ae()!==s){if(n=[],V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q)),a!==s)for(;a!==s;)n.push(a),V.test(t.charAt(ce))?(a=t.charAt(ce),ce++):(a=s,ge(q));else n=s;n!==s&&(a=Ae())!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?(r=je(parseInt(n.join(""),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,a=30*ce+29,o=ye[a];return o?(ce=o.nextPos,o.result):(e=ce,58===t.charCodeAt(ce)?(r=":",ce++):(r=s,ge(ae)),r!==s?("statement"===t.substr(ce,9).toLowerCase()?(n=t.substr(ce,9),ce+=9):(n=s,ge(oe)),n===s&&("expression"===t.substr(ce,10).toLowerCase()?(n=t.substr(ce,10),ce+=10):(n=s,ge(ie)),n===s&&("declaration"===t.substr(ce,11).toLowerCase()?(n=t.substr(ce,11),ce+=11):(n=s,ge(se)),n===s&&("function"===t.substr(ce,8).toLowerCase()?(n=t.substr(ce,8),ce+=8):(n=s,ge(le)),n===s&&("pattern"===t.substr(ce,7).toLowerCase()?(n=t.substr(ce,7),ce+=7):(n=s,ge(ue)))))),n!==s?e=r={type:"class",name:n}:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}()),ye[r]={nextPos:ce,result:e},e)}function ke(){var e,r,n,a,o,i,l,u,c=30*ce+13,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=Ee())!==s){for(n=[],a=ce,46===t.charCodeAt(ce)?(o=".",ce++):(o=s,ge(k)),o!==s&&(i=Ee())!==s?a=o=[o,i]:(ce=a,a=s);a!==s;)n.push(a),a=ce,46===t.charCodeAt(ce)?(o=".",ce++):(o=s,ge(k)),o!==s&&(i=Ee())!==s?a=o=[o,i]:(ce=a,a=s);n!==s?(l=r,u=n,e=r=[].concat.apply([l],u).join("")):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function De(e){return{type:"nth-child",index:{type:"literal",value:e}}}function je(e){return{type:"nth-last-child",index:{type:"literal",value:e}}}if((n=u())!==s&&ce===t.length)return n;throw n!==s&&ce<t.length&&ge({type:"end"}),a=he,o=pe<t.length?t.charAt(pe):null,i=pe<t.length?ve(pe,pe+1):ve(pe,pe),new e(e.buildMessage(a,o),a,o,i)}}}())}));function u(t,r,n,a){if(!r)return!0;if(!t)return!1;switch(n||(n=[]),r.type){case"wildcard":return!0;case"identifier":return r.value.toLowerCase()===t.type.toLowerCase();case"field":var i=r.name.split("."),l=n[i.length-1];return function e(t,r,n){if(0===n.length)return t===r;if(null==r)return!1;var a=r[n[0]],i=n.slice(1);if(Array.isArray(a)){var s,l=o(a);try{for(l.s();!(s=l.n()).done;){if(e(t,s.value,i))return!0}}catch(e){l.e(e)}finally{l.f()}return!1}return e(t,a,i)}(t,l,i);case"matches":var c,f=o(r.selectors);try{for(f.s();!(c=f.n()).done;){var d=c.value;if(u(t,d,n,a))return!0}}catch(e){f.e(e)}finally{f.f()}return!1;case"compound":var m,x=o(r.selectors);try{for(x.s();!(m=x.n()).done;){var v=m.value;if(!u(t,v,n,a))return!1}}catch(e){x.e(e)}finally{x.f()}return!0;case"not":var g,b=o(r.selectors);try{for(b.s();!(g=b.n()).done;){var A=g.value;if(u(t,A,n,a))return!1}}catch(e){b.e(e)}finally{b.f()}return!0;case"has":var E=function(){var e,n=[],i=o(r.selectors);try{var l=function(){var r=e.value,o=[];s.traverse(t,{enter:function(e,t){null!=t&&o.unshift(t),u(e,r,o,a)&&n.push(e)},leave:function(){o.shift()},keys:a&&a.visitorKeys,fallback:a&&a.fallback||"iteration"})};for(i.s();!(e=i.n()).done;)l()}catch(e){i.e(e)}finally{i.f()}return{v:0!==n.length}}();if("object"===e(E))return E.v;case"child":return!!u(t,r.right,n,a)&&u(n[0],r.left,n.slice(1),a);case"descendant":if(u(t,r.right,n,a))for(var S=0,_=n.length;S<_;++S)if(u(n[S],r.left,n.slice(S+1),a))return!0;return!1;case"attribute":var w=function(e,t){var r,n=o(t.split("."));try{for(n.s();!(r=n.n()).done;){var a=r.value;if(null==e)return e;e=e[a]}}catch(e){n.e(e)}finally{n.f()}return e}(t,r.name);switch(r.operator){case void 0:return null!=w;case"=":switch(r.value.type){case"regexp":return"string"==typeof w&&r.value.value.test(w);case"literal":return"".concat(r.value.value)==="".concat(w);case"type":return r.value.value===e(w)}throw new Error("Unknown selector value type: ".concat(r.value.type));case"!=":switch(r.value.type){case"regexp":return!r.value.value.test(w);case"literal":return"".concat(r.value.value)!=="".concat(w);case"type":return r.value.value!==e(w)}throw new Error("Unknown selector value type: ".concat(r.value.type));case"<=":return w<=r.value.value;case"<":return w<r.value.value;case">":return w>r.value.value;case">=":return w>=r.value.value}throw new Error("Unknown operator: ".concat(r.operator));case"sibling":return u(t,r.right,n,a)&&p(t,r.left,n,"LEFT_SIDE",a)||r.left.subject&&u(t,r.left,n,a)&&p(t,r.right,n,"RIGHT_SIDE",a);case"adjacent":return u(t,r.right,n,a)&&h(t,r.left,n,"LEFT_SIDE",a)||r.right.subject&&u(t,r.left,n,a)&&h(t,r.right,n,"RIGHT_SIDE",a);case"nth-child":return u(t,r.right,n,a)&&y(t,n,(function(){return r.index.value-1}),a);case"nth-last-child":return u(t,r.right,n,a)&&y(t,n,(function(e){return e-r.index.value}),a);case"class":switch(r.name.toLowerCase()){case"statement":if("Statement"===t.type.slice(-9))return!0;case"declaration":return"Declaration"===t.type.slice(-11);case"pattern":if("Pattern"===t.type.slice(-7))return!0;case"expression":return"Expression"===t.type.slice(-10)||"Literal"===t.type.slice(-7)||"Identifier"===t.type&&(0===n.length||"MetaProperty"!==n[0].type)||"MetaProperty"===t.type;case"function":return"FunctionDeclaration"===t.type||"FunctionExpression"===t.type||"ArrowFunctionExpression"===t.type}throw new Error("Unknown class name: ".concat(r.name))}throw new Error("Unknown selector type: ".concat(r.type))}function c(e,t){var r=e.type;return t&&t.visitorKeys&&t.visitorKeys[r]?t.visitorKeys[r]:s.VisitorKeys[r]?s.VisitorKeys[r]:t&&"function"==typeof t.fallback?t.fallback(e):Object.keys(e).filter((function(e){return"type"!==e}))}function f(t){return null!==t&&"object"===e(t)&&"string"==typeof t.type}function p(e,r,n,a,i){var s=t(n,1)[0];if(!s)return!1;var l,p=o(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;var d=void 0,m=void 0;"LEFT_SIDE"===a?(d=0,m=y):(d=y+1,m=h.length);for(var x=d;x<m;++x)if(f(h[x])&&u(h[x],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function h(e,r,n,a,i){var s=t(n,1)[0];if(!s)return!1;var l,p=o(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;if("LEFT_SIDE"===a&&y>0&&f(h[y-1])&&u(h[y-1],r,n,i))return!0;if("RIGHT_SIDE"===a&&y<h.length-1&&f(h[y+1])&&u(h[y+1],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function y(e,r,n,a){var i=t(r,1)[0];if(!i)return!1;var s,l=o(c(i,a));try{for(l.s();!(s=l.n()).done;){var u=i[s.value];if(Array.isArray(u)){var f=u.indexOf(e);if(f>=0&&f===n(u.length))return!0}}}catch(e){l.e(e)}finally{l.f()}return!1}function d(n,a){if(null==n||"object"!=e(n))return[];null==a&&(a=n);for(var o=n.subject?[a]:[],i=0,s=function(e){for(var t=[],r=Object.keys(e),n=0;n<r.length;n++)t.push([r[n],e[r[n]]]);return t}(n);i<s.length;i++){var l=t(s[i],2),u=l[0],c=l[1];o.push.apply(o,r(d(c,"left"===u?c:a)))}return o}function m(e,t,r,n){if(t){var a=[],o=d(t);s.traverse(e,{enter:function(e,i){if(null!=i&&a.unshift(i),u(e,t,a,n))if(o.length)for(var s=0,l=o.length;s<l;++s){u(e,o[s],a,n)&&r(e,i,a);for(var c=0,f=a.length;c<f;++c){var p=a.slice(c+1);u(a[c],o[s],p,n)&&r(a[c],i,p)}}else r(e,i,a)},leave:function(){a.shift()},keys:n&&n.visitorKeys,fallback:n&&n.fallback||"iteration"})}}function x(e,t,r){var n=[];return m(e,t,(function(e){n.push(e)}),r),n}function v(e){return l.parse(e)}function g(e,t,r){return x(e,v(t),r)}g.parse=v,g.match=x,g.traverse=m,g.matches=u,g.query=g;export default g;
//# sourceMappingURL=esquery.esm.min.js.map
µ/dist/esquery.lite.jsÆ š­(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('estraverse')) :
  typeof define === 'function' && define.amd ? define(['estraverse'], factory) :
  (global = global || self, global.esquery = factory(global.estraverse));
}(this, (function (estraverse) { 'use strict';

  estraverse = estraverse && Object.prototype.hasOwnProperty.call(estraverse, 'default') ? estraverse['default'] : estraverse;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var parser = createCommonjsModule(function (module) {
    /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
    (function (root, factory) {
      if ( module.exports) {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {

      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }

        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";

        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }

      peg$subclass(peg$SyntaxError, Error);

      peg$SyntaxError.buildMessage = function (expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function literal(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },
          "class": function _class(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },
          any: function any(expectation) {
            return "any character";
          },
          end: function end(expectation) {
            return "end of input";
          },
          other: function other(expectation) {
            return expectation.description;
          }
        };

        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }

        function literalEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }

        function classEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }

        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
          var descriptions = new Array(expected.length),
              i,
              j;

          for (i = 0; i < expected.length; i++) {
            descriptions[i] = describeExpectation(expected[i]);
          }

          descriptions.sort();

          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }

            descriptions.length = j;
          }

          switch (descriptions.length) {
            case 1:
              return descriptions[0];

            case 2:
              return descriptions[0] + " or " + descriptions[1];

            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }

        function describeFound(found) {
          return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };

      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};

        var peg$FAILED = {},
            peg$startRuleFunctions = {
          start: peg$parsestart
        },
            peg$startRuleFunction = peg$parsestart,
            peg$c0 = function peg$c0(ss) {
          return ss.length === 1 ? ss[0] : {
            type: 'matches',
            selectors: ss
          };
        },
            peg$c1 = function peg$c1() {
          return void 0;
        },
            peg$c2 = " ",
            peg$c3 = peg$literalExpectation(" ", false),
            peg$c4 = /^[^ [\],():#!=><~+.]/,
            peg$c5 = peg$classExpectation([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false),
            peg$c6 = function peg$c6(i) {
          return i.join('');
        },
            peg$c7 = ">",
            peg$c8 = peg$literalExpectation(">", false),
            peg$c9 = function peg$c9() {
          return 'child';
        },
            peg$c10 = "~",
            peg$c11 = peg$literalExpectation("~", false),
            peg$c12 = function peg$c12() {
          return 'sibling';
        },
            peg$c13 = "+",
            peg$c14 = peg$literalExpectation("+", false),
            peg$c15 = function peg$c15() {
          return 'adjacent';
        },
            peg$c16 = function peg$c16() {
          return 'descendant';
        },
            peg$c17 = ",",
            peg$c18 = peg$literalExpectation(",", false),
            peg$c19 = function peg$c19(s, ss) {
          return [s].concat(ss.map(function (s) {
            return s[3];
          }));
        },
            peg$c20 = function peg$c20(a, ops) {
          return ops.reduce(function (memo, rhs) {
            return {
              type: rhs[0],
              left: memo,
              right: rhs[1]
            };
          }, a);
        },
            peg$c21 = "!",
            peg$c22 = peg$literalExpectation("!", false),
            peg$c23 = function peg$c23(subject, as) {
          var b = as.length === 1 ? as[0] : {
            type: 'compound',
            selectors: as
          };
          if (subject) b.subject = true;
          return b;
        },
            peg$c24 = "*",
            peg$c25 = peg$literalExpectation("*", false),
            peg$c26 = function peg$c26(a) {
          return {
            type: 'wildcard',
            value: a
          };
        },
            peg$c27 = "#",
            peg$c28 = peg$literalExpectation("#", false),
            peg$c29 = function peg$c29(i) {
          return {
            type: 'identifier',
            value: i
          };
        },
            peg$c30 = "[",
            peg$c31 = peg$literalExpectation("[", false),
            peg$c32 = "]",
            peg$c33 = peg$literalExpectation("]", false),
            peg$c34 = function peg$c34(v) {
          return v;
        },
            peg$c35 = /^[><!]/,
            peg$c36 = peg$classExpectation([">", "<", "!"], false, false),
            peg$c37 = "=",
            peg$c38 = peg$literalExpectation("=", false),
            peg$c39 = function peg$c39(a) {
          return (a || '') + '=';
        },
            peg$c40 = /^[><]/,
            peg$c41 = peg$classExpectation([">", "<"], false, false),
            peg$c42 = ".",
            peg$c43 = peg$literalExpectation(".", false),
            peg$c44 = function peg$c44(a, as) {
          return [].concat.apply([a], as).join('');
        },
            peg$c45 = function peg$c45(name, op, value) {
          return {
            type: 'attribute',
            name: name,
            operator: op,
            value: value
          };
        },
            peg$c46 = function peg$c46(name) {
          return {
            type: 'attribute',
            name: name
          };
        },
            peg$c47 = "\"",
            peg$c48 = peg$literalExpectation("\"", false),
            peg$c49 = /^[^\\"]/,
            peg$c50 = peg$classExpectation(["\\", "\""], true, false),
            peg$c51 = "\\",
            peg$c52 = peg$literalExpectation("\\", false),
            peg$c53 = peg$anyExpectation(),
            peg$c54 = function peg$c54(a, b) {
          return a + b;
        },
            peg$c55 = function peg$c55(d) {
          return {
            type: 'literal',
            value: strUnescape(d.join(''))
          };
        },
            peg$c56 = "'",
            peg$c57 = peg$literalExpectation("'", false),
            peg$c58 = /^[^\\']/,
            peg$c59 = peg$classExpectation(["\\", "'"], true, false),
            peg$c60 = /^[0-9]/,
            peg$c61 = peg$classExpectation([["0", "9"]], false, false),
            peg$c62 = function peg$c62(a, b) {
          // Can use `a.flat().join('')` once supported
          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';
          return {
            type: 'literal',
            value: parseFloat(leadingDecimals + b.join(''))
          };
        },
            peg$c63 = function peg$c63(i) {
          return {
            type: 'literal',
            value: i
          };
        },
            peg$c64 = "type(",
            peg$c65 = peg$literalExpectation("type(", false),
            peg$c66 = /^[^ )]/,
            peg$c67 = peg$classExpectation([" ", ")"], true, false),
            peg$c68 = ")",
            peg$c69 = peg$literalExpectation(")", false),
            peg$c70 = function peg$c70(t) {
          return {
            type: 'type',
            value: t.join('')
          };
        },
            peg$c71 = /^[imsu]/,
            peg$c72 = peg$classExpectation(["i", "m", "s", "u"], false, false),
            peg$c73 = "/",
            peg$c74 = peg$literalExpectation("/", false),
            peg$c75 = /^[^\/]/,
            peg$c76 = peg$classExpectation(["/"], true, false),
            peg$c77 = function peg$c77(d, flgs) {
          return {
            type: 'regexp',
            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')
          };
        },
            peg$c78 = function peg$c78(i, is) {
          return {
            type: 'field',
            name: is.reduce(function (memo, p) {
              return memo + p[0] + p[1];
            }, i)
          };
        },
            peg$c79 = ":not(",
            peg$c80 = peg$literalExpectation(":not(", false),
            peg$c81 = function peg$c81(ss) {
          return {
            type: 'not',
            selectors: ss
          };
        },
            peg$c82 = ":matches(",
            peg$c83 = peg$literalExpectation(":matches(", false),
            peg$c84 = function peg$c84(ss) {
          return {
            type: 'matches',
            selectors: ss
          };
        },
            peg$c85 = ":has(",
            peg$c86 = peg$literalExpectation(":has(", false),
            peg$c87 = function peg$c87(ss) {
          return {
            type: 'has',
            selectors: ss
          };
        },
            peg$c88 = ":first-child",
            peg$c89 = peg$literalExpectation(":first-child", false),
            peg$c90 = function peg$c90() {
          return nth(1);
        },
            peg$c91 = ":last-child",
            peg$c92 = peg$literalExpectation(":last-child", false),
            peg$c93 = function peg$c93() {
          return nthLast(1);
        },
            peg$c94 = ":nth-child(",
            peg$c95 = peg$literalExpectation(":nth-child(", false),
            peg$c96 = function peg$c96(n) {
          return nth(parseInt(n.join(''), 10));
        },
            peg$c97 = ":nth-last-child(",
            peg$c98 = peg$literalExpectation(":nth-last-child(", false),
            peg$c99 = function peg$c99(n) {
          return nthLast(parseInt(n.join(''), 10));
        },
            peg$c100 = ":",
            peg$c101 = peg$literalExpectation(":", false),
            peg$c102 = "statement",
            peg$c103 = peg$literalExpectation("statement", true),
            peg$c104 = "expression",
            peg$c105 = peg$literalExpectation("expression", true),
            peg$c106 = "declaration",
            peg$c107 = peg$literalExpectation("declaration", true),
            peg$c108 = "function",
            peg$c109 = peg$literalExpectation("function", true),
            peg$c110 = "pattern",
            peg$c111 = peg$literalExpectation("pattern", true),
            peg$c112 = function peg$c112(c) {
          return {
            type: 'class',
            name: c
          };
        },
            peg$currPos = 0,
            peg$posDetailsCache = [{
          line: 1,
          column: 1
        }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$resultsCache = {},
            peg$result;

        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }

          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function peg$literalExpectation(text, ignoreCase) {
          return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
          };
        }

        function peg$classExpectation(parts, inverted, ignoreCase) {
          return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
          };
        }

        function peg$anyExpectation() {
          return {
            type: "any"
          };
        }

        function peg$endExpectation() {
          return {
            type: "end"
          };
        }

        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p;

          if (details) {
            return details;
          } else {
            p = pos - 1;

            while (!peg$posDetailsCache[p]) {
              p--;
            }

            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column
            };

            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }

              p++;
            }

            peg$posDetailsCache[pos] = details;
            return details;
          }
        }

        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }

          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }

          peg$maxFailExpected.push(expected);
        }

        function peg$buildStructuredError(expected, found, location) {
          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
        }

        function peg$parsestart() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 0,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            s2 = peg$parseselectors();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();

              if (s3 !== peg$FAILED) {
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();

            if (s1 !== peg$FAILED) {
              s1 = peg$c1();
            }

            s0 = s1;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parse_() {
          var s0, s1;
          var key = peg$currPos * 30 + 1,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = [];

          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c2;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c3);
            }
          }

          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (input.charCodeAt(peg$currPos) === 32) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              {
                peg$fail(peg$c3);
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseidentifierName() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 2,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = [];

          if (peg$c4.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c5);
            }
          }

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);

              if (peg$c4.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c5);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c6(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsebinaryOp() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 3,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c8);
              }
            }

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();

              if (s3 !== peg$FAILED) {
                s1 = peg$c9();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();

            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 126) {
                s2 = peg$c10;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c11);
                }
              }

              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();

                if (s3 !== peg$FAILED) {
                  s1 = peg$c12();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();

              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  {
                    peg$fail(peg$c14);
                  }
                }

                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();

                  if (s3 !== peg$FAILED) {
                    s1 = peg$c15();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              if (s0 === peg$FAILED) {
                s0 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 32) {
                  s1 = peg$c2;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;

                  {
                    peg$fail(peg$c3);
                  }
                }

                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();

                  if (s2 !== peg$FAILED) {
                    s1 = peg$c16();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseselectors() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 30 + 4,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseselector();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();

            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c18);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();

                if (s6 !== peg$FAILED) {
                  s7 = peg$parseselector();

                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c17;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c18);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseselector();

                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c19(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseselector() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 5,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parsesequence();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsebinaryOp();

            if (s4 !== peg$FAILED) {
              s5 = peg$parsesequence();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsebinaryOp();

              if (s4 !== peg$FAILED) {
                s5 = peg$parsesequence();

                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c20(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsesequence() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 6,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c21;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c22);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseatom();

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseatom();
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c23(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseatom() {
          var s0;
          var key = peg$currPos * 30 + 7,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$parsewildcard();

          if (s0 === peg$FAILED) {
            s0 = peg$parseidentifier();

            if (s0 === peg$FAILED) {
              s0 = peg$parseattr();

              if (s0 === peg$FAILED) {
                s0 = peg$parsefield();

                if (s0 === peg$FAILED) {
                  s0 = peg$parsenegation();

                  if (s0 === peg$FAILED) {
                    s0 = peg$parsematches();

                    if (s0 === peg$FAILED) {
                      s0 = peg$parsehas();

                      if (s0 === peg$FAILED) {
                        s0 = peg$parsefirstChild();

                        if (s0 === peg$FAILED) {
                          s0 = peg$parselastChild();

                          if (s0 === peg$FAILED) {
                            s0 = peg$parsenthChild();

                            if (s0 === peg$FAILED) {
                              s0 = peg$parsenthLastChild();

                              if (s0 === peg$FAILED) {
                                s0 = peg$parseclass();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsewildcard() {
          var s0, s1;
          var key = peg$currPos * 30 + 8,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c24;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c25);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c26(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseidentifier() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 9,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c28);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();

            if (s2 !== peg$FAILED) {
              s1 = peg$c29(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattr() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 10,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c30;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c31);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrValue();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c32;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c33);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c34(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrOps() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 11,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (peg$c35.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c36);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c37;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c38);
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c39(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            if (peg$c40.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              {
                peg$fail(peg$c41);
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrEqOps() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 12,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c21;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c22);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c37;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c38);
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c39(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrName() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 13,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseidentifierName();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c42;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseidentifierName();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c42;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c43);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parseidentifierName();

                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c44(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrValue() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 14,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseattrName();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrEqOps();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetype();

                  if (s5 === peg$FAILED) {
                    s5 = peg$parseregex();
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c45(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseattrName();

            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();

              if (s2 !== peg$FAILED) {
                s3 = peg$parseattrOps();

                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();

                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsestring();

                    if (s5 === peg$FAILED) {
                      s5 = peg$parsenumber();

                      if (s5 === peg$FAILED) {
                        s5 = peg$parsepath();
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      s1 = peg$c45(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseattrName();

              if (s1 !== peg$FAILED) {
                s1 = peg$c46(s1);
              }

              s0 = s1;
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsestring() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 15,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c48);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c49.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c50);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c52);
                }
              }

              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c53);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s4 = peg$c54(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);

              if (peg$c49.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c50);
                }
              }

              if (s3 === peg$FAILED) {
                s3 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c51;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c52);
                  }
                }

                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c53);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s4 = peg$c54(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c47;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c48);
                }
              }

              if (s3 !== peg$FAILED) {
                s1 = peg$c55(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c56;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              {
                peg$fail(peg$c57);
              }
            }

            if (s1 !== peg$FAILED) {
              s2 = [];

              if (peg$c58.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c59);
                }
              }

              if (s3 === peg$FAILED) {
                s3 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c51;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c52);
                  }
                }

                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c53);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s4 = peg$c54(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }

              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c58.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c59);
                  }
                }

                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;

                  if (input.charCodeAt(peg$currPos) === 92) {
                    s4 = peg$c51;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c52);
                    }
                  }

                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;

                      {
                        peg$fail(peg$c53);
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      s4 = peg$c54(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }

              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c56;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c57);
                  }
                }

                if (s3 !== peg$FAILED) {
                  s1 = peg$c55(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenumber() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 16,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];

          if (peg$c60.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c61);
            }
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c42;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c60.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c61);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c62(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsepath() {
          var s0, s1;
          var key = peg$currPos * 30 + 17,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseidentifierName();

          if (s1 !== peg$FAILED) {
            s1 = peg$c63(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsetype() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 18,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c64) {
            s1 = peg$c64;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c65);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c66.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c67);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c66.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c67);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c70(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseflags() {
          var s0, s1;
          var key = peg$currPos * 30 + 19,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = [];

          if (peg$c71.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c72);
            }
          }

          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);

              if (peg$c71.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                {
                  peg$fail(peg$c72);
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseregex() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 30 + 20,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c73;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c74);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c75.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c76);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c75.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c76);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s3 = peg$c73;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c74);
                }
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parseflags();

                if (s4 === peg$FAILED) {
                  s4 = null;
                }

                if (s4 !== peg$FAILED) {
                  s1 = peg$c77(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsefield() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 30 + 21,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c42;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c43);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c42;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c43);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifierName();

                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 46) {
                  s5 = peg$c42;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c43);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseidentifierName();

                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }

              if (s3 !== peg$FAILED) {
                s1 = peg$c78(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenegation() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 22,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c79) {
            s1 = peg$c79;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c80);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c81(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsematches() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 23,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 9) === peg$c82) {
            s1 = peg$c82;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c83);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c84(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsehas() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 24,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c86);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c87(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsefirstChild() {
          var s0, s1;
          var key = peg$currPos * 30 + 25,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 12) === peg$c88) {
            s1 = peg$c88;
            peg$currPos += 12;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c89);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c90();
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parselastChild() {
          var s0, s1;
          var key = peg$currPos * 30 + 26,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 11) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c92);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c93();
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenthChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 27,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 11) === peg$c94) {
            s1 = peg$c94;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c95);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c61);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c60.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c61);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c96(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenthLastChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 28,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 16) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 16;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c98);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c61);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c60.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c61);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c99(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseclass() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 29,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c100;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c101);
            }
          }

          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {
              s2 = input.substr(peg$currPos, 9);
              peg$currPos += 9;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c103);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {
                s2 = input.substr(peg$currPos, 10);
                peg$currPos += 10;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c105);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {
                  s2 = input.substr(peg$currPos, 11);
                  peg$currPos += 11;
                } else {
                  s2 = peg$FAILED;

                  {
                    peg$fail(peg$c107);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {
                    s2 = input.substr(peg$currPos, 8);
                    peg$currPos += 8;
                  } else {
                    s2 = peg$FAILED;

                    {
                      peg$fail(peg$c109);
                    }
                  }

                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {
                      s2 = input.substr(peg$currPos, 7);
                      peg$currPos += 7;
                    } else {
                      s2 = peg$FAILED;

                      {
                        peg$fail(peg$c111);
                      }
                    }
                  }
                }
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c112(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function nth(n) {
          return {
            type: 'nth-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }

        function nthLast(n) {
          return {
            type: 'nth-last-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }

        function strUnescape(s) {
          return s.replace(/\\(.)/g, function (match, ch) {
            switch (ch) {
              case 'b':
                return '\b';

              case 'f':
                return '\f';

              case 'n':
                return '\n';

              case 'r':
                return '\r';

              case 't':
                return '\t';

              case 'v':
                return '\v';

              default:
                return ch;
            }
          });
        }

        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }

          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }

      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    });
  });

  function _objectEntries(obj) {
    var entries = [];
    var keys = Object.keys(obj);

    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);

    return entries;
  }
  /**
  * @typedef {"LEFT_SIDE"|"RIGHT_SIDE"} Side
  */

  var LEFT_SIDE = 'LEFT_SIDE';
  var RIGHT_SIDE = 'RIGHT_SIDE';
  /**
   * @external AST
   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html
   */

  /**
   * One of the rules of `grammar.pegjs`
   * @typedef {PlainObject} SelectorAST
   * @see grammar.pegjs
  */

  /**
   * The `sequence` production of `grammar.pegjs`
   * @typedef {PlainObject} SelectorSequenceAST
  */

  /**
   * Get the value of a property which may be multiple levels down
   * in the object.
   * @param {?PlainObject} obj
   * @param {string} key
   * @returns {undefined|boolean|string|number|external:AST}
   */

  function getPath(obj, key) {
    var keys = key.split('.');

    var _iterator = _createForOfIteratorHelper(keys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (obj == null) {
          return obj;
        }

        obj = obj[_key];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return obj;
  }
  /**
   * Determine whether `node` can be reached by following `path`,
   * starting at `ancestor`.
   * @param {?external:AST} node
   * @param {?external:AST} ancestor
   * @param {string[]} path
   * @returns {boolean}
   */


  function inPath(node, ancestor, path) {
    if (path.length === 0) {
      return node === ancestor;
    }

    if (ancestor == null) {
      return false;
    }

    var field = ancestor[path[0]];
    var remainingPath = path.slice(1);

    if (Array.isArray(field)) {
      var _iterator2 = _createForOfIteratorHelper(field),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var component = _step2.value;

          if (inPath(node, component, remainingPath)) {
            return true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return false;
    } else {
      return inPath(node, field, remainingPath);
    }
  }
  /**
   * @callback TraverseOptionFallback
   * @param {external:AST} node The given node.
   * @returns {string[]} An array of visitor keys for the given node.
   */

  /**
   * @typedef {object} ESQueryOptions
   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.
   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.
   */

  /**
   * Given a `node` and its ancestors, determine if `node` is matched
   * by `selector`.
   * @param {?external:AST} node
   * @param {?SelectorAST} selector
   * @param {external:AST[]} [ancestry=[]]
   * @param {ESQueryOptions} [options]
   * @throws {Error} Unknowns (operator, class name, selector type, or
   * selector value type)
   * @returns {boolean}
   */


  function matches(node, selector, ancestry, options) {
    if (!selector) {
      return true;
    }

    if (!node) {
      return false;
    }

    if (!ancestry) {
      ancestry = [];
    }

    switch (selector.type) {
      case 'wildcard':
        return true;

      case 'identifier':
        return selector.value.toLowerCase() === node.type.toLowerCase();

      case 'field':
        {
          var path = selector.name.split('.');
          var ancestor = ancestry[path.length - 1];
          return inPath(node, ancestor, path);
        }

      case 'matches':
        var _iterator3 = _createForOfIteratorHelper(selector.selectors),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var sel = _step3.value;

            if (matches(node, sel, ancestry, options)) {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return false;

      case 'compound':
        var _iterator4 = _createForOfIteratorHelper(selector.selectors),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _sel = _step4.value;

            if (!matches(node, _sel, ancestry, options)) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return true;

      case 'not':
        var _iterator5 = _createForOfIteratorHelper(selector.selectors),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _sel2 = _step5.value;

            if (matches(node, _sel2, ancestry, options)) {
              return false;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return true;

      case 'has':
        {
          var _ret = function () {
            var collector = [];

            var _iterator6 = _createForOfIteratorHelper(selector.selectors),
                _step6;

            try {
              var _loop = function _loop() {
                var sel = _step6.value;
                var a = [];
                estraverse.traverse(node, {
                  enter: function enter(node, parent) {
                    if (parent != null) {
                      a.unshift(parent);
                    }

                    if (matches(node, sel, a, options)) {
                      collector.push(node);
                    }
                  },
                  leave: function leave() {
                    a.shift();
                  },
                  keys: options && options.visitorKeys,
                  fallback: options && options.fallback || 'iteration'
                });
              };

              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            return {
              v: collector.length !== 0
            };
          }();

          if (_typeof(_ret) === "object") return _ret.v;
        }

      case 'child':
        if (matches(node, selector.right, ancestry, options)) {
          return matches(ancestry[0], selector.left, ancestry.slice(1), options);
        }

        return false;

      case 'descendant':
        if (matches(node, selector.right, ancestry, options)) {
          for (var i = 0, l = ancestry.length; i < l; ++i) {
            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {
              return true;
            }
          }
        }

        return false;

      case 'attribute':
        {
          var p = getPath(node, selector.name);

          switch (selector.operator) {
            case void 0:
              return p != null;

            case '=':
              switch (selector.value.type) {
                case 'regexp':
                  return typeof p === 'string' && selector.value.value.test(p);

                case 'literal':
                  return "".concat(selector.value.value) === "".concat(p);

                case 'type':
                  return selector.value.value === _typeof(p);
              }

              throw new Error("Unknown selector value type: ".concat(selector.value.type));

            case '!=':
              switch (selector.value.type) {
                case 'regexp':
                  return !selector.value.value.test(p);

                case 'literal':
                  return "".concat(selector.value.value) !== "".concat(p);

                case 'type':
                  return selector.value.value !== _typeof(p);
              }

              throw new Error("Unknown selector value type: ".concat(selector.value.type));

            case '<=':
              return p <= selector.value.value;

            case '<':
              return p < selector.value.value;

            case '>':
              return p > selector.value.value;

            case '>=':
              return p >= selector.value.value;
          }

          throw new Error("Unknown operator: ".concat(selector.operator));
        }

      case 'sibling':
        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);

      case 'adjacent':
        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);

      case 'nth-child':
        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {
          return selector.index.value - 1;
        }, options);

      case 'nth-last-child':
        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {
          return length - selector.index.value;
        }, options);

      case 'class':
        switch (selector.name.toLowerCase()) {
          case 'statement':
            if (node.type.slice(-9) === 'Statement') return true;
          // fallthrough: interface Declaration <: Statement { }

          case 'declaration':
            return node.type.slice(-11) === 'Declaration';

          case 'pattern':
            if (node.type.slice(-7) === 'Pattern') return true;
          // fallthrough: interface Expression <: Node, Pattern { }

          case 'expression':
            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';

          case 'function':
            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';
        }

        throw new Error("Unknown class name: ".concat(selector.name));
    }

    throw new Error("Unknown selector type: ".concat(selector.type));
  }
  /**
   * Get visitor keys of a given node.
   * @param {external:AST} node The AST node to get keys.
   * @param {ESQueryOptions|undefined} options
   * @returns {string[]} Visitor keys of the node.
   */


  function getVisitorKeys(node, options) {
    var nodeType = node.type;

    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {
      return options.visitorKeys[nodeType];
    }

    if (estraverse.VisitorKeys[nodeType]) {
      return estraverse.VisitorKeys[nodeType];
    }

    if (options && typeof options.fallback === 'function') {
      return options.fallback(node);
    } // 'iteration' fallback


    return Object.keys(node).filter(function (key) {
      return key !== 'type';
    });
  }
  /**
   * Check whether the given value is an ASTNode or not.
   * @param {any} node The value to check.
   * @returns {boolean} `true` if the value is an ASTNode.
   */


  function isNode(node) {
    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';
  }
  /**
   * Determines if the given node has a sibling that matches the
   * given selector.
   * @param {external:AST} node
   * @param {SelectorSequenceAST} selector
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function sibling(node, selector, ancestry, side, options) {
    var _ancestry = _slicedToArray(ancestry, 1),
        parent = _ancestry[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator7 = _createForOfIteratorHelper(keys),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var key = _step7.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var startIndex = listProp.indexOf(node);

          if (startIndex < 0) {
            continue;
          }

          var lowerBound = void 0,
              upperBound = void 0;

          if (side === LEFT_SIDE) {
            lowerBound = 0;
            upperBound = startIndex;
          } else {
            lowerBound = startIndex + 1;
            upperBound = listProp.length;
          }

          for (var k = lowerBound; k < upperBound; ++k) {
            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {
              return true;
            }
          }
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return false;
  }
  /**
   * Determines if the given node has an adjacent sibling that matches
   * the given selector.
   * @param {external:AST} node
   * @param {SelectorSequenceAST} selector
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function adjacent(node, selector, ancestry, side, options) {
    var _ancestry2 = _slicedToArray(ancestry, 1),
        parent = _ancestry2[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator8 = _createForOfIteratorHelper(keys),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var key = _step8.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var idx = listProp.indexOf(node);

          if (idx < 0) {
            continue;
          }

          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {
            return true;
          }

          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {
            return true;
          }
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    return false;
  }
  /**
  * @callback IndexFunction
  * @param {Integer} len Containing list's length
  * @returns {Integer}
  */

  /**
   * Determines if the given node is the nth child, determined by
   * `idxFn`, which is given the containing list's length.
   * @param {external:AST} node
   * @param {external:AST[]} ancestry
   * @param {IndexFunction} idxFn
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function nthChild(node, ancestry, idxFn, options) {
    var _ancestry3 = _slicedToArray(ancestry, 1),
        parent = _ancestry3[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator9 = _createForOfIteratorHelper(keys),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var key = _step9.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var idx = listProp.indexOf(node);

          if (idx >= 0 && idx === idxFn(listProp.length)) {
            return true;
          }
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    return false;
  }
  /**
   * For each selector node marked as a subject, find the portion of the
   * selector that the subject must match.
   * @param {SelectorAST} selector
   * @param {SelectorAST} [ancestor] Defaults to `selector`
   * @returns {SelectorAST[]}
   */


  function subjects(selector, ancestor) {
    if (selector == null || _typeof(selector) != 'object') {
      return [];
    }

    if (ancestor == null) {
      ancestor = selector;
    }

    var results = selector.subject ? [ancestor] : [];

    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          p = _Object$entries$_i[0],
          sel = _Object$entries$_i[1];

      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));
    }

    return results;
  }
  /**
  * @callback TraverseVisitor
  * @param {?external:AST} node
  * @param {?external:AST} parent
  * @param {external:AST[]} ancestry
  */

  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {TraverseVisitor} visitor
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function traverse(ast, selector, visitor, options) {
    if (!selector) {
      return;
    }

    var ancestry = [];
    var altSubjects = subjects(selector);
    estraverse.traverse(ast, {
      enter: function enter(node, parent) {
        if (parent != null) {
          ancestry.unshift(parent);
        }

        if (matches(node, selector, ancestry, options)) {
          if (altSubjects.length) {
            for (var i = 0, l = altSubjects.length; i < l; ++i) {
              if (matches(node, altSubjects[i], ancestry, options)) {
                visitor(node, parent, ancestry);
              }

              for (var k = 0, m = ancestry.length; k < m; ++k) {
                var succeedingAncestry = ancestry.slice(k + 1);

                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {
                  visitor(ancestry[k], parent, succeedingAncestry);
                }
              }
            }
          } else {
            visitor(node, parent, ancestry);
          }
        }
      },
      leave: function leave() {
        ancestry.shift();
      },
      keys: options && options.visitorKeys,
      fallback: options && options.fallback || 'iteration'
    });
  }
  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function match(ast, selector, options) {
    var results = [];
    traverse(ast, selector, function (node) {
      results.push(node);
    }, options);
    return results;
  }
  /**
   * Parse a selector string and return its AST.
   * @param {string} selector
   * @returns {SelectorAST}
   */


  function parse(selector) {
    return parser.parse(selector);
  }
  /**
   * Query the code AST using the selector string.
   * @param {external:AST} ast
   * @param {string} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function query(ast, selector, options) {
    return match(ast, parse(selector), options);
  }

  query.parse = parse;
  query.match = match;
  query.traverse = traverse;
  query.matches = matches;
  query.query = query;

  return query;

})));
ª/parser.jsÆ $/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory();
  }
})(this, function() {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = function(ss) {
            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };
          },
        peg$c1 = function() { return void 0; },
        peg$c2 = " ",
        peg$c3 = peg$literalExpectation(" ", false),
        peg$c4 = /^[^ [\],():#!=><~+.]/,
        peg$c5 = peg$classExpectation([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false),
        peg$c6 = function(i) { return i.join(''); },
        peg$c7 = ">",
        peg$c8 = peg$literalExpectation(">", false),
        peg$c9 = function() { return 'child'; },
        peg$c10 = "~",
        peg$c11 = peg$literalExpectation("~", false),
        peg$c12 = function() { return 'sibling'; },
        peg$c13 = "+",
        peg$c14 = peg$literalExpectation("+", false),
        peg$c15 = function() { return 'adjacent'; },
        peg$c16 = function() { return 'descendant'; },
        peg$c17 = ",",
        peg$c18 = peg$literalExpectation(",", false),
        peg$c19 = function(s, ss) {
          return [s].concat(ss.map(function (s) { return s[3]; }));
        },
        peg$c20 = function(a, ops) {
            return ops.reduce(function (memo, rhs) {
              return { type: rhs[0], left: memo, right: rhs[1] };
            }, a);
          },
        peg$c21 = "!",
        peg$c22 = peg$literalExpectation("!", false),
        peg$c23 = function(subject, as) {
            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };
            if(subject) b.subject = true;
            return b;
          },
        peg$c24 = "*",
        peg$c25 = peg$literalExpectation("*", false),
        peg$c26 = function(a) { return { type: 'wildcard', value: a }; },
        peg$c27 = "#",
        peg$c28 = peg$literalExpectation("#", false),
        peg$c29 = function(i) { return { type: 'identifier', value: i }; },
        peg$c30 = "[",
        peg$c31 = peg$literalExpectation("[", false),
        peg$c32 = "]",
        peg$c33 = peg$literalExpectation("]", false),
        peg$c34 = function(v) { return v; },
        peg$c35 = /^[><!]/,
        peg$c36 = peg$classExpectation([">", "<", "!"], false, false),
        peg$c37 = "=",
        peg$c38 = peg$literalExpectation("=", false),
        peg$c39 = function(a) { return (a || '') + '='; },
        peg$c40 = /^[><]/,
        peg$c41 = peg$classExpectation([">", "<"], false, false),
        peg$c42 = ".",
        peg$c43 = peg$literalExpectation(".", false),
        peg$c44 = function(a, as) {
            return [].concat.apply([a], as).join('');
          },
        peg$c45 = function(name, op, value) {
              return { type: 'attribute', name: name, operator: op, value: value };
            },
        peg$c46 = function(name) { return { type: 'attribute', name: name }; },
        peg$c47 = "\"",
        peg$c48 = peg$literalExpectation("\"", false),
        peg$c49 = /^[^\\"]/,
        peg$c50 = peg$classExpectation(["\\", "\""], true, false),
        peg$c51 = "\\",
        peg$c52 = peg$literalExpectation("\\", false),
        peg$c53 = peg$anyExpectation(),
        peg$c54 = function(a, b) { return a + b; },
        peg$c55 = function(d) {
                return { type: 'literal', value: strUnescape(d.join('')) };
              },
        peg$c56 = "'",
        peg$c57 = peg$literalExpectation("'", false),
        peg$c58 = /^[^\\']/,
        peg$c59 = peg$classExpectation(["\\", "'"], true, false),
        peg$c60 = /^[0-9]/,
        peg$c61 = peg$classExpectation([["0", "9"]], false, false),
        peg$c62 = function(a, b) {
                // Can use `a.flat().join('')` once supported
                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';
                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };
              },
        peg$c63 = function(i) { return { type: 'literal', value: i }; },
        peg$c64 = "type(",
        peg$c65 = peg$literalExpectation("type(", false),
        peg$c66 = /^[^ )]/,
        peg$c67 = peg$classExpectation([" ", ")"], true, false),
        peg$c68 = ")",
        peg$c69 = peg$literalExpectation(")", false),
        peg$c70 = function(t) { return { type: 'type', value: t.join('') }; },
        peg$c71 = /^[imsu]/,
        peg$c72 = peg$classExpectation(["i", "m", "s", "u"], false, false),
        peg$c73 = "/",
        peg$c74 = peg$literalExpectation("/", false),
        peg$c75 = /^[^\/]/,
        peg$c76 = peg$classExpectation(["/"], true, false),
        peg$c77 = function(d, flgs) { return {
              type: 'regexp', value: new RegExp(d.join(''), flgs ? flgs.join('') : '') };
            },
        peg$c78 = function(i, is) {
          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};
        },
        peg$c79 = ":not(",
        peg$c80 = peg$literalExpectation(":not(", false),
        peg$c81 = function(ss) { return { type: 'not', selectors: ss }; },
        peg$c82 = ":matches(",
        peg$c83 = peg$literalExpectation(":matches(", false),
        peg$c84 = function(ss) { return { type: 'matches', selectors: ss }; },
        peg$c85 = ":has(",
        peg$c86 = peg$literalExpectation(":has(", false),
        peg$c87 = function(ss) { return { type: 'has', selectors: ss }; },
        peg$c88 = ":first-child",
        peg$c89 = peg$literalExpectation(":first-child", false),
        peg$c90 = function() { return nth(1); },
        peg$c91 = ":last-child",
        peg$c92 = peg$literalExpectation(":last-child", false),
        peg$c93 = function() { return nthLast(1); },
        peg$c94 = ":nth-child(",
        peg$c95 = peg$literalExpectation(":nth-child(", false),
        peg$c96 = function(n) { return nth(parseInt(n.join(''), 10)); },
        peg$c97 = ":nth-last-child(",
        peg$c98 = peg$literalExpectation(":nth-last-child(", false),
        peg$c99 = function(n) { return nthLast(parseInt(n.join(''), 10)); },
        peg$c100 = ":",
        peg$c101 = peg$literalExpectation(":", false),
        peg$c102 = "statement",
        peg$c103 = peg$literalExpectation("statement", true),
        peg$c104 = "expression",
        peg$c105 = peg$literalExpectation("expression", true),
        peg$c106 = "declaration",
        peg$c107 = peg$literalExpectation("declaration", true),
        peg$c108 = "function",
        peg$c109 = peg$literalExpectation("function", true),
        peg$c110 = "pattern",
        peg$c111 = peg$literalExpectation("pattern", true),
        peg$c112 = function(c) {
          return { type: 'class', name: c };
        },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$resultsCache = {},

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 30 + 0,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseselectors();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1();
        }
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      var key    = peg$currPos * 30 + 1,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c2;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c3); }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifierName() {
      var s0, s1, s2;

      var key    = peg$currPos * 30 + 2,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      if (peg$c4.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c4.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinaryOp() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 30 + 3,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s2 = peg$c7;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c8); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 126) {
            s2 = peg$c10;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c12();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s2 = peg$c13;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 32) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c3); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseselectors() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 30 + 4,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseselector();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c17;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseselector();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c17;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseselector();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseselector() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 5,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsesequence();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parsebinaryOp();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsesequence();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parsebinaryOp();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesequence();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c20(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesequence() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 30 + 6,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c21;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseatom();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseatom();
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c23(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseatom() {
      var s0;

      var key    = peg$currPos * 30 + 7,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsewildcard();
      if (s0 === peg$FAILED) {
        s0 = peg$parseidentifier();
        if (s0 === peg$FAILED) {
          s0 = peg$parseattr();
          if (s0 === peg$FAILED) {
            s0 = peg$parsefield();
            if (s0 === peg$FAILED) {
              s0 = peg$parsenegation();
              if (s0 === peg$FAILED) {
                s0 = peg$parsematches();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsehas();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsefirstChild();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parselastChild();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsenthChild();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenthLastChild();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseclass();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewildcard() {
      var s0, s1;

      var key    = peg$currPos * 30 + 8,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c24;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2;

      var key    = peg$currPos * 30 + 9,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifierName();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseattr() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 10,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c30;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseattrValue();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c32;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c33); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c34(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseattrOps() {
      var s0, s1, s2;

      var key    = peg$currPos * 30 + 11,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (peg$c35.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c37;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        if (peg$c40.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseattrEqOps() {
      var s0, s1, s2;

      var key    = peg$currPos * 30 + 12,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c21;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c37;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseattrName() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 13,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifierName();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c42;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseidentifierName();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c42;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseidentifierName();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c44(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseattrValue() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 14,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseattrName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseattrEqOps();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsetype();
              if (s5 === peg$FAILED) {
                s5 = peg$parseregex();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c45(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseattrName();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseattrOps();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsestring();
                if (s5 === peg$FAILED) {
                  s5 = peg$parsenumber();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parsepath();
                  }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c45(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseattrName();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s1);
          }
          s0 = s1;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 15,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c47;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c49.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c50); }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s4 = peg$c51;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c52); }
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c54(s4, s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c49.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c50); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s4 = peg$c51;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c53); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c54(s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c47;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c48); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c55(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c56;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c58.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s4 = peg$c51;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c53); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c54(s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c58.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c52); }
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c53); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c54(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c56;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c57); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c55(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 30 + 16,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c60.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c42;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c60.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c60.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c61); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c62(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepath() {
      var s0, s1;

      var key    = peg$currPos * 30 + 17,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifierName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c63(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetype() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 18,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c64) {
        s1 = peg$c64;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c66.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c67); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c66.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c67); }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c70(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseflags() {
      var s0, s1;

      var key    = peg$currPos * 30 + 19,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (peg$c71.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c72); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c71.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c72); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseregex() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 30 + 20,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c75.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c75.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c76); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c73;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c74); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseflags();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c77(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefield() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 30 + 21,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c42;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifierName();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s5 = peg$c42;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseidentifierName();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s5 = peg$c42;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseidentifierName();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c78(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenegation() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 22,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c79) {
        s1 = peg$c79;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseselectors();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c81(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsematches() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 23,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c82) {
        s1 = peg$c82;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseselectors();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c84(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsehas() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 24,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c85) {
        s1 = peg$c85;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseselectors();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c87(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefirstChild() {
      var s0, s1;

      var key    = peg$currPos * 30 + 25,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 12) === peg$c88) {
        s1 = peg$c88;
        peg$currPos += 12;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c90();
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselastChild() {
      var s0, s1;

      var key    = peg$currPos * 30 + 26,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11) === peg$c91) {
        s1 = peg$c91;
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c93();
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenthChild() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 27,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11) === peg$c94) {
        s1 = peg$c94;
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c95); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c61); }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c96(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenthLastChild() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 30 + 28,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 16) === peg$c97) {
        s1 = peg$c97;
        peg$currPos += 16;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c61); }
              }
            }
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c68;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c99(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclass() {
      var s0, s1, s2;

      var key    = peg$currPos * 30 + 29,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {
          s2 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c103); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {
            s2 = input.substr(peg$currPos, 10);
            peg$currPos += 10;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c105); }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {
              s2 = input.substr(peg$currPos, 11);
              peg$currPos += 11;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c107); }
            }
            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {
                s2 = input.substr(peg$currPos, 8);
                peg$currPos += 8;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c109); }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {
                  s2 = input.substr(peg$currPos, 7);
                  peg$currPos += 7;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c111); }
                }
              }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c112(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }


      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }
      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }
      function strUnescape(s) {
        return s.replace(/\\(.)/g, function(match, ch) {
          switch(ch) {
            case 'b': return '\b';
            case 'f': return '\f';
            case 'n': return '\n';
            case 'r': return '\r';
            case 't': return '\t';
            case 'v': return '\v';
            default: return ch;
          }
        });
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
});
¼/dist/esquery.esm.min.js.mapÆ ‡#{"version":3,"file":"esquery.esm.min.js","sources":["../node_modules/estraverse/estraverse.js","../parser.js","../esquery.js"],"sourcesContent":["/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n  \n    function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n            if (leavelist[i].node === candidate) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n\n                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                              continue;\n                            }\n\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        if (candidateExistsInLeaveList(leavelist, candidate)) {\n                          continue;\n                        }\n\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\n          return [s].concat(ss.map(function (s) { return s[3]; }));\n        },\n        peg$c20 = function(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return { type: rhs[0], left: memo, right: rhs[1] };\n            }, a);\n          },\n        peg$c21 = \"!\",\n        peg$c22 = peg$literalExpectation(\"!\", false),\n        peg$c23 = function(subject, as) {\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\n            if(subject) b.subject = true;\n            return b;\n          },\n        peg$c24 = \"*\",\n        peg$c25 = peg$literalExpectation(\"*\", false),\n        peg$c26 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c27 = \"#\",\n        peg$c28 = peg$literalExpectation(\"#\", false),\n        peg$c29 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c30 = \"[\",\n        peg$c31 = peg$literalExpectation(\"[\", false),\n        peg$c32 = \"]\",\n        peg$c33 = peg$literalExpectation(\"]\", false),\n        peg$c34 = function(v) { return v; },\n        peg$c35 = /^[><!]/,\n        peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c37 = \"=\",\n        peg$c38 = peg$literalExpectation(\"=\", false),\n        peg$c39 = function(a) { return (a || '') + '='; },\n        peg$c40 = /^[><]/,\n        peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c42 = \".\",\n        peg$c43 = peg$literalExpectation(\".\", false),\n        peg$c44 = function(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n        peg$c45 = function(name, op, value) {\n              return { type: 'attribute', name: name, operator: op, value: value };\n            },\n        peg$c46 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c47 = \"\\\"\",\n        peg$c48 = peg$literalExpectation(\"\\\"\", false),\n        peg$c49 = /^[^\\\\\"]/,\n        peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c51 = \"\\\\\",\n        peg$c52 = peg$literalExpectation(\"\\\\\", false),\n        peg$c53 = peg$anyExpectation(),\n        peg$c54 = function(a, b) { return a + b; },\n        peg$c55 = function(d) {\n                return { type: 'literal', value: strUnescape(d.join('')) };\n              },\n        peg$c56 = \"'\",\n        peg$c57 = peg$literalExpectation(\"'\", false),\n        peg$c58 = /^[^\\\\']/,\n        peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c60 = /^[0-9]/,\n        peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c62 = function(a, b) {\n                // Can use `a.flat().join('')` once supported\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\n              },\n        peg$c63 = function(i) { return { type: 'literal', value: i }; },\n        peg$c64 = \"type(\",\n        peg$c65 = peg$literalExpectation(\"type(\", false),\n        peg$c66 = /^[^ )]/,\n        peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c68 = \")\",\n        peg$c69 = peg$literalExpectation(\")\", false),\n        peg$c70 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c71 = /^[imsu]/,\n        peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c73 = \"/\",\n        peg$c74 = peg$literalExpectation(\"/\", false),\n        peg$c75 = /^[^\\/]/,\n        peg$c76 = peg$classExpectation([\"/\"], true, false),\n        peg$c77 = function(d, flgs) { return {\n              type: 'regexp', value: new RegExp(d.join(''), flgs ? flgs.join('') : '') };\n            },\n        peg$c78 = function(i, is) {\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\n        },\n        peg$c79 = \":not(\",\n        peg$c80 = peg$literalExpectation(\":not(\", false),\n        peg$c81 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c82 = \":matches(\",\n        peg$c83 = peg$literalExpectation(\":matches(\", false),\n        peg$c84 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c85 = \":has(\",\n        peg$c86 = peg$literalExpectation(\":has(\", false),\n        peg$c87 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c88 = \":first-child\",\n        peg$c89 = peg$literalExpectation(\":first-child\", false),\n        peg$c90 = function() { return nth(1); },\n        peg$c91 = \":last-child\",\n        peg$c92 = peg$literalExpectation(\":last-child\", false),\n        peg$c93 = function() { return nthLast(1); },\n        peg$c94 = \":nth-child(\",\n        peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c96 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c97 = \":nth-last-child(\",\n        peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c99 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c100 = \":\",\n        peg$c101 = peg$literalExpectation(\":\", false),\n        peg$c102 = \"statement\",\n        peg$c103 = peg$literalExpectation(\"statement\", true),\n        peg$c104 = \"expression\",\n        peg$c105 = peg$literalExpectation(\"expression\", true),\n        peg$c106 = \"declaration\",\n        peg$c107 = peg$literalExpectation(\"declaration\", true),\n        peg$c108 = \"function\",\n        peg$c109 = peg$literalExpectation(\"function\", true),\n        peg$c110 = \"pattern\",\n        peg$c111 = peg$literalExpectation(\"pattern\", true),\n        peg$c112 = function(c) {\n          return { type: 'class', name: c };\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 30 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c23(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 30 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsehas();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsefirstChild();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parselastChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsenthChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthLastChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseclass();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c24;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c32;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c35.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c40.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c42;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c42;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c44(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c45(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c45(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c46(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c47;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c49.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c51;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c54(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c49.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c50); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c47;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c48); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c56;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c57); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c58.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c59); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c58.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c52); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c56;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c55(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c42;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c61); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c62(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c64) {\n        s1 = peg$c64;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c66.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c67); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c70(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c71.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 30 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c75.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c76); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c73;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c74); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c77(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 30 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c42;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c42;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c42;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c78(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c79) {\n        s1 = peg$c79;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c81(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c82) {\n        s1 = peg$c82;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c84(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c93();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c96(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c97) {\n        s1 = peg$c97;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c99(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c100;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c101); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n          s2 = input.substr(peg$currPos, 9);\n          peg$currPos += 9;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c103); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n            s2 = input.substr(peg$currPos, 10);\n            peg$currPos += 10;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c105); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n              s2 = input.substr(peg$currPos, 11);\n              peg$currPos += 11;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c107); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                s2 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c109); }\n              }\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                  s2 = input.substr(peg$currPos, 7);\n                  peg$currPos += 7;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c111); }\n                }\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c112(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function(match, ch) {\n          switch(ch) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            default: return ch;\n          }\n        });\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\nimport estraverse from 'estraverse';\nimport parser from './parser.js';\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nconst LEFT_SIDE = 'LEFT_SIDE';\nconst RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string} key\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, key) {\n    const keys = key.split('.');\n    for (const key of keys) {\n        if (obj == null) { return obj; }\n        obj = obj[key];\n    }\n    return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path) {\n    if (path.length === 0) { return node === ancestor; }\n    if (ancestor == null) { return false; }\n    const field = ancestor[path[0]];\n    const remainingPath = path.slice(1);\n    if (Array.isArray(field)) {\n        for (const component of field) {\n            if (inPath(node, component, remainingPath)) { return true; }\n        }\n        return false;\n    } else {\n        return inPath(node, field, remainingPath);\n    }\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n/**\n * @typedef {object} ESQueryOptions\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    switch(selector.type) {\n        case 'wildcard':\n            return true;\n\n        case 'identifier':\n            return selector.value.toLowerCase() === node.type.toLowerCase();\n\n        case 'field': {\n            const path = selector.name.split('.');\n            const ancestor = ancestry[path.length - 1];\n            return inPath(node, ancestor, path);\n\n        }\n        case 'matches':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return true; }\n            }\n            return false;\n\n        case 'compound':\n            for (const sel of selector.selectors) {\n                if (!matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'not':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'has': {\n            const collector = [];\n            for (const sel of selector.selectors) {\n                const a = [];\n                estraverse.traverse(node, {\n                    enter (node, parent) {\n                        if (parent != null) { a.unshift(parent); }\n                        if (matches(node, sel, a, options)) {\n                            collector.push(node);\n                        }\n                    },\n                    leave () { a.shift(); },\n                    keys: options && options.visitorKeys,\n                    fallback: options && options.fallback || 'iteration'\n                });\n            }\n            return collector.length !== 0;\n\n        }\n        case 'child':\n            if (matches(node, selector.right, ancestry, options)) {\n                return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n            }\n            return false;\n\n        case 'descendant':\n            if (matches(node, selector.right, ancestry, options)) {\n                for (let i = 0, l = ancestry.length; i < l; ++i) {\n                    if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n\n        case 'attribute': {\n            const p = getPath(node, selector.name);\n            switch (selector.operator) {\n                case void 0:\n                    return p != null;\n                case '=':\n                    switch (selector.value.type) {\n                        case 'regexp': return typeof p === 'string' && selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` === `${p}`;\n                        case 'type': return selector.value.value === typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '!=':\n                    switch (selector.value.type) {\n                        case 'regexp': return !selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` !== `${p}`;\n                        case 'type': return selector.value.value !== typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '<=': return p <= selector.value.value;\n                case '<': return p < selector.value.value;\n                case '>': return p > selector.value.value;\n                case '>=': return p >= selector.value.value;\n            }\n            throw new Error(`Unknown operator: ${selector.operator}`);\n        }\n        case 'sibling':\n            return matches(node, selector.right, ancestry, options) &&\n                sibling(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.left.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n        case 'adjacent':\n            return matches(node, selector.right, ancestry, options) &&\n                adjacent(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.right.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n        case 'nth-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function () {\n                    return selector.index.value - 1;\n                }, options);\n\n        case 'nth-last-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function (length) {\n                    return length - selector.index.value;\n                }, options);\n\n        case 'class':\n            switch(selector.name.toLowerCase()){\n                case 'statement':\n                    if(node.type.slice(-9) === 'Statement') return true;\n                    // fallthrough: interface Declaration <: Statement { }\n                case 'declaration':\n                    return node.type.slice(-11) === 'Declaration';\n                case 'pattern':\n                    if(node.type.slice(-7) === 'Pattern') return true;\n                    // fallthrough: interface Expression <: Node, Pattern { }\n                case 'expression':\n                    return node.type.slice(-10) === 'Expression' ||\n                        node.type.slice(-7) === 'Literal' ||\n                        (\n                            node.type === 'Identifier' &&\n                            (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                        ) ||\n                        node.type === 'MetaProperty';\n                case 'function':\n                    return node.type === 'FunctionDeclaration' ||\n                        node.type === 'FunctionExpression' ||\n                        node.type === 'ArrowFunctionExpression';\n            }\n            throw new Error(`Unknown class name: ${selector.name}`);\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeType = node.type;\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== 'type';\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node) {\n    return node !== null && typeof node === 'object' && typeof node.type === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) &&  matches(listProp[idx + 1], selector, ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n* @callback IndexFunction\n* @param {Integer} len Containing list's length\n* @returns {Integer}\n*/\n\n/**\n * Determines if the given node is the nth child, determined by\n * `idxFn`, which is given the containing list's length.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {IndexFunction} idxFn\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, idxFn, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx >= 0 && idx === idxFn(listProp.length)) { return true; }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    for (const [p, sel] of Object.entries(selector)) {\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matches(node, selector, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (matches(node, altSubjects[i], ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["clone","exports","Syntax","VisitorOption","VisitorKeys","BREAK","SKIP","REMOVE","deepCopy","obj","key","val","ret","hasOwnProperty","Reference","parent","Element","node","path","wrap","ref","Controller","isNode","type","isProperty","nodeType","ObjectExpression","ObjectPattern","candidateExistsInLeaveList","leavelist","candidate","i","length","traverse","root","visitor","extendCommentRange","comment","tokens","target","array","func","diff","len","current","upperBound","token","range","extendedRange","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DirectiveStatement","DoWhileStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","GeneratorExpression","Identifier","IfStatement","ImportExpression","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","ModuleSpecifier","NewExpression","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchStatement","SwitchCase","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","Break","Skip","Remove","prototype","replace","this","remove","Array","isArray","splice","iz","j","jz","result","addToPath","push","__current","__leavelist","parents","__execute","callback","element","previous","undefined","__state","call","notify","flag","skip","__initialize","__worklist","__fallback","fallback","Object","keys","__keys","assign","create","worklist","current2","candidates","sentinel","pop","enter","Error","leave","outer","removeElem","nextElem","attachComments","tree","providedComments","cursor","comments","leadingComments","trailingComments","cloneEnvironment","module","peg$SyntaxError","message","expected","found","location","name","captureStackTrace","child","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","descriptions","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c22","peg$c25","peg$c28","peg$c31","peg$c33","peg$c35","peg$c36","peg$c38","peg$c39","a","peg$c40","peg$c41","peg$c43","peg$c45","op","value","operator","peg$c48","peg$c49","peg$c50","peg$c52","peg$c53","peg$c54","b","peg$c55","d","match","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c65","peg$c66","peg$c67","peg$c69","peg$c71","peg$c72","peg$c74","peg$c75","peg$c76","peg$c80","peg$c83","peg$c86","peg$c89","peg$c92","peg$c95","peg$c98","peg$c101","peg$c103","peg$c105","peg$c107","peg$c109","peg$c111","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","s0","s1","s2","ss","cached","peg$resultsCache","nextPos","peg$parse_","peg$parseselectors","selectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","concat","map","peg$parsesequence","reduce","memo","rhs","left","right","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","toLowerCase","peg$parseclass","n","index","factory","matches","selector","ancestry","split","ancestor","inPath","field","remainingPath","sel","collector","estraverse","unshift","shift","visitorKeys","l","getPath","sibling","adjacent","nthChild","getVisitorKeys","filter","_typeof","side","listProp","startIndex","indexOf","lowerBound","k","idx","idxFn","subjects","results","_objectEntries","ast","altSubjects","m","succeedingAncestry","parser","query"],"mappings":"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"}½/dist/esquery.lite.min.js.mapÆ ì
{"version":3,"file":"esquery.lite.min.js","sources":["../parser.js","../esquery.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\n          return [s].concat(ss.map(function (s) { return s[3]; }));\n        },\n        peg$c20 = function(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return { type: rhs[0], left: memo, right: rhs[1] };\n            }, a);\n          },\n        peg$c21 = \"!\",\n        peg$c22 = peg$literalExpectation(\"!\", false),\n        peg$c23 = function(subject, as) {\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\n            if(subject) b.subject = true;\n            return b;\n          },\n        peg$c24 = \"*\",\n        peg$c25 = peg$literalExpectation(\"*\", false),\n        peg$c26 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c27 = \"#\",\n        peg$c28 = peg$literalExpectation(\"#\", false),\n        peg$c29 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c30 = \"[\",\n        peg$c31 = peg$literalExpectation(\"[\", false),\n        peg$c32 = \"]\",\n        peg$c33 = peg$literalExpectation(\"]\", false),\n        peg$c34 = function(v) { return v; },\n        peg$c35 = /^[><!]/,\n        peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c37 = \"=\",\n        peg$c38 = peg$literalExpectation(\"=\", false),\n        peg$c39 = function(a) { return (a || '') + '='; },\n        peg$c40 = /^[><]/,\n        peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c42 = \".\",\n        peg$c43 = peg$literalExpectation(\".\", false),\n        peg$c44 = function(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n        peg$c45 = function(name, op, value) {\n              return { type: 'attribute', name: name, operator: op, value: value };\n            },\n        peg$c46 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c47 = \"\\\"\",\n        peg$c48 = peg$literalExpectation(\"\\\"\", false),\n        peg$c49 = /^[^\\\\\"]/,\n        peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c51 = \"\\\\\",\n        peg$c52 = peg$literalExpectation(\"\\\\\", false),\n        peg$c53 = peg$anyExpectation(),\n        peg$c54 = function(a, b) { return a + b; },\n        peg$c55 = function(d) {\n                return { type: 'literal', value: strUnescape(d.join('')) };\n              },\n        peg$c56 = \"'\",\n        peg$c57 = peg$literalExpectation(\"'\", false),\n        peg$c58 = /^[^\\\\']/,\n        peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c60 = /^[0-9]/,\n        peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c62 = function(a, b) {\n                // Can use `a.flat().join('')` once supported\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\n              },\n        peg$c63 = function(i) { return { type: 'literal', value: i }; },\n        peg$c64 = \"type(\",\n        peg$c65 = peg$literalExpectation(\"type(\", false),\n        peg$c66 = /^[^ )]/,\n        peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c68 = \")\",\n        peg$c69 = peg$literalExpectation(\")\", false),\n        peg$c70 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c71 = /^[imsu]/,\n        peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c73 = \"/\",\n        peg$c74 = peg$literalExpectation(\"/\", false),\n        peg$c75 = /^[^\\/]/,\n        peg$c76 = peg$classExpectation([\"/\"], true, false),\n        peg$c77 = function(d, flgs) { return {\n              type: 'regexp', value: new RegExp(d.join(''), flgs ? flgs.join('') : '') };\n            },\n        peg$c78 = function(i, is) {\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\n        },\n        peg$c79 = \":not(\",\n        peg$c80 = peg$literalExpectation(\":not(\", false),\n        peg$c81 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c82 = \":matches(\",\n        peg$c83 = peg$literalExpectation(\":matches(\", false),\n        peg$c84 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c85 = \":has(\",\n        peg$c86 = peg$literalExpectation(\":has(\", false),\n        peg$c87 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c88 = \":first-child\",\n        peg$c89 = peg$literalExpectation(\":first-child\", false),\n        peg$c90 = function() { return nth(1); },\n        peg$c91 = \":last-child\",\n        peg$c92 = peg$literalExpectation(\":last-child\", false),\n        peg$c93 = function() { return nthLast(1); },\n        peg$c94 = \":nth-child(\",\n        peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c96 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c97 = \":nth-last-child(\",\n        peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c99 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c100 = \":\",\n        peg$c101 = peg$literalExpectation(\":\", false),\n        peg$c102 = \"statement\",\n        peg$c103 = peg$literalExpectation(\"statement\", true),\n        peg$c104 = \"expression\",\n        peg$c105 = peg$literalExpectation(\"expression\", true),\n        peg$c106 = \"declaration\",\n        peg$c107 = peg$literalExpectation(\"declaration\", true),\n        peg$c108 = \"function\",\n        peg$c109 = peg$literalExpectation(\"function\", true),\n        peg$c110 = \"pattern\",\n        peg$c111 = peg$literalExpectation(\"pattern\", true),\n        peg$c112 = function(c) {\n          return { type: 'class', name: c };\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 30 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c23(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 30 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsehas();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsefirstChild();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parselastChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsenthChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthLastChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseclass();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c24;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c32;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c35.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c40.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c42;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c42;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c44(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c45(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c45(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c46(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c47;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c49.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c51;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c54(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c49.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c50); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c47;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c48); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c56;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c57); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c58.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c59); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c58.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c52); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c56;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c55(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c42;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c61); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c62(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c64) {\n        s1 = peg$c64;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c66.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c67); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c70(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c71.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 30 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c75.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c76); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c73;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c74); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c77(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 30 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c42;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c42;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c42;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c78(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c79) {\n        s1 = peg$c79;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c81(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c82) {\n        s1 = peg$c82;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c84(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c93();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c96(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c97) {\n        s1 = peg$c97;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c99(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c100;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c101); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n          s2 = input.substr(peg$currPos, 9);\n          peg$currPos += 9;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c103); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n            s2 = input.substr(peg$currPos, 10);\n            peg$currPos += 10;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c105); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n              s2 = input.substr(peg$currPos, 11);\n              peg$currPos += 11;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c107); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                s2 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c109); }\n              }\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                  s2 = input.substr(peg$currPos, 7);\n                  peg$currPos += 7;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c111); }\n                }\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c112(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function(match, ch) {\n          switch(ch) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            default: return ch;\n          }\n        });\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\nimport estraverse from 'estraverse';\nimport parser from './parser.js';\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nconst LEFT_SIDE = 'LEFT_SIDE';\nconst RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string} key\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, key) {\n    const keys = key.split('.');\n    for (const key of keys) {\n        if (obj == null) { return obj; }\n        obj = obj[key];\n    }\n    return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path) {\n    if (path.length === 0) { return node === ancestor; }\n    if (ancestor == null) { return false; }\n    const field = ancestor[path[0]];\n    const remainingPath = path.slice(1);\n    if (Array.isArray(field)) {\n        for (const component of field) {\n            if (inPath(node, component, remainingPath)) { return true; }\n        }\n        return false;\n    } else {\n        return inPath(node, field, remainingPath);\n    }\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n/**\n * @typedef {object} ESQueryOptions\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    switch(selector.type) {\n        case 'wildcard':\n            return true;\n\n        case 'identifier':\n            return selector.value.toLowerCase() === node.type.toLowerCase();\n\n        case 'field': {\n            const path = selector.name.split('.');\n            const ancestor = ancestry[path.length - 1];\n            return inPath(node, ancestor, path);\n\n        }\n        case 'matches':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return true; }\n            }\n            return false;\n\n        case 'compound':\n            for (const sel of selector.selectors) {\n                if (!matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'not':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'has': {\n            const collector = [];\n            for (const sel of selector.selectors) {\n                const a = [];\n                estraverse.traverse(node, {\n                    enter (node, parent) {\n                        if (parent != null) { a.unshift(parent); }\n                        if (matches(node, sel, a, options)) {\n                            collector.push(node);\n                        }\n                    },\n                    leave () { a.shift(); },\n                    keys: options && options.visitorKeys,\n                    fallback: options && options.fallback || 'iteration'\n                });\n            }\n            return collector.length !== 0;\n\n        }\n        case 'child':\n            if (matches(node, selector.right, ancestry, options)) {\n                return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n            }\n            return false;\n\n        case 'descendant':\n            if (matches(node, selector.right, ancestry, options)) {\n                for (let i = 0, l = ancestry.length; i < l; ++i) {\n                    if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n\n        case 'attribute': {\n            const p = getPath(node, selector.name);\n            switch (selector.operator) {\n                case void 0:\n                    return p != null;\n                case '=':\n                    switch (selector.value.type) {\n                        case 'regexp': return typeof p === 'string' && selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` === `${p}`;\n                        case 'type': return selector.value.value === typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '!=':\n                    switch (selector.value.type) {\n                        case 'regexp': return !selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` !== `${p}`;\n                        case 'type': return selector.value.value !== typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '<=': return p <= selector.value.value;\n                case '<': return p < selector.value.value;\n                case '>': return p > selector.value.value;\n                case '>=': return p >= selector.value.value;\n            }\n            throw new Error(`Unknown operator: ${selector.operator}`);\n        }\n        case 'sibling':\n            return matches(node, selector.right, ancestry, options) &&\n                sibling(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.left.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n        case 'adjacent':\n            return matches(node, selector.right, ancestry, options) &&\n                adjacent(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.right.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n        case 'nth-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function () {\n                    return selector.index.value - 1;\n                }, options);\n\n        case 'nth-last-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function (length) {\n                    return length - selector.index.value;\n                }, options);\n\n        case 'class':\n            switch(selector.name.toLowerCase()){\n                case 'statement':\n                    if(node.type.slice(-9) === 'Statement') return true;\n                    // fallthrough: interface Declaration <: Statement { }\n                case 'declaration':\n                    return node.type.slice(-11) === 'Declaration';\n                case 'pattern':\n                    if(node.type.slice(-7) === 'Pattern') return true;\n                    // fallthrough: interface Expression <: Node, Pattern { }\n                case 'expression':\n                    return node.type.slice(-10) === 'Expression' ||\n                        node.type.slice(-7) === 'Literal' ||\n                        (\n                            node.type === 'Identifier' &&\n                            (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                        ) ||\n                        node.type === 'MetaProperty';\n                case 'function':\n                    return node.type === 'FunctionDeclaration' ||\n                        node.type === 'FunctionExpression' ||\n                        node.type === 'ArrowFunctionExpression';\n            }\n            throw new Error(`Unknown class name: ${selector.name}`);\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeType = node.type;\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== 'type';\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node) {\n    return node !== null && typeof node === 'object' && typeof node.type === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) &&  matches(listProp[idx + 1], selector, ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n* @callback IndexFunction\n* @param {Integer} len Containing list's length\n* @returns {Integer}\n*/\n\n/**\n * Determines if the given node is the nth child, determined by\n * `idxFn`, which is given the containing list's length.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {IndexFunction} idxFn\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, idxFn, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx >= 0 && idx === idxFn(listProp.length)) { return true; }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    for (const [p, sel] of Object.entries(selector)) {\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matches(node, selector, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (matches(node, altSubjects[i], ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["module","exports","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","this","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","i","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c22","peg$c25","peg$c28","peg$c31","peg$c33","peg$c35","peg$c36","peg$c38","peg$c39","a","peg$c40","peg$c41","peg$c43","peg$c45","op","value","operator","peg$c48","peg$c49","peg$c50","peg$c52","peg$c53","peg$c54","b","peg$c55","d","match","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c65","peg$c66","peg$c67","peg$c69","peg$c71","peg$c72","peg$c74","peg$c75","peg$c76","peg$c80","peg$c83","peg$c86","peg$c89","peg$c92","peg$c95","peg$c98","peg$c101","peg$c103","peg$c105","peg$c107","peg$c109","peg$c111","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","s0","s1","s2","ss","key","cached","nextPos","result","peg$parse_","peg$parseselectors","selectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","concat","map","peg$parsesequence","reduce","memo","rhs","left","right","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","toLowerCase","peg$parseclass","n","index","factory","matches","node","selector","ancestry","path","split","ancestor","inPath","field","remainingPath","isArray","sel","collector","estraverse","traverse","enter","unshift","leave","shift","keys","visitorKeys","fallback","l","obj","getPath","sibling","adjacent","nthChild","getVisitorKeys","nodeType","VisitorKeys","Object","filter","isNode","_typeof","side","listProp","startIndex","indexOf","lowerBound","upperBound","k","idx","idxFn","subjects","results","_objectEntries","ast","visitor","altSubjects","m","succeedingAncestry","parser","query"],"mappings":"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"}ª/README.mdÅsESQuery is a library for querying the AST output by Esprima for patterns of syntax using a CSS style selector system. Check out the demo:

[demo](https://estools.github.io/esquery/)

The following selectors are supported:
* AST node type: `ForStatement`
* [wildcard](http://dev.w3.org/csswg/selectors4/#universal-selector): `*`
* [attribute existence](http://dev.w3.org/csswg/selectors4/#attribute-selectors): `[attr]`
* [attribute value](http://dev.w3.org/csswg/selectors4/#attribute-selectors): `[attr="foo"]` or `[attr=123]`
* attribute regex: `[attr=/foo.*/]` or (with flags) `[attr=/foo.*/is]`
* attribute conditions: `[attr!="foo"]`, `[attr>2]`, `[attr<3]`, `[attr>=2]`, or `[attr<=3]`
* nested attribute: `[attr.level2="foo"]`
* field: `FunctionDeclaration > Identifier.id`
* [First](http://dev.w3.org/csswg/selectors4/#the-first-child-pseudo) or [last](http://dev.w3.org/csswg/selectors4/#the-last-child-pseudo) child: `:first-child` or `:last-child`
* [nth-child](http://dev.w3.org/csswg/selectors4/#the-nth-child-pseudo) (no ax+b support): `:nth-child(2)`
* [nth-last-child](http://dev.w3.org/csswg/selectors4/#the-nth-last-child-pseudo) (no ax+b support): `:nth-last-child(1)`
* [descendant](http://dev.w3.org/csswg/selectors4/#descendant-combinators): `ancestor descendant`
* [child](http://dev.w3.org/csswg/selectors4/#child-combinators): `parent > child`
* [following sibling](http://dev.w3.org/csswg/selectors4/#general-sibling-combinators): `node ~ sibling`
* [adjacent sibling](http://dev.w3.org/csswg/selectors4/#adjacent-sibling-combinators): `node + adjacent`
* [negation](http://dev.w3.org/csswg/selectors4/#negation-pseudo): `:not(ForStatement)`
* [has](https://drafts.csswg.org/selectors-4/#has-pseudo): `:has(ForStatement)`
* [matches-any](http://dev.w3.org/csswg/selectors4/#matches): `:matches([attr] > :first-child, :last-child)`
* [subject indicator](http://dev.w3.org/csswg/selectors4/#subject): `!IfStatement > [name="foo"]`
* class of AST node: `:statement`, `:expression`, `:declaration`, `:function`, or `:pattern`

[![Build Status](https://travis-ci.org/estools/esquery.png?branch=master)](https://travis-ci.org/estools/esquery)
¬/license.txtÅÐCopyright (c) 2013, Joel Feenstra
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the ESQuery nor the names of its contributors may
      be used to endorse or promote products derived from this software without
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOEL FEENSTRA BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
´/dist/esquery.min.jsÅˆÜ!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).esquery=t()}(this,(function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var r=[],n=!0,o=!1,a=void 0;try{for(var i,s=e[Symbol.iterator]();!(n=(i=s.next()).done)&&(r.push(i.value),!t||r.length!==t);n=!0);}catch(e){o=!0,a=e}finally{try{n||null==s.return||s.return()}finally{if(o)throw a}}return r}(e,t)||n(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function r(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||n(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(e,t){if(e){if("string"==typeof e)return o(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?o(e,t):void 0}}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function a(e,t){var r;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=n(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var o=0,a=function(){};return{s:a,n:function(){return o>=e.length?{done:!0}:{done:!1,value:e[o++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,s=!0,l=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return s=e.done,e},e:function(e){l=!0,i=e},f:function(){try{s||null==r.return||r.return()}finally{if(l)throw i}}}}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function i(e,t){return e(t={exports:{}},t.exports),t.exports}var s=i((function(e,t){!function e(t){var r,n,o,a,i,s;function l(e){var t,r,n={};for(t in e)e.hasOwnProperty(t)&&(r=e[t],n[t]="object"==typeof r&&null!==r?l(r):r);return n}function u(e,t){this.parent=e,this.key=t}function c(e,t,r,n){this.node=e,this.path=t,this.wrap=r,this.ref=n}function f(){}function p(e){return null!=e&&("object"==typeof e&&"string"==typeof e.type)}function h(e,t){return(e===r.ObjectExpression||e===r.ObjectPattern)&&"properties"===t}function y(e,t){for(var r=e.length-1;r>=0;--r)if(e[r].node===t)return!0;return!1}function d(e,t){return(new f).traverse(e,t)}function m(e,t){var r;return r=function(e,t){var r,n,o,a;for(n=e.length,o=0;n;)t(e[a=o+(r=n>>>1)])?n=r:(o=a+1,n-=r+1);return o}(t,(function(t){return t.range[0]>e.range[0]})),e.extendedRange=[e.range[0],e.range[1]],r!==t.length&&(e.extendedRange[1]=t[r].range[0]),(r-=1)>=0&&(e.extendedRange[0]=t[r].range[1]),e}return r={AssignmentExpression:"AssignmentExpression",AssignmentPattern:"AssignmentPattern",ArrayExpression:"ArrayExpression",ArrayPattern:"ArrayPattern",ArrowFunctionExpression:"ArrowFunctionExpression",AwaitExpression:"AwaitExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ChainExpression:"ChainExpression",ClassBody:"ClassBody",ClassDeclaration:"ClassDeclaration",ClassExpression:"ClassExpression",ComprehensionBlock:"ComprehensionBlock",ComprehensionExpression:"ComprehensionExpression",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DebuggerStatement:"DebuggerStatement",DirectiveStatement:"DirectiveStatement",DoWhileStatement:"DoWhileStatement",EmptyStatement:"EmptyStatement",ExportAllDeclaration:"ExportAllDeclaration",ExportDefaultDeclaration:"ExportDefaultDeclaration",ExportNamedDeclaration:"ExportNamedDeclaration",ExportSpecifier:"ExportSpecifier",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForInStatement:"ForInStatement",ForOfStatement:"ForOfStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",GeneratorExpression:"GeneratorExpression",Identifier:"Identifier",IfStatement:"IfStatement",ImportExpression:"ImportExpression",ImportDeclaration:"ImportDeclaration",ImportDefaultSpecifier:"ImportDefaultSpecifier",ImportNamespaceSpecifier:"ImportNamespaceSpecifier",ImportSpecifier:"ImportSpecifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",MetaProperty:"MetaProperty",MethodDefinition:"MethodDefinition",ModuleSpecifier:"ModuleSpecifier",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",ObjectPattern:"ObjectPattern",Program:"Program",Property:"Property",RestElement:"RestElement",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SpreadElement:"SpreadElement",Super:"Super",SwitchStatement:"SwitchStatement",SwitchCase:"SwitchCase",TaggedTemplateExpression:"TaggedTemplateExpression",TemplateElement:"TemplateElement",TemplateLiteral:"TemplateLiteral",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement",YieldExpression:"YieldExpression"},o={AssignmentExpression:["left","right"],AssignmentPattern:["left","right"],ArrayExpression:["elements"],ArrayPattern:["elements"],ArrowFunctionExpression:["params","body"],AwaitExpression:["argument"],BlockStatement:["body"],BinaryExpression:["left","right"],BreakStatement:["label"],CallExpression:["callee","arguments"],CatchClause:["param","body"],ChainExpression:["expression"],ClassBody:["body"],ClassDeclaration:["id","superClass","body"],ClassExpression:["id","superClass","body"],ComprehensionBlock:["left","right"],ComprehensionExpression:["blocks","filter","body"],ConditionalExpression:["test","consequent","alternate"],ContinueStatement:["label"],DebuggerStatement:[],DirectiveStatement:[],DoWhileStatement:["body","test"],EmptyStatement:[],ExportAllDeclaration:["source"],ExportDefaultDeclaration:["declaration"],ExportNamedDeclaration:["declaration","specifiers","source"],ExportSpecifier:["exported","local"],ExpressionStatement:["expression"],ForStatement:["init","test","update","body"],ForInStatement:["left","right","body"],ForOfStatement:["left","right","body"],FunctionDeclaration:["id","params","body"],FunctionExpression:["id","params","body"],GeneratorExpression:["blocks","filter","body"],Identifier:[],IfStatement:["test","consequent","alternate"],ImportExpression:["source"],ImportDeclaration:["specifiers","source"],ImportDefaultSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportSpecifier:["imported","local"],Literal:[],LabeledStatement:["label","body"],LogicalExpression:["left","right"],MemberExpression:["object","property"],MetaProperty:["meta","property"],MethodDefinition:["key","value"],ModuleSpecifier:[],NewExpression:["callee","arguments"],ObjectExpression:["properties"],ObjectPattern:["properties"],Program:["body"],Property:["key","value"],RestElement:["argument"],ReturnStatement:["argument"],SequenceExpression:["expressions"],SpreadElement:["argument"],Super:[],SwitchStatement:["discriminant","cases"],SwitchCase:["test","consequent"],TaggedTemplateExpression:["tag","quasi"],TemplateElement:[],TemplateLiteral:["quasis","expressions"],ThisExpression:[],ThrowStatement:["argument"],TryStatement:["block","handler","finalizer"],UnaryExpression:["argument"],UpdateExpression:["argument"],VariableDeclaration:["declarations"],VariableDeclarator:["id","init"],WhileStatement:["test","body"],WithStatement:["object","body"],YieldExpression:["argument"]},n={Break:a={},Skip:i={},Remove:s={}},u.prototype.replace=function(e){this.parent[this.key]=e},u.prototype.remove=function(){return Array.isArray(this.parent)?(this.parent.splice(this.key,1),!0):(this.replace(null),!1)},f.prototype.path=function(){var e,t,r,n,o;function a(e,t){if(Array.isArray(t))for(r=0,n=t.length;r<n;++r)e.push(t[r]);else e.push(t)}if(!this.__current.path)return null;for(o=[],e=2,t=this.__leavelist.length;e<t;++e)a(o,this.__leavelist[e].path);return a(o,this.__current.path),o},f.prototype.type=function(){return this.current().type||this.__current.wrap},f.prototype.parents=function(){var e,t,r;for(r=[],e=1,t=this.__leavelist.length;e<t;++e)r.push(this.__leavelist[e].node);return r},f.prototype.current=function(){return this.__current.node},f.prototype.__execute=function(e,t){var r,n;return n=void 0,r=this.__current,this.__current=t,this.__state=null,e&&(n=e.call(this,t.node,this.__leavelist[this.__leavelist.length-1].node)),this.__current=r,n},f.prototype.notify=function(e){this.__state=e},f.prototype.skip=function(){this.notify(i)},f.prototype.break=function(){this.notify(a)},f.prototype.remove=function(){this.notify(s)},f.prototype.__initialize=function(e,t){this.visitor=t,this.root=e,this.__worklist=[],this.__leavelist=[],this.__current=null,this.__state=null,this.__fallback=null,"iteration"===t.fallback?this.__fallback=Object.keys:"function"==typeof t.fallback&&(this.__fallback=t.fallback),this.__keys=o,t.keys&&(this.__keys=Object.assign(Object.create(this.__keys),t.keys))},f.prototype.traverse=function(e,t){var r,n,o,s,l,u,f,d,m,x,v,g;for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,r.push(new c(e,null,null,null)),n.push(new c(null,null,null,null));r.length;)if((o=r.pop())!==g){if(o.node){if(u=this.__execute(t.enter,o),this.__state===a||u===a)return;if(r.push(g),n.push(o),this.__state===i||u===i)continue;if(l=(s=o.node).type||o.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error("Unknown node type "+l+".");x=this.__fallback(s)}for(d=x.length;(d-=1)>=0;)if(v=s[f=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]&&!y(n,v[m])){if(h(l,x[d]))o=new c(v[m],[f,m],"Property",null);else{if(!p(v[m]))continue;o=new c(v[m],[f,m],null,null)}r.push(o)}}else if(p(v)){if(y(n,v))continue;r.push(new c(v,f,null,null))}}}else if(o=n.pop(),u=this.__execute(t.leave,o),this.__state===a||u===a)return},f.prototype.replace=function(e,t){var r,n,o,l,f,y,d,m,x,v,g,b,A;function E(e){var t,n,o,a;if(e.ref.remove())for(n=e.ref.key,a=e.ref.parent,t=r.length;t--;)if((o=r[t]).ref&&o.ref.parent===a){if(o.ref.key<n)break;--o.ref.key}}for(this.__initialize(e,t),g={},r=this.__worklist,n=this.__leavelist,y=new c(e,null,null,new u(b={root:e},"root")),r.push(y),n.push(y);r.length;)if((y=r.pop())!==g){if(void 0!==(f=this.__execute(t.enter,y))&&f!==a&&f!==i&&f!==s&&(y.ref.replace(f),y.node=f),this.__state!==s&&f!==s||(E(y),y.node=null),this.__state===a||f===a)return b.root;if((o=y.node)&&(r.push(g),n.push(y),this.__state!==i&&f!==i)){if(l=o.type||y.wrap,!(x=this.__keys[l])){if(!this.__fallback)throw new Error("Unknown node type "+l+".");x=this.__fallback(o)}for(d=x.length;(d-=1)>=0;)if(v=o[A=x[d]])if(Array.isArray(v)){for(m=v.length;(m-=1)>=0;)if(v[m]){if(h(l,x[d]))y=new c(v[m],[A,m],"Property",new u(v,m));else{if(!p(v[m]))continue;y=new c(v[m],[A,m],null,new u(v,m))}r.push(y)}}else p(v)&&r.push(new c(v,A,null,new u(o,A)))}}else if(y=n.pop(),void 0!==(f=this.__execute(t.leave,y))&&f!==a&&f!==i&&f!==s&&y.ref.replace(f),this.__state!==s&&f!==s||E(y),this.__state===a||f===a)return b.root;return b.root},t.Syntax=r,t.traverse=d,t.replace=function(e,t){return(new f).replace(e,t)},t.attachComments=function(e,t,r){var o,a,i,s,u=[];if(!e.range)throw new Error("attachComments needs range information");if(!r.length){if(t.length){for(i=0,a=t.length;i<a;i+=1)(o=l(t[i])).extendedRange=[0,e.range[0]],u.push(o);e.leadingComments=u}return e}for(i=0,a=t.length;i<a;i+=1)u.push(m(l(t[i]),r));return s=0,d(e,{enter:function(e){for(var t;s<u.length&&!((t=u[s]).extendedRange[1]>e.range[0]);)t.extendedRange[1]===e.range[0]?(e.leadingComments||(e.leadingComments=[]),e.leadingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),s=0,d(e,{leave:function(e){for(var t;s<u.length&&(t=u[s],!(e.range[1]<t.extendedRange[0]));)e.range[1]===t.extendedRange[0]?(e.trailingComments||(e.trailingComments=[]),e.trailingComments.push(t),u.splice(s,1)):s+=1;return s===u.length?n.Break:u[s].extendedRange[0]>e.range[1]?n.Skip:void 0}}),e},t.VisitorKeys=o,t.VisitorOption=n,t.Controller=f,t.cloneEnvironment=function(){return e({})},t}(t)})),l=i((function(e){e.exports&&(e.exports=function(){function e(t,r,n,o){this.message=t,this.expected=r,this.found=n,this.location=o,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,e)}return function(e,t){function r(){this.constructor=e}r.prototype=t.prototype,e.prototype=new r}(e,Error),e.buildMessage=function(e,t){var r={literal:function(e){return'"'+o(e.text)+'"'},class:function(e){var t,r="";for(t=0;t<e.parts.length;t++)r+=e.parts[t]instanceof Array?a(e.parts[t][0])+"-"+a(e.parts[t][1]):a(e.parts[t]);return"["+(e.inverted?"^":"")+r+"]"},any:function(e){return"any character"},end:function(e){return"end of input"},other:function(e){return e.description}};function n(e){return e.charCodeAt(0).toString(16).toUpperCase()}function o(e){return e.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(e){return"\\x0"+n(e)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(e){return"\\x"+n(e)}))}function a(e){return e.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(e){return"\\x0"+n(e)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(e){return"\\x"+n(e)}))}return"Expected "+function(e){var t,n,o,a=new Array(e.length);for(t=0;t<e.length;t++)a[t]=(o=e[t],r[o.type](o));if(a.sort(),a.length>0){for(t=1,n=1;t<a.length;t++)a[t-1]!==a[t]&&(a[n]=a[t],n++);a.length=n}switch(a.length){case 1:return a[0];case 2:return a[0]+" or "+a[1];default:return a.slice(0,-1).join(", ")+", or "+a[a.length-1]}}(e)+" but "+function(e){return e?'"'+o(e)+'"':"end of input"}(t)+" found."},{SyntaxError:e,parse:function(t,r){r=void 0!==r?r:{};var n,o,a,i,s={},l={start:be},u=be,c=de(" ",!1),f=/^[^ [\],():#!=><~+.]/,p=me([" ","[","]",",","(",")",":","#","!","=",">","<","~","+","."],!0,!1),h=de(">",!1),y=de("~",!1),d=de("+",!1),m=de(",",!1),x=de("!",!1),v=de("*",!1),g=de("#",!1),b=de("[",!1),A=de("]",!1),E=/^[><!]/,S=me([">","<","!"],!1,!1),_=de("=",!1),w=function(e){return(e||"")+"="},C=/^[><]/,P=me([">","<"],!1,!1),k=de(".",!1),D=function(e,t,r){return{type:"attribute",name:e,operator:t,value:r}},j=de('"',!1),I=/^[^\\"]/,T=me(["\\",'"'],!0,!1),F=de("\\",!1),L={type:"any"},O=function(e,t){return e+t},R=function(e){return{type:"literal",value:(t=e.join(""),t.replace(/\\(.)/g,(function(e,t){switch(t){case"b":return"\b";case"f":return"\f";case"n":return"\n";case"r":return"\r";case"t":return"\t";case"v":return"\v";default:return t}})))};var t},B=de("'",!1),M=/^[^\\']/,U=me(["\\","'"],!0,!1),q=/^[0-9]/,V=me([["0","9"]],!1,!1),N=de("type(",!1),W=/^[^ )]/,K=me([" ",")"],!0,!1),G=de(")",!1),z=/^[imsu]/,H=me(["i","m","s","u"],!1,!1),Y=de("/",!1),$=/^[^\/]/,J=me(["/"],!0,!1),Q=de(":not(",!1),X=de(":matches(",!1),Z=de(":has(",!1),ee=de(":first-child",!1),te=de(":last-child",!1),re=de(":nth-child(",!1),ne=de(":nth-last-child(",!1),oe=de(":",!1),ae=de("statement",!0),ie=de("expression",!0),se=de("declaration",!0),le=de("function",!0),ue=de("pattern",!0),ce=0,fe=[{line:1,column:1}],pe=0,he=[],ye={};if("startRule"in r){if(!(r.startRule in l))throw new Error("Can't start parsing from rule \""+r.startRule+'".');u=l[r.startRule]}function de(e,t){return{type:"literal",text:e,ignoreCase:t}}function me(e,t,r){return{type:"class",parts:e,inverted:t,ignoreCase:r}}function xe(e){var r,n=fe[e];if(n)return n;for(r=e-1;!fe[r];)r--;for(n={line:(n=fe[r]).line,column:n.column};r<e;)10===t.charCodeAt(r)?(n.line++,n.column=1):n.column++,r++;return fe[e]=n,n}function ve(e,t){var r=xe(e),n=xe(t);return{start:{offset:e,line:r.line,column:r.column},end:{offset:t,line:n.line,column:n.column}}}function ge(e){ce<pe||(ce>pe&&(pe=ce,he=[]),he.push(e))}function be(){var e,t,r,n,o=30*ce+0,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,(t=Ae())!==s&&(r=_e())!==s&&Ae()!==s?e=t=1===(n=r).length?n[0]:{type:"matches",selectors:n}:(ce=e,e=s),e===s&&(e=ce,(t=Ae())!==s&&(t=void 0),e=t),ye[o]={nextPos:ce,result:e},e)}function Ae(){var e,r,n=30*ce+1,o=ye[n];if(o)return ce=o.nextPos,o.result;for(e=[],32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c));r!==s;)e.push(r),32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c));return ye[n]={nextPos:ce,result:e},e}function Ee(){var e,r,n,o=30*ce+2,a=ye[o];if(a)return ce=a.nextPos,a.result;if(r=[],f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p)),n!==s)for(;n!==s;)r.push(n),f.test(t.charAt(ce))?(n=t.charAt(ce),ce++):(n=s,ge(p));else r=s;return r!==s&&(r=r.join("")),e=r,ye[o]={nextPos:ce,result:e},e}function Se(){var e,r,n,o=30*ce+3,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,(r=Ae())!==s?(62===t.charCodeAt(ce)?(n=">",ce++):(n=s,ge(h)),n!==s&&Ae()!==s?e=r="child":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(126===t.charCodeAt(ce)?(n="~",ce++):(n=s,ge(y)),n!==s&&Ae()!==s?e=r="sibling":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=Ae())!==s?(43===t.charCodeAt(ce)?(n="+",ce++):(n=s,ge(d)),n!==s&&Ae()!==s?e=r="adjacent":(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,32===t.charCodeAt(ce)?(r=" ",ce++):(r=s,ge(c)),r!==s&&(n=Ae())!==s?e=r="descendant":(ce=e,e=s)))),ye[o]={nextPos:ce,result:e},e)}function _e(){var e,r,n,o,a,i,l,u,c=30*ce+4,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=we())!==s){for(n=[],o=ce,(a=Ae())!==s?(44===t.charCodeAt(ce)?(i=",",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?o=a=[a,i,l,u]:(ce=o,o=s)):(ce=o,o=s);o!==s;)n.push(o),o=ce,(a=Ae())!==s?(44===t.charCodeAt(ce)?(i=",",ce++):(i=s,ge(m)),i!==s&&(l=Ae())!==s&&(u=we())!==s?o=a=[a,i,l,u]:(ce=o,o=s)):(ce=o,o=s);n!==s?e=r=[r].concat(n.map((function(e){return e[3]}))):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function we(){var e,t,r,n,o,a,i,l=30*ce+5,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,(t=Ce())!==s){for(r=[],n=ce,(o=Se())!==s&&(a=Ce())!==s?n=o=[o,a]:(ce=n,n=s);n!==s;)r.push(n),n=ce,(o=Se())!==s&&(a=Ce())!==s?n=o=[o,a]:(ce=n,n=s);r!==s?(i=t,e=t=r.reduce((function(e,t){return{type:t[0],left:e,right:t[1]}}),i)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}function Ce(){var e,r,n,o,a,i,l,u=30*ce+6,c=ye[u];if(c)return ce=c.nextPos,c.result;if(e=ce,33===t.charCodeAt(ce)?(r="!",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s){if(n=[],(o=Pe())!==s)for(;o!==s;)n.push(o),o=Pe();else n=s;n!==s?(a=r,l=1===(i=n).length?i[0]:{type:"compound",selectors:i},a&&(l.subject=!0),e=r=l):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}function Pe(){var e,r=30*ce+7,n=ye[r];return n?(ce=n.nextPos,n.result):((e=function(){var e,r,n=30*ce+8,o=ye[n];return o?(ce=o.nextPos,o.result):(42===t.charCodeAt(ce)?(r="*",ce++):(r=s,ge(v)),r!==s&&(r={type:"wildcard",value:r}),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o=30*ce+9,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,35===t.charCodeAt(ce)?(r="#",ce++):(r=s,ge(g)),r===s&&(r=null),r!==s&&(n=Ee())!==s?e=r={type:"identifier",value:n}:(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o,a=30*ce+10,i=ye[a];return i?(ce=i.nextPos,i.result):(e=ce,91===t.charCodeAt(ce)?(r="[",ce++):(r=s,ge(b)),r!==s&&Ae()!==s&&(n=function(){var e,r,n,o,a=30*ce+14,i=ye[a];return i?(ce=i.nextPos,i.result):(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,o=30*ce+12,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,33===t.charCodeAt(ce)?(r="!",ce++):(r=s,ge(x)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n="=",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((o=function(){var e,r,n,o,a,i=30*ce+18,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,"type("===t.substr(ce,5)?(r="type(",ce+=5):(r=s,ge(N)),r!==s)if(Ae()!==s){if(n=[],W.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(K)),o!==s)for(;o!==s;)n.push(o),W.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(K));else n=s;n!==s&&(o=Ae())!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?(r={type:"type",value:n.join("")},e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(o=function(){var e,r,n,o,a,i,l=30*ce+20,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,47===t.charCodeAt(ce)?(r="/",ce++):(r=s,ge(Y)),r!==s){if(n=[],$.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(J)),o!==s)for(;o!==s;)n.push(o),$.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(J));else n=s;n!==s?(47===t.charCodeAt(ce)?(o="/",ce++):(o=s,ge(Y)),o!==s?((a=function(){var e,r,n=30*ce+19,o=ye[n];if(o)return ce=o.nextPos,o.result;if(e=[],z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H)),r!==s)for(;r!==s;)e.push(r),z.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(H));else e=s;return ye[n]={nextPos:ce,result:e},e}())===s&&(a=null),a!==s?(i=a,r={type:"regexp",value:new RegExp(n.join(""),i?i.join(""):"")},e=r):(ce=e,e=s)):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}()),o!==s?(r=D(r,n,o),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&Ae()!==s&&(n=function(){var e,r,n,o=30*ce+11,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,E.test(t.charAt(ce))?(r=t.charAt(ce),ce++):(r=s,ge(S)),r===s&&(r=null),r!==s?(61===t.charCodeAt(ce)?(n="=",ce++):(n=s,ge(_)),n!==s?(r=w(r),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(C.test(t.charAt(ce))?(e=t.charAt(ce),ce++):(e=s,ge(P))),ye[o]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?((o=function(){var e,r,n,o,a,i,l=30*ce+15,u=ye[l];if(u)return ce=u.nextPos,u.result;if(e=ce,34===t.charCodeAt(ce)?(r='"',ce++):(r=s,ge(j)),r!==s){for(n=[],I.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(T)),o===s&&(o=ce,92===t.charCodeAt(ce)?(a="\\",ce++):(a=s,ge(F)),a!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(a=O(a,i),o=a):(ce=o,o=s)):(ce=o,o=s));o!==s;)n.push(o),I.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(T)),o===s&&(o=ce,92===t.charCodeAt(ce)?(a="\\",ce++):(a=s,ge(F)),a!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(a=O(a,i),o=a):(ce=o,o=s)):(ce=o,o=s));n!==s?(34===t.charCodeAt(ce)?(o='"',ce++):(o=s,ge(j)),o!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;if(e===s)if(e=ce,39===t.charCodeAt(ce)?(r="'",ce++):(r=s,ge(B)),r!==s){for(n=[],M.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(U)),o===s&&(o=ce,92===t.charCodeAt(ce)?(a="\\",ce++):(a=s,ge(F)),a!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(a=O(a,i),o=a):(ce=o,o=s)):(ce=o,o=s));o!==s;)n.push(o),M.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(U)),o===s&&(o=ce,92===t.charCodeAt(ce)?(a="\\",ce++):(a=s,ge(F)),a!==s?(t.length>ce?(i=t.charAt(ce),ce++):(i=s,ge(L)),i!==s?(a=O(a,i),o=a):(ce=o,o=s)):(ce=o,o=s));n!==s?(39===t.charCodeAt(ce)?(o="'",ce++):(o=s,ge(B)),o!==s?(r=R(n),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;return ye[l]={nextPos:ce,result:e},e}())===s&&(o=function(){var e,r,n,o,a,i,l,u=30*ce+16,c=ye[u];if(c)return ce=c.nextPos,c.result;for(e=ce,r=ce,n=[],q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V));o!==s;)n.push(o),q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V));if(n!==s?(46===t.charCodeAt(ce)?(o=".",ce++):(o=s,ge(k)),o!==s?r=n=[n,o]:(ce=r,r=s)):(ce=r,r=s),r===s&&(r=null),r!==s){if(n=[],q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V)),o!==s)for(;o!==s;)n.push(o),q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V));else n=s;n!==s?(i=n,l=(a=r)?[].concat.apply([],a).join(""):"",r={type:"literal",value:parseFloat(l+i.join(""))},e=r):(ce=e,e=s)}else ce=e,e=s;return ye[u]={nextPos:ce,result:e},e}())===s&&(o=function(){var e,t,r=30*ce+17,n=ye[r];return n?(ce=n.nextPos,n.result):((t=Ee())!==s&&(t={type:"literal",value:t}),e=t,ye[r]={nextPos:ce,result:e},e)}()),o!==s?(r=D(r,n,o),e=r):(ce=e,e=s)):(ce=e,e=s),e===s&&(e=ce,(r=ke())!==s&&(r={type:"attribute",name:r}),e=r)),ye[a]={nextPos:ce,result:e},e)}())!==s&&Ae()!==s?(93===t.charCodeAt(ce)?(o="]",ce++):(o=s,ge(A)),o!==s?e=r=n:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o,a,i,l,u,c=30*ce+21,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,46===t.charCodeAt(ce)?(r=".",ce++):(r=s,ge(k)),r!==s)if((n=Ee())!==s){for(o=[],a=ce,46===t.charCodeAt(ce)?(i=".",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?a=i=[i,l]:(ce=a,a=s);a!==s;)o.push(a),a=ce,46===t.charCodeAt(ce)?(i=".",ce++):(i=s,ge(k)),i!==s&&(l=Ee())!==s?a=i=[i,l]:(ce=a,a=s);o!==s?(u=n,r={type:"field",name:o.reduce((function(e,t){return e+t[0]+t[1]}),u)},e=r):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,o,a=30*ce+22,i=ye[a];return i?(ce=i.nextPos,i.result):(e=ce,":not("===t.substr(ce,5)?(r=":not(",ce+=5):(r=s,ge(Q)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?e=r={type:"not",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o,a=30*ce+23,i=ye[a];return i?(ce=i.nextPos,i.result):(e=ce,":matches("===t.substr(ce,9)?(r=":matches(",ce+=9):(r=s,ge(X)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?e=r={type:"matches",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o,a=30*ce+24,i=ye[a];return i?(ce=i.nextPos,i.result):(e=ce,":has("===t.substr(ce,5)?(r=":has(",ce+=5):(r=s,ge(Z)),r!==s&&Ae()!==s&&(n=_e())!==s&&Ae()!==s?(41===t.charCodeAt(ce)?(o=")",ce++):(o=s,ge(G)),o!==s?e=r={type:"has",selectors:n}:(ce=e,e=s)):(ce=e,e=s),ye[a]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+25,o=ye[n];return o?(ce=o.nextPos,o.result):(":first-child"===t.substr(ce,12)?(r=":first-child",ce+=12):(r=s,ge(ee)),r!==s&&(r=De(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n=30*ce+26,o=ye[n];return o?(ce=o.nextPos,o.result):(":last-child"===t.substr(ce,11)?(r=":last-child",ce+=11):(r=s,ge(te)),r!==s&&(r=je(1)),e=r,ye[n]={nextPos:ce,result:e},e)}())===s&&(e=function(){var e,r,n,o,a,i=30*ce+27,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,":nth-child("===t.substr(ce,11)?(r=":nth-child(",ce+=11):(r=s,ge(re)),r!==s)if(Ae()!==s){if(n=[],q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V)),o!==s)for(;o!==s;)n.push(o),q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V));else n=s;n!==s&&(o=Ae())!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?(r=De(parseInt(n.join(""),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,o,a,i=30*ce+28,l=ye[i];if(l)return ce=l.nextPos,l.result;if(e=ce,":nth-last-child("===t.substr(ce,16)?(r=":nth-last-child(",ce+=16):(r=s,ge(ne)),r!==s)if(Ae()!==s){if(n=[],q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V)),o!==s)for(;o!==s;)n.push(o),q.test(t.charAt(ce))?(o=t.charAt(ce),ce++):(o=s,ge(V));else n=s;n!==s&&(o=Ae())!==s?(41===t.charCodeAt(ce)?(a=")",ce++):(a=s,ge(G)),a!==s?(r=je(parseInt(n.join(""),10)),e=r):(ce=e,e=s)):(ce=e,e=s)}else ce=e,e=s;else ce=e,e=s;return ye[i]={nextPos:ce,result:e},e}())===s&&(e=function(){var e,r,n,o=30*ce+29,a=ye[o];return a?(ce=a.nextPos,a.result):(e=ce,58===t.charCodeAt(ce)?(r=":",ce++):(r=s,ge(oe)),r!==s?("statement"===t.substr(ce,9).toLowerCase()?(n=t.substr(ce,9),ce+=9):(n=s,ge(ae)),n===s&&("expression"===t.substr(ce,10).toLowerCase()?(n=t.substr(ce,10),ce+=10):(n=s,ge(ie)),n===s&&("declaration"===t.substr(ce,11).toLowerCase()?(n=t.substr(ce,11),ce+=11):(n=s,ge(se)),n===s&&("function"===t.substr(ce,8).toLowerCase()?(n=t.substr(ce,8),ce+=8):(n=s,ge(le)),n===s&&("pattern"===t.substr(ce,7).toLowerCase()?(n=t.substr(ce,7),ce+=7):(n=s,ge(ue)))))),n!==s?e=r={type:"class",name:n}:(ce=e,e=s)):(ce=e,e=s),ye[o]={nextPos:ce,result:e},e)}()),ye[r]={nextPos:ce,result:e},e)}function ke(){var e,r,n,o,a,i,l,u,c=30*ce+13,f=ye[c];if(f)return ce=f.nextPos,f.result;if(e=ce,(r=Ee())!==s){for(n=[],o=ce,46===t.charCodeAt(ce)?(a=".",ce++):(a=s,ge(k)),a!==s&&(i=Ee())!==s?o=a=[a,i]:(ce=o,o=s);o!==s;)n.push(o),o=ce,46===t.charCodeAt(ce)?(a=".",ce++):(a=s,ge(k)),a!==s&&(i=Ee())!==s?o=a=[a,i]:(ce=o,o=s);n!==s?(l=r,u=n,e=r=[].concat.apply([l],u).join("")):(ce=e,e=s)}else ce=e,e=s;return ye[c]={nextPos:ce,result:e},e}function De(e){return{type:"nth-child",index:{type:"literal",value:e}}}function je(e){return{type:"nth-last-child",index:{type:"literal",value:e}}}if((n=u())!==s&&ce===t.length)return n;throw n!==s&&ce<t.length&&ge({type:"end"}),o=he,a=pe<t.length?t.charAt(pe):null,i=pe<t.length?ve(pe,pe+1):ve(pe,pe),new e(e.buildMessage(o,a),o,a,i)}}}())}));function u(t,r,n,o){if(!r)return!0;if(!t)return!1;switch(n||(n=[]),r.type){case"wildcard":return!0;case"identifier":return r.value.toLowerCase()===t.type.toLowerCase();case"field":var i=r.name.split("."),l=n[i.length-1];return function e(t,r,n){if(0===n.length)return t===r;if(null==r)return!1;var o=r[n[0]],i=n.slice(1);if(Array.isArray(o)){var s,l=a(o);try{for(l.s();!(s=l.n()).done;){if(e(t,s.value,i))return!0}}catch(e){l.e(e)}finally{l.f()}return!1}return e(t,o,i)}(t,l,i);case"matches":var c,f=a(r.selectors);try{for(f.s();!(c=f.n()).done;){var d=c.value;if(u(t,d,n,o))return!0}}catch(e){f.e(e)}finally{f.f()}return!1;case"compound":var m,x=a(r.selectors);try{for(x.s();!(m=x.n()).done;){var v=m.value;if(!u(t,v,n,o))return!1}}catch(e){x.e(e)}finally{x.f()}return!0;case"not":var g,b=a(r.selectors);try{for(b.s();!(g=b.n()).done;){var A=g.value;if(u(t,A,n,o))return!1}}catch(e){b.e(e)}finally{b.f()}return!0;case"has":var E=function(){var e,n=[],i=a(r.selectors);try{var l=function(){var r=e.value,a=[];s.traverse(t,{enter:function(e,t){null!=t&&a.unshift(t),u(e,r,a,o)&&n.push(e)},leave:function(){a.shift()},keys:o&&o.visitorKeys,fallback:o&&o.fallback||"iteration"})};for(i.s();!(e=i.n()).done;)l()}catch(e){i.e(e)}finally{i.f()}return{v:0!==n.length}}();if("object"===e(E))return E.v;case"child":return!!u(t,r.right,n,o)&&u(n[0],r.left,n.slice(1),o);case"descendant":if(u(t,r.right,n,o))for(var S=0,_=n.length;S<_;++S)if(u(n[S],r.left,n.slice(S+1),o))return!0;return!1;case"attribute":var w=function(e,t){var r,n=a(t.split("."));try{for(n.s();!(r=n.n()).done;){var o=r.value;if(null==e)return e;e=e[o]}}catch(e){n.e(e)}finally{n.f()}return e}(t,r.name);switch(r.operator){case void 0:return null!=w;case"=":switch(r.value.type){case"regexp":return"string"==typeof w&&r.value.value.test(w);case"literal":return"".concat(r.value.value)==="".concat(w);case"type":return r.value.value===e(w)}throw new Error("Unknown selector value type: ".concat(r.value.type));case"!=":switch(r.value.type){case"regexp":return!r.value.value.test(w);case"literal":return"".concat(r.value.value)!=="".concat(w);case"type":return r.value.value!==e(w)}throw new Error("Unknown selector value type: ".concat(r.value.type));case"<=":return w<=r.value.value;case"<":return w<r.value.value;case">":return w>r.value.value;case">=":return w>=r.value.value}throw new Error("Unknown operator: ".concat(r.operator));case"sibling":return u(t,r.right,n,o)&&p(t,r.left,n,"LEFT_SIDE",o)||r.left.subject&&u(t,r.left,n,o)&&p(t,r.right,n,"RIGHT_SIDE",o);case"adjacent":return u(t,r.right,n,o)&&h(t,r.left,n,"LEFT_SIDE",o)||r.right.subject&&u(t,r.left,n,o)&&h(t,r.right,n,"RIGHT_SIDE",o);case"nth-child":return u(t,r.right,n,o)&&y(t,n,(function(){return r.index.value-1}),o);case"nth-last-child":return u(t,r.right,n,o)&&y(t,n,(function(e){return e-r.index.value}),o);case"class":switch(r.name.toLowerCase()){case"statement":if("Statement"===t.type.slice(-9))return!0;case"declaration":return"Declaration"===t.type.slice(-11);case"pattern":if("Pattern"===t.type.slice(-7))return!0;case"expression":return"Expression"===t.type.slice(-10)||"Literal"===t.type.slice(-7)||"Identifier"===t.type&&(0===n.length||"MetaProperty"!==n[0].type)||"MetaProperty"===t.type;case"function":return"FunctionDeclaration"===t.type||"FunctionExpression"===t.type||"ArrowFunctionExpression"===t.type}throw new Error("Unknown class name: ".concat(r.name))}throw new Error("Unknown selector type: ".concat(r.type))}function c(e,t){var r=e.type;return t&&t.visitorKeys&&t.visitorKeys[r]?t.visitorKeys[r]:s.VisitorKeys[r]?s.VisitorKeys[r]:t&&"function"==typeof t.fallback?t.fallback(e):Object.keys(e).filter((function(e){return"type"!==e}))}function f(t){return null!==t&&"object"===e(t)&&"string"==typeof t.type}function p(e,r,n,o,i){var s=t(n,1)[0];if(!s)return!1;var l,p=a(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;var d=void 0,m=void 0;"LEFT_SIDE"===o?(d=0,m=y):(d=y+1,m=h.length);for(var x=d;x<m;++x)if(f(h[x])&&u(h[x],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function h(e,r,n,o,i){var s=t(n,1)[0];if(!s)return!1;var l,p=a(c(s,i));try{for(p.s();!(l=p.n()).done;){var h=s[l.value];if(Array.isArray(h)){var y=h.indexOf(e);if(y<0)continue;if("LEFT_SIDE"===o&&y>0&&f(h[y-1])&&u(h[y-1],r,n,i))return!0;if("RIGHT_SIDE"===o&&y<h.length-1&&f(h[y+1])&&u(h[y+1],r,n,i))return!0}}}catch(e){p.e(e)}finally{p.f()}return!1}function y(e,r,n,o){var i=t(r,1)[0];if(!i)return!1;var s,l=a(c(i,o));try{for(l.s();!(s=l.n()).done;){var u=i[s.value];if(Array.isArray(u)){var f=u.indexOf(e);if(f>=0&&f===n(u.length))return!0}}}catch(e){l.e(e)}finally{l.f()}return!1}function d(n,o){if(null==n||"object"!=e(n))return[];null==o&&(o=n);for(var a=n.subject?[o]:[],i=0,s=function(e){for(var t=[],r=Object.keys(e),n=0;n<r.length;n++)t.push([r[n],e[r[n]]]);return t}(n);i<s.length;i++){var l=t(s[i],2),u=l[0],c=l[1];a.push.apply(a,r(d(c,"left"===u?c:o)))}return a}function m(e,t,r,n){if(t){var o=[],a=d(t);s.traverse(e,{enter:function(e,i){if(null!=i&&o.unshift(i),u(e,t,o,n))if(a.length)for(var s=0,l=a.length;s<l;++s){u(e,a[s],o,n)&&r(e,i,o);for(var c=0,f=o.length;c<f;++c){var p=o.slice(c+1);u(o[c],a[s],p,n)&&r(o[c],i,p)}}else r(e,i,o)},leave:function(){o.shift()},keys:n&&n.visitorKeys,fallback:n&&n.fallback||"iteration"})}}function x(e,t,r){var n=[];return m(e,t,(function(e){n.push(e)}),r),n}function v(e){return l.parse(e)}function g(e,t,r){return x(e,v(t),r)}return g.parse=v,g.match=x,g.traverse=m,g.matches=u,g.query=g,g}));
//# sourceMappingURL=esquery.min.js.map
´/dist/esquery.esm.jsÆ ÝGfunction _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var estraverse = createCommonjsModule(function (module, exports) {
  /*
    Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
    Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
  
      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  /*jslint vars:false, bitwise:true*/

  /*jshint indent:4*/

  /*global exports:true*/
  (function clone(exports) {

    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;

    function deepCopy(obj) {
      var ret = {},
          key,
          val;

      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];

          if (typeof val === 'object' && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }

      return ret;
    } // based on LLVM libc++ upper_bound / lower_bound
    // MIT License


    function upperBound(array, func) {
      var diff, len, i, current;
      len = array.length;
      i = 0;

      while (len) {
        diff = len >>> 1;
        current = i + diff;

        if (func(array[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }

      return i;
    }

    Syntax = {
      AssignmentExpression: 'AssignmentExpression',
      AssignmentPattern: 'AssignmentPattern',
      ArrayExpression: 'ArrayExpression',
      ArrayPattern: 'ArrayPattern',
      ArrowFunctionExpression: 'ArrowFunctionExpression',
      AwaitExpression: 'AwaitExpression',
      // CAUTION: It's deferred to ES7.
      BlockStatement: 'BlockStatement',
      BinaryExpression: 'BinaryExpression',
      BreakStatement: 'BreakStatement',
      CallExpression: 'CallExpression',
      CatchClause: 'CatchClause',
      ChainExpression: 'ChainExpression',
      ClassBody: 'ClassBody',
      ClassDeclaration: 'ClassDeclaration',
      ClassExpression: 'ClassExpression',
      ComprehensionBlock: 'ComprehensionBlock',
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: 'ComprehensionExpression',
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: 'ConditionalExpression',
      ContinueStatement: 'ContinueStatement',
      DebuggerStatement: 'DebuggerStatement',
      DirectiveStatement: 'DirectiveStatement',
      DoWhileStatement: 'DoWhileStatement',
      EmptyStatement: 'EmptyStatement',
      ExportAllDeclaration: 'ExportAllDeclaration',
      ExportDefaultDeclaration: 'ExportDefaultDeclaration',
      ExportNamedDeclaration: 'ExportNamedDeclaration',
      ExportSpecifier: 'ExportSpecifier',
      ExpressionStatement: 'ExpressionStatement',
      ForStatement: 'ForStatement',
      ForInStatement: 'ForInStatement',
      ForOfStatement: 'ForOfStatement',
      FunctionDeclaration: 'FunctionDeclaration',
      FunctionExpression: 'FunctionExpression',
      GeneratorExpression: 'GeneratorExpression',
      // CAUTION: It's deferred to ES7.
      Identifier: 'Identifier',
      IfStatement: 'IfStatement',
      ImportExpression: 'ImportExpression',
      ImportDeclaration: 'ImportDeclaration',
      ImportDefaultSpecifier: 'ImportDefaultSpecifier',
      ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
      ImportSpecifier: 'ImportSpecifier',
      Literal: 'Literal',
      LabeledStatement: 'LabeledStatement',
      LogicalExpression: 'LogicalExpression',
      MemberExpression: 'MemberExpression',
      MetaProperty: 'MetaProperty',
      MethodDefinition: 'MethodDefinition',
      ModuleSpecifier: 'ModuleSpecifier',
      NewExpression: 'NewExpression',
      ObjectExpression: 'ObjectExpression',
      ObjectPattern: 'ObjectPattern',
      Program: 'Program',
      Property: 'Property',
      RestElement: 'RestElement',
      ReturnStatement: 'ReturnStatement',
      SequenceExpression: 'SequenceExpression',
      SpreadElement: 'SpreadElement',
      Super: 'Super',
      SwitchStatement: 'SwitchStatement',
      SwitchCase: 'SwitchCase',
      TaggedTemplateExpression: 'TaggedTemplateExpression',
      TemplateElement: 'TemplateElement',
      TemplateLiteral: 'TemplateLiteral',
      ThisExpression: 'ThisExpression',
      ThrowStatement: 'ThrowStatement',
      TryStatement: 'TryStatement',
      UnaryExpression: 'UnaryExpression',
      UpdateExpression: 'UpdateExpression',
      VariableDeclaration: 'VariableDeclaration',
      VariableDeclarator: 'VariableDeclarator',
      WhileStatement: 'WhileStatement',
      WithStatement: 'WithStatement',
      YieldExpression: 'YieldExpression'
    };
    VisitorKeys = {
      AssignmentExpression: ['left', 'right'],
      AssignmentPattern: ['left', 'right'],
      ArrayExpression: ['elements'],
      ArrayPattern: ['elements'],
      ArrowFunctionExpression: ['params', 'body'],
      AwaitExpression: ['argument'],
      // CAUTION: It's deferred to ES7.
      BlockStatement: ['body'],
      BinaryExpression: ['left', 'right'],
      BreakStatement: ['label'],
      CallExpression: ['callee', 'arguments'],
      CatchClause: ['param', 'body'],
      ChainExpression: ['expression'],
      ClassBody: ['body'],
      ClassDeclaration: ['id', 'superClass', 'body'],
      ClassExpression: ['id', 'superClass', 'body'],
      ComprehensionBlock: ['left', 'right'],
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: ['blocks', 'filter', 'body'],
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: ['test', 'consequent', 'alternate'],
      ContinueStatement: ['label'],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ['body', 'test'],
      EmptyStatement: [],
      ExportAllDeclaration: ['source'],
      ExportDefaultDeclaration: ['declaration'],
      ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
      ExportSpecifier: ['exported', 'local'],
      ExpressionStatement: ['expression'],
      ForStatement: ['init', 'test', 'update', 'body'],
      ForInStatement: ['left', 'right', 'body'],
      ForOfStatement: ['left', 'right', 'body'],
      FunctionDeclaration: ['id', 'params', 'body'],
      FunctionExpression: ['id', 'params', 'body'],
      GeneratorExpression: ['blocks', 'filter', 'body'],
      // CAUTION: It's deferred to ES7.
      Identifier: [],
      IfStatement: ['test', 'consequent', 'alternate'],
      ImportExpression: ['source'],
      ImportDeclaration: ['specifiers', 'source'],
      ImportDefaultSpecifier: ['local'],
      ImportNamespaceSpecifier: ['local'],
      ImportSpecifier: ['imported', 'local'],
      Literal: [],
      LabeledStatement: ['label', 'body'],
      LogicalExpression: ['left', 'right'],
      MemberExpression: ['object', 'property'],
      MetaProperty: ['meta', 'property'],
      MethodDefinition: ['key', 'value'],
      ModuleSpecifier: [],
      NewExpression: ['callee', 'arguments'],
      ObjectExpression: ['properties'],
      ObjectPattern: ['properties'],
      Program: ['body'],
      Property: ['key', 'value'],
      RestElement: ['argument'],
      ReturnStatement: ['argument'],
      SequenceExpression: ['expressions'],
      SpreadElement: ['argument'],
      Super: [],
      SwitchStatement: ['discriminant', 'cases'],
      SwitchCase: ['test', 'consequent'],
      TaggedTemplateExpression: ['tag', 'quasi'],
      TemplateElement: [],
      TemplateLiteral: ['quasis', 'expressions'],
      ThisExpression: [],
      ThrowStatement: ['argument'],
      TryStatement: ['block', 'handler', 'finalizer'],
      UnaryExpression: ['argument'],
      UpdateExpression: ['argument'],
      VariableDeclaration: ['declarations'],
      VariableDeclarator: ['id', 'init'],
      WhileStatement: ['test', 'body'],
      WithStatement: ['object', 'body'],
      YieldExpression: ['argument']
    }; // unique id

    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };

    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
      this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };

    function Element(node, path, wrap, ref) {
      this.node = node;
      this.path = path;
      this.wrap = wrap;
      this.ref = ref;
    }

    function Controller() {} // API:
    // return property path array from root to current node


    Controller.prototype.path = function path() {
      var i, iz, j, jz, result, element;

      function addToPath(result, path) {
        if (Array.isArray(path)) {
          for (j = 0, jz = path.length; j < jz; ++j) {
            result.push(path[j]);
          }
        } else {
          result.push(path);
        }
      } // root node


      if (!this.__current.path) {
        return null;
      } // first node is sentinel, second node is root element


      result = [];

      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }

      addToPath(result, this.__current.path);
      return result;
    }; // API:
    // return type of current node


    Controller.prototype.type = function () {
      var node = this.current();
      return node.type || this.__current.wrap;
    }; // API:
    // return array of parent elements


    Controller.prototype.parents = function parents() {
      var i, iz, result; // first node is sentinel

      result = [];

      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }

      return result;
    }; // API:
    // return current node


    Controller.prototype.current = function current() {
      return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = undefined;
      previous = this.__current;
      this.__current = element;
      this.__state = null;

      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }

      this.__current = previous;
      return result;
    }; // API:
    // notify control skip / break


    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    }; // API:
    // skip child nodes of current node


    Controller.prototype.skip = function () {
      this.notify(SKIP);
    }; // API:
    // break traversals


    Controller.prototype['break'] = function () {
      this.notify(BREAK);
    }; // API:
    // remove node


    Controller.prototype.remove = function () {
      this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function (root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;

      if (visitor.fallback === 'iteration') {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === 'function') {
        this.__fallback = visitor.fallback;
      }

      this.__keys = VisitorKeys;

      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };

    function isNode(node) {
      if (node == null) {
        return false;
      }

      return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i = leavelist.length - 1; i >= 0; --i) {
        if (leavelist[i].node === candidate) {
          return true;
        }
      }

      return false;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

      this.__initialize(root, visitor);

      sentinel = {}; // reference

      worklist = this.__worklist;
      leavelist = this.__leavelist; // initialize

      worklist.push(new Element(root, null, null, null));
      leavelist.push(new Element(null, null, null, null));

      while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);

          if (this.__state === BREAK || ret === BREAK) {
            return;
          }

          continue;
        }

        if (element.node) {
          ret = this.__execute(visitor.enter, element);

          if (this.__state === BREAK || ret === BREAK) {
            return;
          }

          worklist.push(sentinel);
          leavelist.push(element);

          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }

          node = element.node;
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];

          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error('Unknown node type ' + nodeType + '.');
            }
          }

          current = candidates.length;

          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];

            if (!candidate) {
              continue;
            }

            if (Array.isArray(candidate)) {
              current2 = candidate.length;

              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }

                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                  continue;
                }

                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], 'Property', null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }

                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }

              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };

    Controller.prototype.replace = function replace(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

      function removeElem(element) {
        var i, key, nextElem, parent;

        if (element.ref.remove()) {
          // When the reference is an element of an array.
          key = element.ref.key;
          parent = element.ref.parent; // If removed from array, then decrease following items' keys.

          i = worklist.length;

          while (i--) {
            nextElem = worklist[i];

            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key) {
                break;
              }

              --nextElem.ref.key;
            }
          }
        }
      }

      this.__initialize(root, visitor);

      sentinel = {}; // reference

      worklist = this.__worklist;
      leavelist = this.__leavelist; // initialize

      outer = {
        root: root
      };
      element = new Element(root, null, null, new Reference(outer, 'root'));
      worklist.push(element);
      leavelist.push(element);

      while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element); // node may be replaced with null,
          // so distinguish between undefined and null in this place

          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            // replace
            element.ref.replace(target);
          }

          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }

          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }

          continue;
        }

        target = this.__execute(visitor.enter, element); // node may be replaced with null,
        // so distinguish between undefined and null in this place

        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
          element.node = target;
        }

        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }

        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        } // node may be null


        node = element.node;

        if (!node) {
          continue;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || target === SKIP) {
          continue;
        }

        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];

        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }

        current = candidates.length;

        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];

          if (!candidate) {
            continue;
          }

          if (Array.isArray(candidate)) {
            current2 = candidate.length;

            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }

              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }

              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
          }
        }
      }

      return outer.root;
    };

    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];

      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }

      target -= 1;

      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }

      return comment;
    }

    function attachComments(tree, providedComments, tokens) {
      // At first, we should calculate extended comment ranges.
      var comments = [],
          comment,
          len,
          i,
          cursor;

      if (!tree.range) {
        throw new Error('attachComments needs range information');
      } // tokens array is empty, we attach comments to tree as 'leadingComments'


      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }

          tree.leadingComments = comments;
        }

        return tree;
      }

      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      } // This is based on John Freeman's implementation.


      cursor = 0;
      traverse(tree, {
        enter: function (node) {
          var comment;

          while (cursor < comments.length) {
            comment = comments[cursor];

            if (comment.extendedRange[1] > node.range[0]) {
              break;
            }

            if (comment.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }

              node.leadingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          } // already out of owned node


          if (cursor === comments.length) {
            return VisitorOption.Break;
          }

          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function (node) {
          var comment;

          while (cursor < comments.length) {
            comment = comments[cursor];

            if (node.range[1] < comment.extendedRange[0]) {
              break;
            }

            if (node.range[1] === comment.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }

              node.trailingComments.push(comment);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          } // already out of owned node


          if (cursor === comments.length) {
            return VisitorOption.Break;
          }

          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }

    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;

    exports.cloneEnvironment = function () {
      return clone({});
    };

    return exports;
  })(exports);
  /* vim: set sw=4 ts=4 et tw=80 : */

});

var parser = createCommonjsModule(function (module) {
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */
  (function (root, factory) {
    if ( module.exports) {
      module.exports = factory();
    }
  })(commonjsGlobal, function () {

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child;
      }

      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location;
      this.name = "SyntaxError";

      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }

    peg$subclass(peg$SyntaxError, Error);

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function literal(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },
        "class": function _class(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function any(expectation) {
          return "any character";
        },
        end: function end(expectation) {
          return "end of input";
        },
        other: function other(expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function classEscape(s) {
        return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
          return '\\x0' + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
          return '\\x' + hex(ch);
        });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
            i,
            j;

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i]);
        }

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }

          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};

      var peg$FAILED = {},
          peg$startRuleFunctions = {
        start: peg$parsestart
      },
          peg$startRuleFunction = peg$parsestart,
          peg$c0 = function peg$c0(ss) {
        return ss.length === 1 ? ss[0] : {
          type: 'matches',
          selectors: ss
        };
      },
          peg$c1 = function peg$c1() {
        return void 0;
      },
          peg$c2 = " ",
          peg$c3 = peg$literalExpectation(" ", false),
          peg$c4 = /^[^ [\],():#!=><~+.]/,
          peg$c5 = peg$classExpectation([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false),
          peg$c6 = function peg$c6(i) {
        return i.join('');
      },
          peg$c7 = ">",
          peg$c8 = peg$literalExpectation(">", false),
          peg$c9 = function peg$c9() {
        return 'child';
      },
          peg$c10 = "~",
          peg$c11 = peg$literalExpectation("~", false),
          peg$c12 = function peg$c12() {
        return 'sibling';
      },
          peg$c13 = "+",
          peg$c14 = peg$literalExpectation("+", false),
          peg$c15 = function peg$c15() {
        return 'adjacent';
      },
          peg$c16 = function peg$c16() {
        return 'descendant';
      },
          peg$c17 = ",",
          peg$c18 = peg$literalExpectation(",", false),
          peg$c19 = function peg$c19(s, ss) {
        return [s].concat(ss.map(function (s) {
          return s[3];
        }));
      },
          peg$c20 = function peg$c20(a, ops) {
        return ops.reduce(function (memo, rhs) {
          return {
            type: rhs[0],
            left: memo,
            right: rhs[1]
          };
        }, a);
      },
          peg$c21 = "!",
          peg$c22 = peg$literalExpectation("!", false),
          peg$c23 = function peg$c23(subject, as) {
        var b = as.length === 1 ? as[0] : {
          type: 'compound',
          selectors: as
        };
        if (subject) b.subject = true;
        return b;
      },
          peg$c24 = "*",
          peg$c25 = peg$literalExpectation("*", false),
          peg$c26 = function peg$c26(a) {
        return {
          type: 'wildcard',
          value: a
        };
      },
          peg$c27 = "#",
          peg$c28 = peg$literalExpectation("#", false),
          peg$c29 = function peg$c29(i) {
        return {
          type: 'identifier',
          value: i
        };
      },
          peg$c30 = "[",
          peg$c31 = peg$literalExpectation("[", false),
          peg$c32 = "]",
          peg$c33 = peg$literalExpectation("]", false),
          peg$c34 = function peg$c34(v) {
        return v;
      },
          peg$c35 = /^[><!]/,
          peg$c36 = peg$classExpectation([">", "<", "!"], false, false),
          peg$c37 = "=",
          peg$c38 = peg$literalExpectation("=", false),
          peg$c39 = function peg$c39(a) {
        return (a || '') + '=';
      },
          peg$c40 = /^[><]/,
          peg$c41 = peg$classExpectation([">", "<"], false, false),
          peg$c42 = ".",
          peg$c43 = peg$literalExpectation(".", false),
          peg$c44 = function peg$c44(a, as) {
        return [].concat.apply([a], as).join('');
      },
          peg$c45 = function peg$c45(name, op, value) {
        return {
          type: 'attribute',
          name: name,
          operator: op,
          value: value
        };
      },
          peg$c46 = function peg$c46(name) {
        return {
          type: 'attribute',
          name: name
        };
      },
          peg$c47 = "\"",
          peg$c48 = peg$literalExpectation("\"", false),
          peg$c49 = /^[^\\"]/,
          peg$c50 = peg$classExpectation(["\\", "\""], true, false),
          peg$c51 = "\\",
          peg$c52 = peg$literalExpectation("\\", false),
          peg$c53 = peg$anyExpectation(),
          peg$c54 = function peg$c54(a, b) {
        return a + b;
      },
          peg$c55 = function peg$c55(d) {
        return {
          type: 'literal',
          value: strUnescape(d.join(''))
        };
      },
          peg$c56 = "'",
          peg$c57 = peg$literalExpectation("'", false),
          peg$c58 = /^[^\\']/,
          peg$c59 = peg$classExpectation(["\\", "'"], true, false),
          peg$c60 = /^[0-9]/,
          peg$c61 = peg$classExpectation([["0", "9"]], false, false),
          peg$c62 = function peg$c62(a, b) {
        // Can use `a.flat().join('')` once supported
        var leadingDecimals = a ? [].concat.apply([], a).join('') : '';
        return {
          type: 'literal',
          value: parseFloat(leadingDecimals + b.join(''))
        };
      },
          peg$c63 = function peg$c63(i) {
        return {
          type: 'literal',
          value: i
        };
      },
          peg$c64 = "type(",
          peg$c65 = peg$literalExpectation("type(", false),
          peg$c66 = /^[^ )]/,
          peg$c67 = peg$classExpectation([" ", ")"], true, false),
          peg$c68 = ")",
          peg$c69 = peg$literalExpectation(")", false),
          peg$c70 = function peg$c70(t) {
        return {
          type: 'type',
          value: t.join('')
        };
      },
          peg$c71 = /^[imsu]/,
          peg$c72 = peg$classExpectation(["i", "m", "s", "u"], false, false),
          peg$c73 = "/",
          peg$c74 = peg$literalExpectation("/", false),
          peg$c75 = /^[^\/]/,
          peg$c76 = peg$classExpectation(["/"], true, false),
          peg$c77 = function peg$c77(d, flgs) {
        return {
          type: 'regexp',
          value: new RegExp(d.join(''), flgs ? flgs.join('') : '')
        };
      },
          peg$c78 = function peg$c78(i, is) {
        return {
          type: 'field',
          name: is.reduce(function (memo, p) {
            return memo + p[0] + p[1];
          }, i)
        };
      },
          peg$c79 = ":not(",
          peg$c80 = peg$literalExpectation(":not(", false),
          peg$c81 = function peg$c81(ss) {
        return {
          type: 'not',
          selectors: ss
        };
      },
          peg$c82 = ":matches(",
          peg$c83 = peg$literalExpectation(":matches(", false),
          peg$c84 = function peg$c84(ss) {
        return {
          type: 'matches',
          selectors: ss
        };
      },
          peg$c85 = ":has(",
          peg$c86 = peg$literalExpectation(":has(", false),
          peg$c87 = function peg$c87(ss) {
        return {
          type: 'has',
          selectors: ss
        };
      },
          peg$c88 = ":first-child",
          peg$c89 = peg$literalExpectation(":first-child", false),
          peg$c90 = function peg$c90() {
        return nth(1);
      },
          peg$c91 = ":last-child",
          peg$c92 = peg$literalExpectation(":last-child", false),
          peg$c93 = function peg$c93() {
        return nthLast(1);
      },
          peg$c94 = ":nth-child(",
          peg$c95 = peg$literalExpectation(":nth-child(", false),
          peg$c96 = function peg$c96(n) {
        return nth(parseInt(n.join(''), 10));
      },
          peg$c97 = ":nth-last-child(",
          peg$c98 = peg$literalExpectation(":nth-last-child(", false),
          peg$c99 = function peg$c99(n) {
        return nthLast(parseInt(n.join(''), 10));
      },
          peg$c100 = ":",
          peg$c101 = peg$literalExpectation(":", false),
          peg$c102 = "statement",
          peg$c103 = peg$literalExpectation("statement", true),
          peg$c104 = "expression",
          peg$c105 = peg$literalExpectation("expression", true),
          peg$c106 = "declaration",
          peg$c107 = peg$literalExpectation("declaration", true),
          peg$c108 = "function",
          peg$c109 = peg$literalExpectation("function", true),
          peg$c110 = "pattern",
          peg$c111 = peg$literalExpectation("pattern", true),
          peg$c112 = function peg$c112(c) {
        return {
          type: 'class',
          name: c
        };
      },
          peg$currPos = 0,
          peg$posDetailsCache = [{
        line: 1,
        column: 1
      }],
          peg$maxFailPos = 0,
          peg$maxFailExpected = [],
          peg$resultsCache = {},
          peg$result;

      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function peg$literalExpectation(text, ignoreCase) {
        return {
          type: "literal",
          text: text,
          ignoreCase: ignoreCase
        };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase
        };
      }

      function peg$anyExpectation() {
        return {
          type: "any"
        };
      }

      function peg$endExpectation() {
        return {
          type: "end"
        };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
            p;

        if (details) {
          return details;
        } else {
          p = pos - 1;

          while (!peg$posDetailsCache[p]) {
            p--;
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;
          return details;
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
            endPosDetails = peg$computePosDetails(endPos);
        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
      }

      function peg$parsestart() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 30 + 0,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parse_();

        if (s1 !== peg$FAILED) {
          s2 = peg$parseselectors();

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();

            if (s3 !== peg$FAILED) {
              s1 = peg$c0(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            s1 = peg$c1();
          }

          s0 = s1;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parse_() {
        var s0, s1;
        var key = peg$currPos * 30 + 1,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = [];

        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c3);
          }
        }

        while (s1 !== peg$FAILED) {
          s0.push(s1);

          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c2;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c3);
            }
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseidentifierName() {
        var s0, s1, s2;
        var key = peg$currPos * 30 + 2,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = [];

        if (peg$c4.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;

          {
            peg$fail(peg$c5);
          }
        }

        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);

            if (peg$c4.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c5);
              }
            }
          }
        } else {
          s1 = peg$FAILED;
        }

        if (s1 !== peg$FAILED) {
          s1 = peg$c6(s1);
        }

        s0 = s1;
        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsebinaryOp() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 30 + 3,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parse_();

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 62) {
            s2 = peg$c7;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c8);
            }
          }

          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();

            if (s3 !== peg$FAILED) {
              s1 = peg$c9();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 126) {
              s2 = peg$c10;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c11);
              }
            }

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();

              if (s3 !== peg$FAILED) {
                s1 = peg$c12();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();

            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 43) {
                s2 = peg$c13;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c14);
                }
              }

              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();

                if (s3 !== peg$FAILED) {
                  s1 = peg$c15();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 32) {
                s1 = peg$c2;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                {
                  peg$fail(peg$c3);
                }
              }

              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();

                if (s2 !== peg$FAILED) {
                  s1 = peg$c16();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseselectors() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 30 + 4,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parseselector();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_();

          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c17;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;

              {
                peg$fail(peg$c18);
              }
            }

            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();

              if (s6 !== peg$FAILED) {
                s7 = peg$parseselector();

                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();

            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c18);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();

                if (s6 !== peg$FAILED) {
                  s7 = peg$parseselector();

                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c19(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseselector() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 5,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parsesequence();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parsebinaryOp();

          if (s4 !== peg$FAILED) {
            s5 = peg$parsesequence();

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parsebinaryOp();

            if (s4 !== peg$FAILED) {
              s5 = peg$parsesequence();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c20(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsesequence() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 30 + 6,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c21;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c22);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseatom();

          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseatom();
            }
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c23(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseatom() {
        var s0;
        var key = peg$currPos * 30 + 7,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$parsewildcard();

        if (s0 === peg$FAILED) {
          s0 = peg$parseidentifier();

          if (s0 === peg$FAILED) {
            s0 = peg$parseattr();

            if (s0 === peg$FAILED) {
              s0 = peg$parsefield();

              if (s0 === peg$FAILED) {
                s0 = peg$parsenegation();

                if (s0 === peg$FAILED) {
                  s0 = peg$parsematches();

                  if (s0 === peg$FAILED) {
                    s0 = peg$parsehas();

                    if (s0 === peg$FAILED) {
                      s0 = peg$parsefirstChild();

                      if (s0 === peg$FAILED) {
                        s0 = peg$parselastChild();

                        if (s0 === peg$FAILED) {
                          s0 = peg$parsenthChild();

                          if (s0 === peg$FAILED) {
                            s0 = peg$parsenthLastChild();

                            if (s0 === peg$FAILED) {
                              s0 = peg$parseclass();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsewildcard() {
        var s0, s1;
        var key = peg$currPos * 30 + 8,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 42) {
          s1 = peg$c24;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c25);
          }
        }

        if (s1 !== peg$FAILED) {
          s1 = peg$c26(s1);
        }

        s0 = s1;
        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseidentifier() {
        var s0, s1, s2;
        var key = peg$currPos * 30 + 9,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c28);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifierName();

          if (s2 !== peg$FAILED) {
            s1 = peg$c29(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseattr() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 10,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c30;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c31);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseattrValue();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s5 = peg$c32;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c33);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c34(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseattrOps() {
        var s0, s1, s2;
        var key = peg$currPos * 30 + 11,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (peg$c35.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c36);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c37;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c38);
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c39(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          if (peg$c40.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;

            {
              peg$fail(peg$c41);
            }
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseattrEqOps() {
        var s0, s1, s2;
        var key = peg$currPos * 30 + 12,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c21;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c22);
          }
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c37;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c38);
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c39(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseattrName() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 13,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parseidentifierName();

        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c42;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;

            {
              peg$fail(peg$c43);
            }
          }

          if (s4 !== peg$FAILED) {
            s5 = peg$parseidentifierName();

            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c42;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseidentifierName();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c44(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseattrValue() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 14,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parseattrName();

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseattrEqOps();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                s5 = peg$parsetype();

                if (s5 === peg$FAILED) {
                  s5 = peg$parseregex();
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c45(s1, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseattrName();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrOps();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parsestring();

                  if (s5 === peg$FAILED) {
                    s5 = peg$parsenumber();

                    if (s5 === peg$FAILED) {
                      s5 = peg$parsepath();
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c45(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseattrName();

            if (s1 !== peg$FAILED) {
              s1 = peg$c46(s1);
            }

            s0 = s1;
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsestring() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 15,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c47;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c48);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];

          if (peg$c49.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c50);
            }
          }

          if (s3 === peg$FAILED) {
            s3 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 92) {
              s4 = peg$c51;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c52);
              }
            }

            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c53);
                }
              }

              if (s5 !== peg$FAILED) {
                s4 = peg$c54(s4, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);

            if (peg$c49.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c50);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c52);
                }
              }

              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c53);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s4 = peg$c54(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c47;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c48);
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = peg$c55(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        if (s0 === peg$FAILED) {
          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c56;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c57);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c58.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c59);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c52);
                }
              }

              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c53);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s4 = peg$c54(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);

              if (peg$c58.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c59);
                }
              }

              if (s3 === peg$FAILED) {
                s3 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c51;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c52);
                  }
                }

                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c53);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s4 = peg$c54(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c56;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c57);
                }
              }

              if (s3 !== peg$FAILED) {
                s1 = peg$c55(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsenumber() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 30 + 16,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];

        if (peg$c60.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;

          {
            peg$fail(peg$c61);
          }
        }

        while (s3 !== peg$FAILED) {
          s2.push(s3);

          if (peg$c60.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c61);
            }
          }
        }

        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c42;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c43);
            }
          }

          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }

        if (s1 === peg$FAILED) {
          s1 = null;
        }

        if (s1 !== peg$FAILED) {
          s2 = [];

          if (peg$c60.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c61);
            }
          }

          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);

              if (peg$c60.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c61);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c62(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsepath() {
        var s0, s1;
        var key = peg$currPos * 30 + 17,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;
        s1 = peg$parseidentifierName();

        if (s1 !== peg$FAILED) {
          s1 = peg$c63(s1);
        }

        s0 = s1;
        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsetype() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 18,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 5) === peg$c64) {
          s1 = peg$c64;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c65);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = [];

            if (peg$c66.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c67);
              }
            }

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);

                if (peg$c66.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c67);
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c70(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseflags() {
        var s0, s1;
        var key = peg$currPos * 30 + 19,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = [];

        if (peg$c71.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c72);
          }
        }

        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (peg$c71.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              {
                peg$fail(peg$c72);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseregex() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 30 + 20,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c74);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = [];

          if (peg$c75.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c76);
            }
          }

          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);

              if (peg$c75.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c76);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c73;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c74);
              }
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parseflags();

              if (s4 === peg$FAILED) {
                s4 = null;
              }

              if (s4 !== peg$FAILED) {
                s1 = peg$c77(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsefield() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 30 + 21,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c42;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c43);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifierName();

          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 46) {
              s5 = peg$c42;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s5 !== peg$FAILED) {
              s6 = peg$parseidentifierName();

              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }

            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c42;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c43);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifierName();

                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }

            if (s3 !== peg$FAILED) {
              s1 = peg$c78(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsenegation() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 22,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 5) === peg$c79) {
          s1 = peg$c79;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c80);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseselectors();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c81(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsematches() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 23,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 9) === peg$c82) {
          s1 = peg$c82;
          peg$currPos += 9;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c83);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseselectors();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c84(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsehas() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 24,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 5) === peg$c85) {
          s1 = peg$c85;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c86);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = peg$parseselectors();

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c87(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsefirstChild() {
        var s0, s1;
        var key = peg$currPos * 30 + 25,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 12) === peg$c88) {
          s1 = peg$c88;
          peg$currPos += 12;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c89);
          }
        }

        if (s1 !== peg$FAILED) {
          s1 = peg$c90();
        }

        s0 = s1;
        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parselastChild() {
        var s0, s1;
        var key = peg$currPos * 30 + 26,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 11) === peg$c91) {
          s1 = peg$c91;
          peg$currPos += 11;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c92);
          }
        }

        if (s1 !== peg$FAILED) {
          s1 = peg$c93();
        }

        s0 = s1;
        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsenthChild() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 27,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 11) === peg$c94) {
          s1 = peg$c94;
          peg$currPos += 11;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c95);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = [];

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);

                if (peg$c60.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c61);
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c96(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parsenthLastChild() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 30 + 28,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.substr(peg$currPos, 16) === peg$c97) {
          s1 = peg$c97;
          peg$currPos += 16;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c98);
          }
        }

        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();

          if (s2 !== peg$FAILED) {
            s3 = [];

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }

            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);

                if (peg$c60.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c61);
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }

            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c68;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c69);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s1 = peg$c99(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function peg$parseclass() {
        var s0, s1, s2;
        var key = peg$currPos * 30 + 29,
            cached = peg$resultsCache[key];

        if (cached) {
          peg$currPos = cached.nextPos;
          return cached.result;
        }

        s0 = peg$currPos;

        if (input.charCodeAt(peg$currPos) === 58) {
          s1 = peg$c100;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;

          {
            peg$fail(peg$c101);
          }
        }

        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {
            s2 = input.substr(peg$currPos, 9);
            peg$currPos += 9;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c103);
            }
          }

          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {
              s2 = input.substr(peg$currPos, 10);
              peg$currPos += 10;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c105);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {
                s2 = input.substr(peg$currPos, 11);
                peg$currPos += 11;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c107);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {
                  s2 = input.substr(peg$currPos, 8);
                  peg$currPos += 8;
                } else {
                  s2 = peg$FAILED;

                  {
                    peg$fail(peg$c109);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {
                    s2 = input.substr(peg$currPos, 7);
                    peg$currPos += 7;
                  } else {
                    s2 = peg$FAILED;

                    {
                      peg$fail(peg$c111);
                    }
                  }
                }
              }
            }
          }

          if (s2 !== peg$FAILED) {
            s1 = peg$c112(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        peg$resultsCache[key] = {
          nextPos: peg$currPos,
          result: s0
        };
        return s0;
      }

      function nth(n) {
        return {
          type: 'nth-child',
          index: {
            type: 'literal',
            value: n
          }
        };
      }

      function nthLast(n) {
        return {
          type: 'nth-last-child',
          index: {
            type: 'literal',
            value: n
          }
        };
      }

      function strUnescape(s) {
        return s.replace(/\\(.)/g, function (match, ch) {
          switch (ch) {
            case 'b':
              return '\b';

            case 'f':
              return '\f';

            case 'n':
              return '\n';

            case 'r':
              return '\r';

            case 't':
              return '\t';

            case 'v':
              return '\v';

            default:
              return ch;
          }
        });
      }

      peg$result = peg$startRuleFunction();

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  });
});

function _objectEntries(obj) {
  var entries = [];
  var keys = Object.keys(obj);

  for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);

  return entries;
}
/**
* @typedef {"LEFT_SIDE"|"RIGHT_SIDE"} Side
*/

var LEFT_SIDE = 'LEFT_SIDE';
var RIGHT_SIDE = 'RIGHT_SIDE';
/**
 * @external AST
 * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html
 */

/**
 * One of the rules of `grammar.pegjs`
 * @typedef {PlainObject} SelectorAST
 * @see grammar.pegjs
*/

/**
 * The `sequence` production of `grammar.pegjs`
 * @typedef {PlainObject} SelectorSequenceAST
*/

/**
 * Get the value of a property which may be multiple levels down
 * in the object.
 * @param {?PlainObject} obj
 * @param {string} key
 * @returns {undefined|boolean|string|number|external:AST}
 */

function getPath(obj, key) {
  var keys = key.split('.');

  var _iterator = _createForOfIteratorHelper(keys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _key = _step.value;

      if (obj == null) {
        return obj;
      }

      obj = obj[_key];
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return obj;
}
/**
 * Determine whether `node` can be reached by following `path`,
 * starting at `ancestor`.
 * @param {?external:AST} node
 * @param {?external:AST} ancestor
 * @param {string[]} path
 * @returns {boolean}
 */


function inPath(node, ancestor, path) {
  if (path.length === 0) {
    return node === ancestor;
  }

  if (ancestor == null) {
    return false;
  }

  var field = ancestor[path[0]];
  var remainingPath = path.slice(1);

  if (Array.isArray(field)) {
    var _iterator2 = _createForOfIteratorHelper(field),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var component = _step2.value;

        if (inPath(node, component, remainingPath)) {
          return true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return false;
  } else {
    return inPath(node, field, remainingPath);
  }
}
/**
 * @callback TraverseOptionFallback
 * @param {external:AST} node The given node.
 * @returns {string[]} An array of visitor keys for the given node.
 */

/**
 * @typedef {object} ESQueryOptions
 * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.
 * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.
 */

/**
 * Given a `node` and its ancestors, determine if `node` is matched
 * by `selector`.
 * @param {?external:AST} node
 * @param {?SelectorAST} selector
 * @param {external:AST[]} [ancestry=[]]
 * @param {ESQueryOptions} [options]
 * @throws {Error} Unknowns (operator, class name, selector type, or
 * selector value type)
 * @returns {boolean}
 */


function matches(node, selector, ancestry, options) {
  if (!selector) {
    return true;
  }

  if (!node) {
    return false;
  }

  if (!ancestry) {
    ancestry = [];
  }

  switch (selector.type) {
    case 'wildcard':
      return true;

    case 'identifier':
      return selector.value.toLowerCase() === node.type.toLowerCase();

    case 'field':
      {
        var path = selector.name.split('.');
        var ancestor = ancestry[path.length - 1];
        return inPath(node, ancestor, path);
      }

    case 'matches':
      var _iterator3 = _createForOfIteratorHelper(selector.selectors),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var sel = _step3.value;

          if (matches(node, sel, ancestry, options)) {
            return true;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return false;

    case 'compound':
      var _iterator4 = _createForOfIteratorHelper(selector.selectors),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _sel = _step4.value;

          if (!matches(node, _sel, ancestry, options)) {
            return false;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return true;

    case 'not':
      var _iterator5 = _createForOfIteratorHelper(selector.selectors),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _sel2 = _step5.value;

          if (matches(node, _sel2, ancestry, options)) {
            return false;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return true;

    case 'has':
      {
        var _ret = function () {
          var collector = [];

          var _iterator6 = _createForOfIteratorHelper(selector.selectors),
              _step6;

          try {
            var _loop = function _loop() {
              var sel = _step6.value;
              var a = [];
              estraverse.traverse(node, {
                enter: function enter(node, parent) {
                  if (parent != null) {
                    a.unshift(parent);
                  }

                  if (matches(node, sel, a, options)) {
                    collector.push(node);
                  }
                },
                leave: function leave() {
                  a.shift();
                },
                keys: options && options.visitorKeys,
                fallback: options && options.fallback || 'iteration'
              });
            };

            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return {
            v: collector.length !== 0
          };
        }();

        if (_typeof(_ret) === "object") return _ret.v;
      }

    case 'child':
      if (matches(node, selector.right, ancestry, options)) {
        return matches(ancestry[0], selector.left, ancestry.slice(1), options);
      }

      return false;

    case 'descendant':
      if (matches(node, selector.right, ancestry, options)) {
        for (var i = 0, l = ancestry.length; i < l; ++i) {
          if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {
            return true;
          }
        }
      }

      return false;

    case 'attribute':
      {
        var p = getPath(node, selector.name);

        switch (selector.operator) {
          case void 0:
            return p != null;

          case '=':
            switch (selector.value.type) {
              case 'regexp':
                return typeof p === 'string' && selector.value.value.test(p);

              case 'literal':
                return "".concat(selector.value.value) === "".concat(p);

              case 'type':
                return selector.value.value === _typeof(p);
            }

            throw new Error("Unknown selector value type: ".concat(selector.value.type));

          case '!=':
            switch (selector.value.type) {
              case 'regexp':
                return !selector.value.value.test(p);

              case 'literal':
                return "".concat(selector.value.value) !== "".concat(p);

              case 'type':
                return selector.value.value !== _typeof(p);
            }

            throw new Error("Unknown selector value type: ".concat(selector.value.type));

          case '<=':
            return p <= selector.value.value;

          case '<':
            return p < selector.value.value;

          case '>':
            return p > selector.value.value;

          case '>=':
            return p >= selector.value.value;
        }

        throw new Error("Unknown operator: ".concat(selector.operator));
      }

    case 'sibling':
      return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);

    case 'adjacent':
      return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);

    case 'nth-child':
      return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {
        return selector.index.value - 1;
      }, options);

    case 'nth-last-child':
      return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {
        return length - selector.index.value;
      }, options);

    case 'class':
      switch (selector.name.toLowerCase()) {
        case 'statement':
          if (node.type.slice(-9) === 'Statement') return true;
        // fallthrough: interface Declaration <: Statement { }

        case 'declaration':
          return node.type.slice(-11) === 'Declaration';

        case 'pattern':
          if (node.type.slice(-7) === 'Pattern') return true;
        // fallthrough: interface Expression <: Node, Pattern { }

        case 'expression':
          return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';

        case 'function':
          return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';
      }

      throw new Error("Unknown class name: ".concat(selector.name));
  }

  throw new Error("Unknown selector type: ".concat(selector.type));
}
/**
 * Get visitor keys of a given node.
 * @param {external:AST} node The AST node to get keys.
 * @param {ESQueryOptions|undefined} options
 * @returns {string[]} Visitor keys of the node.
 */


function getVisitorKeys(node, options) {
  var nodeType = node.type;

  if (options && options.visitorKeys && options.visitorKeys[nodeType]) {
    return options.visitorKeys[nodeType];
  }

  if (estraverse.VisitorKeys[nodeType]) {
    return estraverse.VisitorKeys[nodeType];
  }

  if (options && typeof options.fallback === 'function') {
    return options.fallback(node);
  } // 'iteration' fallback


  return Object.keys(node).filter(function (key) {
    return key !== 'type';
  });
}
/**
 * Check whether the given value is an ASTNode or not.
 * @param {any} node The value to check.
 * @returns {boolean} `true` if the value is an ASTNode.
 */


function isNode(node) {
  return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';
}
/**
 * Determines if the given node has a sibling that matches the
 * given selector.
 * @param {external:AST} node
 * @param {SelectorSequenceAST} selector
 * @param {external:AST[]} ancestry
 * @param {Side} side
 * @param {ESQueryOptions|undefined} options
 * @returns {boolean}
 */


function sibling(node, selector, ancestry, side, options) {
  var _ancestry = _slicedToArray(ancestry, 1),
      parent = _ancestry[0];

  if (!parent) {
    return false;
  }

  var keys = getVisitorKeys(parent, options);

  var _iterator7 = _createForOfIteratorHelper(keys),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var key = _step7.value;
      var listProp = parent[key];

      if (Array.isArray(listProp)) {
        var startIndex = listProp.indexOf(node);

        if (startIndex < 0) {
          continue;
        }

        var lowerBound = void 0,
            upperBound = void 0;

        if (side === LEFT_SIDE) {
          lowerBound = 0;
          upperBound = startIndex;
        } else {
          lowerBound = startIndex + 1;
          upperBound = listProp.length;
        }

        for (var k = lowerBound; k < upperBound; ++k) {
          if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {
            return true;
          }
        }
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return false;
}
/**
 * Determines if the given node has an adjacent sibling that matches
 * the given selector.
 * @param {external:AST} node
 * @param {SelectorSequenceAST} selector
 * @param {external:AST[]} ancestry
 * @param {Side} side
 * @param {ESQueryOptions|undefined} options
 * @returns {boolean}
 */


function adjacent(node, selector, ancestry, side, options) {
  var _ancestry2 = _slicedToArray(ancestry, 1),
      parent = _ancestry2[0];

  if (!parent) {
    return false;
  }

  var keys = getVisitorKeys(parent, options);

  var _iterator8 = _createForOfIteratorHelper(keys),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var key = _step8.value;
      var listProp = parent[key];

      if (Array.isArray(listProp)) {
        var idx = listProp.indexOf(node);

        if (idx < 0) {
          continue;
        }

        if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {
          return true;
        }

        if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  return false;
}
/**
* @callback IndexFunction
* @param {Integer} len Containing list's length
* @returns {Integer}
*/

/**
 * Determines if the given node is the nth child, determined by
 * `idxFn`, which is given the containing list's length.
 * @param {external:AST} node
 * @param {external:AST[]} ancestry
 * @param {IndexFunction} idxFn
 * @param {ESQueryOptions|undefined} options
 * @returns {boolean}
 */


function nthChild(node, ancestry, idxFn, options) {
  var _ancestry3 = _slicedToArray(ancestry, 1),
      parent = _ancestry3[0];

  if (!parent) {
    return false;
  }

  var keys = getVisitorKeys(parent, options);

  var _iterator9 = _createForOfIteratorHelper(keys),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var key = _step9.value;
      var listProp = parent[key];

      if (Array.isArray(listProp)) {
        var idx = listProp.indexOf(node);

        if (idx >= 0 && idx === idxFn(listProp.length)) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return false;
}
/**
 * For each selector node marked as a subject, find the portion of the
 * selector that the subject must match.
 * @param {SelectorAST} selector
 * @param {SelectorAST} [ancestor] Defaults to `selector`
 * @returns {SelectorAST[]}
 */


function subjects(selector, ancestor) {
  if (selector == null || _typeof(selector) != 'object') {
    return [];
  }

  if (ancestor == null) {
    ancestor = selector;
  }

  var results = selector.subject ? [ancestor] : [];

  for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        p = _Object$entries$_i[0],
        sel = _Object$entries$_i[1];

    results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));
  }

  return results;
}
/**
* @callback TraverseVisitor
* @param {?external:AST} node
* @param {?external:AST} parent
* @param {external:AST[]} ancestry
*/

/**
 * From a JS AST and a selector AST, collect all JS AST nodes that
 * match the selector.
 * @param {external:AST} ast
 * @param {?SelectorAST} selector
 * @param {TraverseVisitor} visitor
 * @param {ESQueryOptions} [options]
 * @returns {external:AST[]}
 */


function traverse(ast, selector, visitor, options) {
  if (!selector) {
    return;
  }

  var ancestry = [];
  var altSubjects = subjects(selector);
  estraverse.traverse(ast, {
    enter: function enter(node, parent) {
      if (parent != null) {
        ancestry.unshift(parent);
      }

      if (matches(node, selector, ancestry, options)) {
        if (altSubjects.length) {
          for (var i = 0, l = altSubjects.length; i < l; ++i) {
            if (matches(node, altSubjects[i], ancestry, options)) {
              visitor(node, parent, ancestry);
            }

            for (var k = 0, m = ancestry.length; k < m; ++k) {
              var succeedingAncestry = ancestry.slice(k + 1);

              if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {
                visitor(ancestry[k], parent, succeedingAncestry);
              }
            }
          }
        } else {
          visitor(node, parent, ancestry);
        }
      }
    },
    leave: function leave() {
      ancestry.shift();
    },
    keys: options && options.visitorKeys,
    fallback: options && options.fallback || 'iteration'
  });
}
/**
 * From a JS AST and a selector AST, collect all JS AST nodes that
 * match the selector.
 * @param {external:AST} ast
 * @param {?SelectorAST} selector
 * @param {ESQueryOptions} [options]
 * @returns {external:AST[]}
 */


function match(ast, selector, options) {
  var results = [];
  traverse(ast, selector, function (node) {
    results.push(node);
  }, options);
  return results;
}
/**
 * Parse a selector string and return its AST.
 * @param {string} selector
 * @returns {SelectorAST}
 */


function parse(selector) {
  return parser.parse(selector);
}
/**
 * Query the code AST using the selector string.
 * @param {external:AST} ast
 * @param {string} selector
 * @param {ESQueryOptions} [options]
 * @returns {external:AST[]}
 */


function query(ast, selector, options) {
  return match(ast, parse(selector), options);
}

query.parse = parse;
query.match = match;
query.traverse = traverse;
query.matches = matches;
query.query = query;

export default query;
°/dist/esquery.jsÆ ýˆ(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.esquery = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var estraverse = createCommonjsModule(function (module, exports) {
    /*
      Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */

    /*jslint vars:false, bitwise:true*/

    /*jshint indent:4*/

    /*global exports:true*/
    (function clone(exports) {

      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;

      function deepCopy(obj) {
        var ret = {},
            key,
            val;

        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];

            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }

        return ret;
      } // based on LLVM libc++ upper_bound / lower_bound
      // MIT License


      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;

        while (len) {
          diff = len >>> 1;
          current = i + diff;

          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }

        return i;
      }

      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression',
        // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ChainExpression: 'ChainExpression',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportExpression: 'ImportExpression',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ChainExpression: ['expression'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportExpression: ['source'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: ['argument'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
      }; // unique id

      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };

      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }

      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };

      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };

      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }

      function Controller() {} // API:
      // return property path array from root to current node


      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
          if (Array.isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        } // root node


        if (!this.__current.path) {
          return null;
        } // first node is sentinel, second node is root element


        result = [];

        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }

        addToPath(result, this.__current.path);
        return result;
      }; // API:
      // return type of current node


      Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
      }; // API:
      // return array of parent elements


      Controller.prototype.parents = function parents() {
        var i, iz, result; // first node is sentinel

        result = [];

        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }

        return result;
      }; // API:
      // return current node


      Controller.prototype.current = function current() {
        return this.__current.node;
      };

      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;

        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }

        this.__current = previous;
        return result;
      }; // API:
      // notify control skip / break


      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      }; // API:
      // skip child nodes of current node


      Controller.prototype.skip = function () {
        this.notify(SKIP);
      }; // API:
      // break traversals


      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      }; // API:
      // remove node


      Controller.prototype.remove = function () {
        this.notify(REMOVE);
      };

      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;

        if (visitor.fallback === 'iteration') {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === 'function') {
          this.__fallback = visitor.fallback;
        }

        this.__keys = VisitorKeys;

        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };

      function isNode(node) {
        if (node == null) {
          return false;
        }

        return typeof node === 'object' && typeof node.type === 'string';
      }

      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
      }

      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }

        return false;
      }

      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

        this.__initialize(root, visitor);

        sentinel = {}; // reference

        worklist = this.__worklist;
        leavelist = this.__leavelist; // initialize

        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
          element = worklist.pop();

          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);

            if (this.__state === BREAK || ret === BREAK) {
              return;
            }

            continue;
          }

          if (element.node) {
            ret = this.__execute(visitor.enter, element);

            if (this.__state === BREAK || ret === BREAK) {
              return;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }

            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];

            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error('Unknown node type ' + nodeType + '.');
              }
            }

            current = candidates.length;

            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];

              if (!candidate) {
                continue;
              }

              if (Array.isArray(candidate)) {
                current2 = candidate.length;

                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }

                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }

                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], 'Property', null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }

                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }

                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };

      Controller.prototype.replace = function replace(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

        function removeElem(element) {
          var i, key, nextElem, parent;

          if (element.ref.remove()) {
            // When the reference is an element of an array.
            key = element.ref.key;
            parent = element.ref.parent; // If removed from array, then decrease following items' keys.

            i = worklist.length;

            while (i--) {
              nextElem = worklist[i];

              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key) {
                  break;
                }

                --nextElem.ref.key;
              }
            }
          }
        }

        this.__initialize(root, visitor);

        sentinel = {}; // reference

        worklist = this.__worklist;
        leavelist = this.__leavelist; // initialize

        outer = {
          root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
          element = worklist.pop();

          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element); // node may be replaced with null,
            // so distinguish between undefined and null in this place

            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
              // replace
              element.ref.replace(target);
            }

            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }

            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }

            continue;
          }

          target = this.__execute(visitor.enter, element); // node may be replaced with null,
          // so distinguish between undefined and null in this place

          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
            // replace
            element.ref.replace(target);
            element.node = target;
          }

          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }

          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          } // node may be null


          node = element.node;

          if (!node) {
            continue;
          }

          worklist.push(sentinel);
          leavelist.push(element);

          if (this.__state === SKIP || target === SKIP) {
            continue;
          }

          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];

          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error('Unknown node type ' + nodeType + '.');
            }
          }

          current = candidates.length;

          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];

            if (!candidate) {
              continue;
            }

            if (Array.isArray(candidate)) {
              current2 = candidate.length;

              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }

                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }

                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }

        return outer.root;
      };

      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }

      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }

      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;

        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
      }

      function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [],
            comment,
            len,
            i,
            cursor;

        if (!tree.range) {
          throw new Error('attachComments needs range information');
        } // tokens array is empty, we attach comments to tree as 'leadingComments'


        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }

            tree.leadingComments = comments;
          }

          return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        } // This is based on John Freeman's implementation.


        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;

            while (cursor < comments.length) {
              comment = comments[cursor];

              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }

              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }

                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            } // already out of owned node


            if (cursor === comments.length) {
              return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;

            while (cursor < comments.length) {
              comment = comments[cursor];

              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }

              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }

                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            } // already out of owned node


            if (cursor === comments.length) {
              return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }

      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;

      exports.cloneEnvironment = function () {
        return clone({});
      };

      return exports;
    })(exports);
    /* vim: set sw=4 ts=4 et tw=80 : */

  });

  var parser = createCommonjsModule(function (module) {
    /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
    (function (root, factory) {
      if ( module.exports) {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {

      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }

        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";

        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }

      peg$subclass(peg$SyntaxError, Error);

      peg$SyntaxError.buildMessage = function (expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function literal(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },
          "class": function _class(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },
          any: function any(expectation) {
            return "any character";
          },
          end: function end(expectation) {
            return "end of input";
          },
          other: function other(expectation) {
            return expectation.description;
          }
        };

        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }

        function literalEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }

        function classEscape(s) {
          return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch);
          });
        }

        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
          var descriptions = new Array(expected.length),
              i,
              j;

          for (i = 0; i < expected.length; i++) {
            descriptions[i] = describeExpectation(expected[i]);
          }

          descriptions.sort();

          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }

            descriptions.length = j;
          }

          switch (descriptions.length) {
            case 1:
              return descriptions[0];

            case 2:
              return descriptions[0] + " or " + descriptions[1];

            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }

        function describeFound(found) {
          return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };

      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};

        var peg$FAILED = {},
            peg$startRuleFunctions = {
          start: peg$parsestart
        },
            peg$startRuleFunction = peg$parsestart,
            peg$c0 = function peg$c0(ss) {
          return ss.length === 1 ? ss[0] : {
            type: 'matches',
            selectors: ss
          };
        },
            peg$c1 = function peg$c1() {
          return void 0;
        },
            peg$c2 = " ",
            peg$c3 = peg$literalExpectation(" ", false),
            peg$c4 = /^[^ [\],():#!=><~+.]/,
            peg$c5 = peg$classExpectation([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false),
            peg$c6 = function peg$c6(i) {
          return i.join('');
        },
            peg$c7 = ">",
            peg$c8 = peg$literalExpectation(">", false),
            peg$c9 = function peg$c9() {
          return 'child';
        },
            peg$c10 = "~",
            peg$c11 = peg$literalExpectation("~", false),
            peg$c12 = function peg$c12() {
          return 'sibling';
        },
            peg$c13 = "+",
            peg$c14 = peg$literalExpectation("+", false),
            peg$c15 = function peg$c15() {
          return 'adjacent';
        },
            peg$c16 = function peg$c16() {
          return 'descendant';
        },
            peg$c17 = ",",
            peg$c18 = peg$literalExpectation(",", false),
            peg$c19 = function peg$c19(s, ss) {
          return [s].concat(ss.map(function (s) {
            return s[3];
          }));
        },
            peg$c20 = function peg$c20(a, ops) {
          return ops.reduce(function (memo, rhs) {
            return {
              type: rhs[0],
              left: memo,
              right: rhs[1]
            };
          }, a);
        },
            peg$c21 = "!",
            peg$c22 = peg$literalExpectation("!", false),
            peg$c23 = function peg$c23(subject, as) {
          var b = as.length === 1 ? as[0] : {
            type: 'compound',
            selectors: as
          };
          if (subject) b.subject = true;
          return b;
        },
            peg$c24 = "*",
            peg$c25 = peg$literalExpectation("*", false),
            peg$c26 = function peg$c26(a) {
          return {
            type: 'wildcard',
            value: a
          };
        },
            peg$c27 = "#",
            peg$c28 = peg$literalExpectation("#", false),
            peg$c29 = function peg$c29(i) {
          return {
            type: 'identifier',
            value: i
          };
        },
            peg$c30 = "[",
            peg$c31 = peg$literalExpectation("[", false),
            peg$c32 = "]",
            peg$c33 = peg$literalExpectation("]", false),
            peg$c34 = function peg$c34(v) {
          return v;
        },
            peg$c35 = /^[><!]/,
            peg$c36 = peg$classExpectation([">", "<", "!"], false, false),
            peg$c37 = "=",
            peg$c38 = peg$literalExpectation("=", false),
            peg$c39 = function peg$c39(a) {
          return (a || '') + '=';
        },
            peg$c40 = /^[><]/,
            peg$c41 = peg$classExpectation([">", "<"], false, false),
            peg$c42 = ".",
            peg$c43 = peg$literalExpectation(".", false),
            peg$c44 = function peg$c44(a, as) {
          return [].concat.apply([a], as).join('');
        },
            peg$c45 = function peg$c45(name, op, value) {
          return {
            type: 'attribute',
            name: name,
            operator: op,
            value: value
          };
        },
            peg$c46 = function peg$c46(name) {
          return {
            type: 'attribute',
            name: name
          };
        },
            peg$c47 = "\"",
            peg$c48 = peg$literalExpectation("\"", false),
            peg$c49 = /^[^\\"]/,
            peg$c50 = peg$classExpectation(["\\", "\""], true, false),
            peg$c51 = "\\",
            peg$c52 = peg$literalExpectation("\\", false),
            peg$c53 = peg$anyExpectation(),
            peg$c54 = function peg$c54(a, b) {
          return a + b;
        },
            peg$c55 = function peg$c55(d) {
          return {
            type: 'literal',
            value: strUnescape(d.join(''))
          };
        },
            peg$c56 = "'",
            peg$c57 = peg$literalExpectation("'", false),
            peg$c58 = /^[^\\']/,
            peg$c59 = peg$classExpectation(["\\", "'"], true, false),
            peg$c60 = /^[0-9]/,
            peg$c61 = peg$classExpectation([["0", "9"]], false, false),
            peg$c62 = function peg$c62(a, b) {
          // Can use `a.flat().join('')` once supported
          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';
          return {
            type: 'literal',
            value: parseFloat(leadingDecimals + b.join(''))
          };
        },
            peg$c63 = function peg$c63(i) {
          return {
            type: 'literal',
            value: i
          };
        },
            peg$c64 = "type(",
            peg$c65 = peg$literalExpectation("type(", false),
            peg$c66 = /^[^ )]/,
            peg$c67 = peg$classExpectation([" ", ")"], true, false),
            peg$c68 = ")",
            peg$c69 = peg$literalExpectation(")", false),
            peg$c70 = function peg$c70(t) {
          return {
            type: 'type',
            value: t.join('')
          };
        },
            peg$c71 = /^[imsu]/,
            peg$c72 = peg$classExpectation(["i", "m", "s", "u"], false, false),
            peg$c73 = "/",
            peg$c74 = peg$literalExpectation("/", false),
            peg$c75 = /^[^\/]/,
            peg$c76 = peg$classExpectation(["/"], true, false),
            peg$c77 = function peg$c77(d, flgs) {
          return {
            type: 'regexp',
            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')
          };
        },
            peg$c78 = function peg$c78(i, is) {
          return {
            type: 'field',
            name: is.reduce(function (memo, p) {
              return memo + p[0] + p[1];
            }, i)
          };
        },
            peg$c79 = ":not(",
            peg$c80 = peg$literalExpectation(":not(", false),
            peg$c81 = function peg$c81(ss) {
          return {
            type: 'not',
            selectors: ss
          };
        },
            peg$c82 = ":matches(",
            peg$c83 = peg$literalExpectation(":matches(", false),
            peg$c84 = function peg$c84(ss) {
          return {
            type: 'matches',
            selectors: ss
          };
        },
            peg$c85 = ":has(",
            peg$c86 = peg$literalExpectation(":has(", false),
            peg$c87 = function peg$c87(ss) {
          return {
            type: 'has',
            selectors: ss
          };
        },
            peg$c88 = ":first-child",
            peg$c89 = peg$literalExpectation(":first-child", false),
            peg$c90 = function peg$c90() {
          return nth(1);
        },
            peg$c91 = ":last-child",
            peg$c92 = peg$literalExpectation(":last-child", false),
            peg$c93 = function peg$c93() {
          return nthLast(1);
        },
            peg$c94 = ":nth-child(",
            peg$c95 = peg$literalExpectation(":nth-child(", false),
            peg$c96 = function peg$c96(n) {
          return nth(parseInt(n.join(''), 10));
        },
            peg$c97 = ":nth-last-child(",
            peg$c98 = peg$literalExpectation(":nth-last-child(", false),
            peg$c99 = function peg$c99(n) {
          return nthLast(parseInt(n.join(''), 10));
        },
            peg$c100 = ":",
            peg$c101 = peg$literalExpectation(":", false),
            peg$c102 = "statement",
            peg$c103 = peg$literalExpectation("statement", true),
            peg$c104 = "expression",
            peg$c105 = peg$literalExpectation("expression", true),
            peg$c106 = "declaration",
            peg$c107 = peg$literalExpectation("declaration", true),
            peg$c108 = "function",
            peg$c109 = peg$literalExpectation("function", true),
            peg$c110 = "pattern",
            peg$c111 = peg$literalExpectation("pattern", true),
            peg$c112 = function peg$c112(c) {
          return {
            type: 'class',
            name: c
          };
        },
            peg$currPos = 0,
            peg$posDetailsCache = [{
          line: 1,
          column: 1
        }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$resultsCache = {},
            peg$result;

        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }

          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }

        function peg$literalExpectation(text, ignoreCase) {
          return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
          };
        }

        function peg$classExpectation(parts, inverted, ignoreCase) {
          return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
          };
        }

        function peg$anyExpectation() {
          return {
            type: "any"
          };
        }

        function peg$endExpectation() {
          return {
            type: "end"
          };
        }

        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p;

          if (details) {
            return details;
          } else {
            p = pos - 1;

            while (!peg$posDetailsCache[p]) {
              p--;
            }

            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column
            };

            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }

              p++;
            }

            peg$posDetailsCache[pos] = details;
            return details;
          }
        }

        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }

          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }

          peg$maxFailExpected.push(expected);
        }

        function peg$buildStructuredError(expected, found, location) {
          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
        }

        function peg$parsestart() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 0,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            s2 = peg$parseselectors();

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();

              if (s3 !== peg$FAILED) {
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();

            if (s1 !== peg$FAILED) {
              s1 = peg$c1();
            }

            s0 = s1;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parse_() {
          var s0, s1;
          var key = peg$currPos * 30 + 1,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = [];

          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c2;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c3);
            }
          }

          while (s1 !== peg$FAILED) {
            s0.push(s1);

            if (input.charCodeAt(peg$currPos) === 32) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              {
                peg$fail(peg$c3);
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseidentifierName() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 2,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = [];

          if (peg$c4.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;

            {
              peg$fail(peg$c5);
            }
          }

          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);

              if (peg$c4.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c5);
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c6(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsebinaryOp() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 3,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parse_();

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 62) {
              s2 = peg$c7;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c8);
              }
            }

            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();

              if (s3 !== peg$FAILED) {
                s1 = peg$c9();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();

            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 126) {
                s2 = peg$c10;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c11);
                }
              }

              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();

                if (s3 !== peg$FAILED) {
                  s1 = peg$c12();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();

              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;

                  {
                    peg$fail(peg$c14);
                  }
                }

                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();

                  if (s3 !== peg$FAILED) {
                    s1 = peg$c15();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              if (s0 === peg$FAILED) {
                s0 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 32) {
                  s1 = peg$c2;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;

                  {
                    peg$fail(peg$c3);
                  }
                }

                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();

                  if (s2 !== peg$FAILED) {
                    s1 = peg$c16();
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseselectors() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          var key = peg$currPos * 30 + 4,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseselector();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();

            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c17;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c18);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();

                if (s6 !== peg$FAILED) {
                  s7 = peg$parseselector();

                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parse_();

              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c17;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c18);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();

                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseselector();

                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c19(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseselector() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 5,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parsesequence();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsebinaryOp();

            if (s4 !== peg$FAILED) {
              s5 = peg$parsesequence();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsebinaryOp();

              if (s4 !== peg$FAILED) {
                s5 = peg$parsesequence();

                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c20(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsesequence() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 6,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c21;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c22);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseatom();

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseatom();
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c23(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseatom() {
          var s0;
          var key = peg$currPos * 30 + 7,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$parsewildcard();

          if (s0 === peg$FAILED) {
            s0 = peg$parseidentifier();

            if (s0 === peg$FAILED) {
              s0 = peg$parseattr();

              if (s0 === peg$FAILED) {
                s0 = peg$parsefield();

                if (s0 === peg$FAILED) {
                  s0 = peg$parsenegation();

                  if (s0 === peg$FAILED) {
                    s0 = peg$parsematches();

                    if (s0 === peg$FAILED) {
                      s0 = peg$parsehas();

                      if (s0 === peg$FAILED) {
                        s0 = peg$parsefirstChild();

                        if (s0 === peg$FAILED) {
                          s0 = peg$parselastChild();

                          if (s0 === peg$FAILED) {
                            s0 = peg$parsenthChild();

                            if (s0 === peg$FAILED) {
                              s0 = peg$parsenthLastChild();

                              if (s0 === peg$FAILED) {
                                s0 = peg$parseclass();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsewildcard() {
          var s0, s1;
          var key = peg$currPos * 30 + 8,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c24;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c25);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c26(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseidentifier() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 9,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c28);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();

            if (s2 !== peg$FAILED) {
              s1 = peg$c29(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattr() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 10,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c30;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c31);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrValue();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c32;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c33);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c34(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrOps() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 11,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (peg$c35.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c36);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c37;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c38);
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c39(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            if (peg$c40.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;

              {
                peg$fail(peg$c41);
              }
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrEqOps() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 12,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c21;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c22);
            }
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s2 = peg$c37;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c38);
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c39(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrName() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 13,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseidentifierName();

          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 46) {
              s4 = peg$c42;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s4 !== peg$FAILED) {
              s5 = peg$parseidentifierName();

              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c42;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c43);
                }
              }

              if (s4 !== peg$FAILED) {
                s5 = peg$parseidentifierName();

                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c44(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseattrValue() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 14,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseattrName();

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseattrEqOps();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  s5 = peg$parsetype();

                  if (s5 === peg$FAILED) {
                    s5 = peg$parseregex();
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c45(s1, s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseattrName();

            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();

              if (s2 !== peg$FAILED) {
                s3 = peg$parseattrOps();

                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();

                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsestring();

                    if (s5 === peg$FAILED) {
                      s5 = peg$parsenumber();

                      if (s5 === peg$FAILED) {
                        s5 = peg$parsepath();
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      s1 = peg$c45(s1, s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }

            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseattrName();

              if (s1 !== peg$FAILED) {
                s1 = peg$c46(s1);
              }

              s0 = s1;
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsestring() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 15,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c47;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c48);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c49.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c50);
              }
            }

            if (s3 === peg$FAILED) {
              s3 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 92) {
                s4 = peg$c51;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c52);
                }
              }

              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c53);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s4 = peg$c54(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }

            while (s3 !== peg$FAILED) {
              s2.push(s3);

              if (peg$c49.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c50);
                }
              }

              if (s3 === peg$FAILED) {
                s3 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c51;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c52);
                  }
                }

                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c53);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s4 = peg$c54(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c47;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c48);
                }
              }

              if (s3 !== peg$FAILED) {
                s1 = peg$c55(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          if (s0 === peg$FAILED) {
            s0 = peg$currPos;

            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c56;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;

              {
                peg$fail(peg$c57);
              }
            }

            if (s1 !== peg$FAILED) {
              s2 = [];

              if (peg$c58.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c59);
                }
              }

              if (s3 === peg$FAILED) {
                s3 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 92) {
                  s4 = peg$c51;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;

                  {
                    peg$fail(peg$c52);
                  }
                }

                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c53);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s4 = peg$c54(s4, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }

              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c58.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c59);
                  }
                }

                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;

                  if (input.charCodeAt(peg$currPos) === 92) {
                    s4 = peg$c51;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c52);
                    }
                  }

                  if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;

                      {
                        peg$fail(peg$c53);
                      }
                    }

                    if (s5 !== peg$FAILED) {
                      s4 = peg$c54(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }

              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c56;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c57);
                  }
                }

                if (s3 !== peg$FAILED) {
                  s1 = peg$c55(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenumber() {
          var s0, s1, s2, s3;
          var key = peg$currPos * 30 + 16,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];

          if (peg$c60.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;

            {
              peg$fail(peg$c61);
            }
          }

          while (s3 !== peg$FAILED) {
            s2.push(s3);

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }
          }

          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c42;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c43);
              }
            }

            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }

          if (s1 === peg$FAILED) {
            s1 = null;
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c60.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c61);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c60.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c61);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c62(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsepath() {
          var s0, s1;
          var key = peg$currPos * 30 + 17,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;
          s1 = peg$parseidentifierName();

          if (s1 !== peg$FAILED) {
            s1 = peg$c63(s1);
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsetype() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 18,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c64) {
            s1 = peg$c64;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c65);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c66.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c67);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c66.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c67);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c70(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseflags() {
          var s0, s1;
          var key = peg$currPos * 30 + 19,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = [];

          if (peg$c71.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c72);
            }
          }

          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);

              if (peg$c71.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;

                {
                  peg$fail(peg$c72);
                }
              }
            }
          } else {
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseregex() {
          var s0, s1, s2, s3, s4;
          var key = peg$currPos * 30 + 20,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c73;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c74);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = [];

            if (peg$c75.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;

              {
                peg$fail(peg$c76);
              }
            }

            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);

                if (peg$c75.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;

                  {
                    peg$fail(peg$c76);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }

            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s3 = peg$c73;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;

                {
                  peg$fail(peg$c74);
                }
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parseflags();

                if (s4 === peg$FAILED) {
                  s4 = null;
                }

                if (s4 !== peg$FAILED) {
                  s1 = peg$c77(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsefield() {
          var s0, s1, s2, s3, s4, s5, s6;
          var key = peg$currPos * 30 + 21,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c42;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c43);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifierName();

            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;

              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c42;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;

                {
                  peg$fail(peg$c43);
                }
              }

              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifierName();

                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }

              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;

                if (input.charCodeAt(peg$currPos) === 46) {
                  s5 = peg$c42;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;

                  {
                    peg$fail(peg$c43);
                  }
                }

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseidentifierName();

                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }

              if (s3 !== peg$FAILED) {
                s1 = peg$c78(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenegation() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 22,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c79) {
            s1 = peg$c79;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c80);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c81(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsematches() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 23,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 9) === peg$c82) {
            s1 = peg$c82;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c83);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c84(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsehas() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 24,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 5) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c86);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = peg$parseselectors();

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c87(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsefirstChild() {
          var s0, s1;
          var key = peg$currPos * 30 + 25,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 12) === peg$c88) {
            s1 = peg$c88;
            peg$currPos += 12;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c89);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c90();
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parselastChild() {
          var s0, s1;
          var key = peg$currPos * 30 + 26,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 11) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c92);
            }
          }

          if (s1 !== peg$FAILED) {
            s1 = peg$c93();
          }

          s0 = s1;
          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenthChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 27,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 11) === peg$c94) {
            s1 = peg$c94;
            peg$currPos += 11;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c95);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c61);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c60.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c61);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c96(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parsenthLastChild() {
          var s0, s1, s2, s3, s4, s5;
          var key = peg$currPos * 30 + 28,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.substr(peg$currPos, 16) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 16;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c98);
            }
          }

          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();

            if (s2 !== peg$FAILED) {
              s3 = [];

              if (peg$c60.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;

                {
                  peg$fail(peg$c61);
                }
              }

              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);

                  if (peg$c60.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;

                    {
                      peg$fail(peg$c61);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }

              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();

                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c68;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;

                    {
                      peg$fail(peg$c69);
                    }
                  }

                  if (s5 !== peg$FAILED) {
                    s1 = peg$c99(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function peg$parseclass() {
          var s0, s1, s2;
          var key = peg$currPos * 30 + 29,
              cached = peg$resultsCache[key];

          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }

          s0 = peg$currPos;

          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c100;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;

            {
              peg$fail(peg$c101);
            }
          }

          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {
              s2 = input.substr(peg$currPos, 9);
              peg$currPos += 9;
            } else {
              s2 = peg$FAILED;

              {
                peg$fail(peg$c103);
              }
            }

            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {
                s2 = input.substr(peg$currPos, 10);
                peg$currPos += 10;
              } else {
                s2 = peg$FAILED;

                {
                  peg$fail(peg$c105);
                }
              }

              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {
                  s2 = input.substr(peg$currPos, 11);
                  peg$currPos += 11;
                } else {
                  s2 = peg$FAILED;

                  {
                    peg$fail(peg$c107);
                  }
                }

                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {
                    s2 = input.substr(peg$currPos, 8);
                    peg$currPos += 8;
                  } else {
                    s2 = peg$FAILED;

                    {
                      peg$fail(peg$c109);
                    }
                  }

                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {
                      s2 = input.substr(peg$currPos, 7);
                      peg$currPos += 7;
                    } else {
                      s2 = peg$FAILED;

                      {
                        peg$fail(peg$c111);
                      }
                    }
                  }
                }
              }
            }

            if (s2 !== peg$FAILED) {
              s1 = peg$c112(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }

          peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
          };
          return s0;
        }

        function nth(n) {
          return {
            type: 'nth-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }

        function nthLast(n) {
          return {
            type: 'nth-last-child',
            index: {
              type: 'literal',
              value: n
            }
          };
        }

        function strUnescape(s) {
          return s.replace(/\\(.)/g, function (match, ch) {
            switch (ch) {
              case 'b':
                return '\b';

              case 'f':
                return '\f';

              case 'n':
                return '\n';

              case 'r':
                return '\r';

              case 't':
                return '\t';

              case 'v':
                return '\v';

              default:
                return ch;
            }
          });
        }

        peg$result = peg$startRuleFunction();

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }

          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }

      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    });
  });

  function _objectEntries(obj) {
    var entries = [];
    var keys = Object.keys(obj);

    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);

    return entries;
  }
  /**
  * @typedef {"LEFT_SIDE"|"RIGHT_SIDE"} Side
  */

  var LEFT_SIDE = 'LEFT_SIDE';
  var RIGHT_SIDE = 'RIGHT_SIDE';
  /**
   * @external AST
   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html
   */

  /**
   * One of the rules of `grammar.pegjs`
   * @typedef {PlainObject} SelectorAST
   * @see grammar.pegjs
  */

  /**
   * The `sequence` production of `grammar.pegjs`
   * @typedef {PlainObject} SelectorSequenceAST
  */

  /**
   * Get the value of a property which may be multiple levels down
   * in the object.
   * @param {?PlainObject} obj
   * @param {string} key
   * @returns {undefined|boolean|string|number|external:AST}
   */

  function getPath(obj, key) {
    var keys = key.split('.');

    var _iterator = _createForOfIteratorHelper(keys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (obj == null) {
          return obj;
        }

        obj = obj[_key];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return obj;
  }
  /**
   * Determine whether `node` can be reached by following `path`,
   * starting at `ancestor`.
   * @param {?external:AST} node
   * @param {?external:AST} ancestor
   * @param {string[]} path
   * @returns {boolean}
   */


  function inPath(node, ancestor, path) {
    if (path.length === 0) {
      return node === ancestor;
    }

    if (ancestor == null) {
      return false;
    }

    var field = ancestor[path[0]];
    var remainingPath = path.slice(1);

    if (Array.isArray(field)) {
      var _iterator2 = _createForOfIteratorHelper(field),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var component = _step2.value;

          if (inPath(node, component, remainingPath)) {
            return true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return false;
    } else {
      return inPath(node, field, remainingPath);
    }
  }
  /**
   * @callback TraverseOptionFallback
   * @param {external:AST} node The given node.
   * @returns {string[]} An array of visitor keys for the given node.
   */

  /**
   * @typedef {object} ESQueryOptions
   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.
   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.
   */

  /**
   * Given a `node` and its ancestors, determine if `node` is matched
   * by `selector`.
   * @param {?external:AST} node
   * @param {?SelectorAST} selector
   * @param {external:AST[]} [ancestry=[]]
   * @param {ESQueryOptions} [options]
   * @throws {Error} Unknowns (operator, class name, selector type, or
   * selector value type)
   * @returns {boolean}
   */


  function matches(node, selector, ancestry, options) {
    if (!selector) {
      return true;
    }

    if (!node) {
      return false;
    }

    if (!ancestry) {
      ancestry = [];
    }

    switch (selector.type) {
      case 'wildcard':
        return true;

      case 'identifier':
        return selector.value.toLowerCase() === node.type.toLowerCase();

      case 'field':
        {
          var path = selector.name.split('.');
          var ancestor = ancestry[path.length - 1];
          return inPath(node, ancestor, path);
        }

      case 'matches':
        var _iterator3 = _createForOfIteratorHelper(selector.selectors),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var sel = _step3.value;

            if (matches(node, sel, ancestry, options)) {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return false;

      case 'compound':
        var _iterator4 = _createForOfIteratorHelper(selector.selectors),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _sel = _step4.value;

            if (!matches(node, _sel, ancestry, options)) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return true;

      case 'not':
        var _iterator5 = _createForOfIteratorHelper(selector.selectors),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _sel2 = _step5.value;

            if (matches(node, _sel2, ancestry, options)) {
              return false;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return true;

      case 'has':
        {
          var _ret = function () {
            var collector = [];

            var _iterator6 = _createForOfIteratorHelper(selector.selectors),
                _step6;

            try {
              var _loop = function _loop() {
                var sel = _step6.value;
                var a = [];
                estraverse.traverse(node, {
                  enter: function enter(node, parent) {
                    if (parent != null) {
                      a.unshift(parent);
                    }

                    if (matches(node, sel, a, options)) {
                      collector.push(node);
                    }
                  },
                  leave: function leave() {
                    a.shift();
                  },
                  keys: options && options.visitorKeys,
                  fallback: options && options.fallback || 'iteration'
                });
              };

              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            return {
              v: collector.length !== 0
            };
          }();

          if (_typeof(_ret) === "object") return _ret.v;
        }

      case 'child':
        if (matches(node, selector.right, ancestry, options)) {
          return matches(ancestry[0], selector.left, ancestry.slice(1), options);
        }

        return false;

      case 'descendant':
        if (matches(node, selector.right, ancestry, options)) {
          for (var i = 0, l = ancestry.length; i < l; ++i) {
            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {
              return true;
            }
          }
        }

        return false;

      case 'attribute':
        {
          var p = getPath(node, selector.name);

          switch (selector.operator) {
            case void 0:
              return p != null;

            case '=':
              switch (selector.value.type) {
                case 'regexp':
                  return typeof p === 'string' && selector.value.value.test(p);

                case 'literal':
                  return "".concat(selector.value.value) === "".concat(p);

                case 'type':
                  return selector.value.value === _typeof(p);
              }

              throw new Error("Unknown selector value type: ".concat(selector.value.type));

            case '!=':
              switch (selector.value.type) {
                case 'regexp':
                  return !selector.value.value.test(p);

                case 'literal':
                  return "".concat(selector.value.value) !== "".concat(p);

                case 'type':
                  return selector.value.value !== _typeof(p);
              }

              throw new Error("Unknown selector value type: ".concat(selector.value.type));

            case '<=':
              return p <= selector.value.value;

            case '<':
              return p < selector.value.value;

            case '>':
              return p > selector.value.value;

            case '>=':
              return p >= selector.value.value;
          }

          throw new Error("Unknown operator: ".concat(selector.operator));
        }

      case 'sibling':
        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);

      case 'adjacent':
        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);

      case 'nth-child':
        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {
          return selector.index.value - 1;
        }, options);

      case 'nth-last-child':
        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {
          return length - selector.index.value;
        }, options);

      case 'class':
        switch (selector.name.toLowerCase()) {
          case 'statement':
            if (node.type.slice(-9) === 'Statement') return true;
          // fallthrough: interface Declaration <: Statement { }

          case 'declaration':
            return node.type.slice(-11) === 'Declaration';

          case 'pattern':
            if (node.type.slice(-7) === 'Pattern') return true;
          // fallthrough: interface Expression <: Node, Pattern { }

          case 'expression':
            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';

          case 'function':
            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';
        }

        throw new Error("Unknown class name: ".concat(selector.name));
    }

    throw new Error("Unknown selector type: ".concat(selector.type));
  }
  /**
   * Get visitor keys of a given node.
   * @param {external:AST} node The AST node to get keys.
   * @param {ESQueryOptions|undefined} options
   * @returns {string[]} Visitor keys of the node.
   */


  function getVisitorKeys(node, options) {
    var nodeType = node.type;

    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {
      return options.visitorKeys[nodeType];
    }

    if (estraverse.VisitorKeys[nodeType]) {
      return estraverse.VisitorKeys[nodeType];
    }

    if (options && typeof options.fallback === 'function') {
      return options.fallback(node);
    } // 'iteration' fallback


    return Object.keys(node).filter(function (key) {
      return key !== 'type';
    });
  }
  /**
   * Check whether the given value is an ASTNode or not.
   * @param {any} node The value to check.
   * @returns {boolean} `true` if the value is an ASTNode.
   */


  function isNode(node) {
    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';
  }
  /**
   * Determines if the given node has a sibling that matches the
   * given selector.
   * @param {external:AST} node
   * @param {SelectorSequenceAST} selector
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function sibling(node, selector, ancestry, side, options) {
    var _ancestry = _slicedToArray(ancestry, 1),
        parent = _ancestry[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator7 = _createForOfIteratorHelper(keys),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var key = _step7.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var startIndex = listProp.indexOf(node);

          if (startIndex < 0) {
            continue;
          }

          var lowerBound = void 0,
              upperBound = void 0;

          if (side === LEFT_SIDE) {
            lowerBound = 0;
            upperBound = startIndex;
          } else {
            lowerBound = startIndex + 1;
            upperBound = listProp.length;
          }

          for (var k = lowerBound; k < upperBound; ++k) {
            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {
              return true;
            }
          }
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return false;
  }
  /**
   * Determines if the given node has an adjacent sibling that matches
   * the given selector.
   * @param {external:AST} node
   * @param {SelectorSequenceAST} selector
   * @param {external:AST[]} ancestry
   * @param {Side} side
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function adjacent(node, selector, ancestry, side, options) {
    var _ancestry2 = _slicedToArray(ancestry, 1),
        parent = _ancestry2[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator8 = _createForOfIteratorHelper(keys),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var key = _step8.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var idx = listProp.indexOf(node);

          if (idx < 0) {
            continue;
          }

          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {
            return true;
          }

          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {
            return true;
          }
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    return false;
  }
  /**
  * @callback IndexFunction
  * @param {Integer} len Containing list's length
  * @returns {Integer}
  */

  /**
   * Determines if the given node is the nth child, determined by
   * `idxFn`, which is given the containing list's length.
   * @param {external:AST} node
   * @param {external:AST[]} ancestry
   * @param {IndexFunction} idxFn
   * @param {ESQueryOptions|undefined} options
   * @returns {boolean}
   */


  function nthChild(node, ancestry, idxFn, options) {
    var _ancestry3 = _slicedToArray(ancestry, 1),
        parent = _ancestry3[0];

    if (!parent) {
      return false;
    }

    var keys = getVisitorKeys(parent, options);

    var _iterator9 = _createForOfIteratorHelper(keys),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var key = _step9.value;
        var listProp = parent[key];

        if (Array.isArray(listProp)) {
          var idx = listProp.indexOf(node);

          if (idx >= 0 && idx === idxFn(listProp.length)) {
            return true;
          }
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    return false;
  }
  /**
   * For each selector node marked as a subject, find the portion of the
   * selector that the subject must match.
   * @param {SelectorAST} selector
   * @param {SelectorAST} [ancestor] Defaults to `selector`
   * @returns {SelectorAST[]}
   */


  function subjects(selector, ancestor) {
    if (selector == null || _typeof(selector) != 'object') {
      return [];
    }

    if (ancestor == null) {
      ancestor = selector;
    }

    var results = selector.subject ? [ancestor] : [];

    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          p = _Object$entries$_i[0],
          sel = _Object$entries$_i[1];

      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));
    }

    return results;
  }
  /**
  * @callback TraverseVisitor
  * @param {?external:AST} node
  * @param {?external:AST} parent
  * @param {external:AST[]} ancestry
  */

  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {TraverseVisitor} visitor
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function traverse(ast, selector, visitor, options) {
    if (!selector) {
      return;
    }

    var ancestry = [];
    var altSubjects = subjects(selector);
    estraverse.traverse(ast, {
      enter: function enter(node, parent) {
        if (parent != null) {
          ancestry.unshift(parent);
        }

        if (matches(node, selector, ancestry, options)) {
          if (altSubjects.length) {
            for (var i = 0, l = altSubjects.length; i < l; ++i) {
              if (matches(node, altSubjects[i], ancestry, options)) {
                visitor(node, parent, ancestry);
              }

              for (var k = 0, m = ancestry.length; k < m; ++k) {
                var succeedingAncestry = ancestry.slice(k + 1);

                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {
                  visitor(ancestry[k], parent, succeedingAncestry);
                }
              }
            }
          } else {
            visitor(node, parent, ancestry);
          }
        }
      },
      leave: function leave() {
        ancestry.shift();
      },
      keys: options && options.visitorKeys,
      fallback: options && options.fallback || 'iteration'
    });
  }
  /**
   * From a JS AST and a selector AST, collect all JS AST nodes that
   * match the selector.
   * @param {external:AST} ast
   * @param {?SelectorAST} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function match(ast, selector, options) {
    var results = [];
    traverse(ast, selector, function (node) {
      results.push(node);
    }, options);
    return results;
  }
  /**
   * Parse a selector string and return its AST.
   * @param {string} selector
   * @returns {SelectorAST}
   */


  function parse(selector) {
    return parser.parse(selector);
  }
  /**
   * Query the code AST using the selector string.
   * @param {external:AST} ast
   * @param {string} selector
   * @param {ESQueryOptions} [options]
   * @returns {external:AST[]}
   */


  function query(ast, selector, options) {
    return match(ast, parse(selector), options);
  }

  query.parse = parse;
  query.match = match;
  query.traverse = traverse;
  query.matches = matches;
  query.query = query;

  return query;

})));
­/package.jsonÅð{
  "name": "esquery",
  "version": "1.4.0",
  "author": "Joel Feenstra <jrfeenst+esquery@gmail.com>",
  "contributors": [],
  "description": "A query library for ECMAScript AST using a CSS selector like query language.",
  "main": "dist/esquery.min.js",
  "module": "dist/esquery.esm.min.js",
  "files": [
    "dist/*.js",
    "dist/*.map",
    "parser.js",
    "license.txt",
    "README.md"
  ],
  "nyc": {
    "branches": 100,
    "lines": 100,
    "functions": 100,
    "statements": 100,
    "reporter": [
      "html",
      "text"
    ],
    "exclude": [
      "parser.js",
      "dist",
      "tests"
    ]
  },
  "scripts": {
    "prepublishOnly": "npm run build && npm test",
    "build:parser": "rm parser.js && pegjs --cache --format umd -o \"parser.js\" \"grammar.pegjs\"",
    "build:browser": "rollup -c",
    "build": "npm run build:parser && npm run build:browser",
    "mocha": "mocha --require chai/register-assert --require @babel/register tests",
    "test": "nyc npm run mocha && npm run lint",
    "test:ci": "npm run mocha",
    "lint": "eslint ."
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/estools/esquery.git"
  },
  "bugs": "https://github.com/estools/esquery/issues",
  "homepage": "https://github.com/estools/esquery/",
  "keywords": [
    "ast",
    "ecmascript",
    "javascript",
    "query"
  ],
  "devDependencies": {
    "@babel/core": "^7.9.0",
    "@babel/preset-env": "^7.9.5",
    "@babel/register": "^7.9.0",
    "@rollup/plugin-commonjs": "^11.1.0",
    "@rollup/plugin-json": "^4.0.2",
    "@rollup/plugin-node-resolve": "^7.1.3",
    "babel-plugin-transform-es2017-object-entries": "0.0.5",
    "chai": "^4.2.0",
    "eslint": "^6.8.0",
    "esprima": "~4.0.1",
    "mocha": "^7.1.1",
    "nyc": "^15.0.1",
    "pegjs": "~0.10.0",
    "rollup": "^1.32.1",
    "rollup-plugin-babel": "^4.4.0",
    "rollup-plugin-terser": "^5.3.0"
  },
  "license": "BSD-3-Clause",
  "engines": {
    "node": ">=0.10"
  },
  "dependencies": {
    "estraverse": "^5.1.0"
  }
}
¸/dist/esquery.min.js.mapÆ ‡{"version":3,"file":"esquery.min.js","sources":["../node_modules/estraverse/estraverse.js","../parser.js","../esquery.js"],"sourcesContent":["/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n  \n    function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n            if (leavelist[i].node === candidate) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n\n                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                              continue;\n                            }\n\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        if (candidateExistsInLeaveList(leavelist, candidate)) {\n                          continue;\n                        }\n\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\n          return [s].concat(ss.map(function (s) { return s[3]; }));\n        },\n        peg$c20 = function(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return { type: rhs[0], left: memo, right: rhs[1] };\n            }, a);\n          },\n        peg$c21 = \"!\",\n        peg$c22 = peg$literalExpectation(\"!\", false),\n        peg$c23 = function(subject, as) {\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\n            if(subject) b.subject = true;\n            return b;\n          },\n        peg$c24 = \"*\",\n        peg$c25 = peg$literalExpectation(\"*\", false),\n        peg$c26 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c27 = \"#\",\n        peg$c28 = peg$literalExpectation(\"#\", false),\n        peg$c29 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c30 = \"[\",\n        peg$c31 = peg$literalExpectation(\"[\", false),\n        peg$c32 = \"]\",\n        peg$c33 = peg$literalExpectation(\"]\", false),\n        peg$c34 = function(v) { return v; },\n        peg$c35 = /^[><!]/,\n        peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c37 = \"=\",\n        peg$c38 = peg$literalExpectation(\"=\", false),\n        peg$c39 = function(a) { return (a || '') + '='; },\n        peg$c40 = /^[><]/,\n        peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c42 = \".\",\n        peg$c43 = peg$literalExpectation(\".\", false),\n        peg$c44 = function(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n        peg$c45 = function(name, op, value) {\n              return { type: 'attribute', name: name, operator: op, value: value };\n            },\n        peg$c46 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c47 = \"\\\"\",\n        peg$c48 = peg$literalExpectation(\"\\\"\", false),\n        peg$c49 = /^[^\\\\\"]/,\n        peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c51 = \"\\\\\",\n        peg$c52 = peg$literalExpectation(\"\\\\\", false),\n        peg$c53 = peg$anyExpectation(),\n        peg$c54 = function(a, b) { return a + b; },\n        peg$c55 = function(d) {\n                return { type: 'literal', value: strUnescape(d.join('')) };\n              },\n        peg$c56 = \"'\",\n        peg$c57 = peg$literalExpectation(\"'\", false),\n        peg$c58 = /^[^\\\\']/,\n        peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c60 = /^[0-9]/,\n        peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c62 = function(a, b) {\n                // Can use `a.flat().join('')` once supported\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\n              },\n        peg$c63 = function(i) { return { type: 'literal', value: i }; },\n        peg$c64 = \"type(\",\n        peg$c65 = peg$literalExpectation(\"type(\", false),\n        peg$c66 = /^[^ )]/,\n        peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c68 = \")\",\n        peg$c69 = peg$literalExpectation(\")\", false),\n        peg$c70 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c71 = /^[imsu]/,\n        peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c73 = \"/\",\n        peg$c74 = peg$literalExpectation(\"/\", false),\n        peg$c75 = /^[^\\/]/,\n        peg$c76 = peg$classExpectation([\"/\"], true, false),\n        peg$c77 = function(d, flgs) { return {\n              type: 'regexp', value: new RegExp(d.join(''), flgs ? flgs.join('') : '') };\n            },\n        peg$c78 = function(i, is) {\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\n        },\n        peg$c79 = \":not(\",\n        peg$c80 = peg$literalExpectation(\":not(\", false),\n        peg$c81 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c82 = \":matches(\",\n        peg$c83 = peg$literalExpectation(\":matches(\", false),\n        peg$c84 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c85 = \":has(\",\n        peg$c86 = peg$literalExpectation(\":has(\", false),\n        peg$c87 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c88 = \":first-child\",\n        peg$c89 = peg$literalExpectation(\":first-child\", false),\n        peg$c90 = function() { return nth(1); },\n        peg$c91 = \":last-child\",\n        peg$c92 = peg$literalExpectation(\":last-child\", false),\n        peg$c93 = function() { return nthLast(1); },\n        peg$c94 = \":nth-child(\",\n        peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c96 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c97 = \":nth-last-child(\",\n        peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c99 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c100 = \":\",\n        peg$c101 = peg$literalExpectation(\":\", false),\n        peg$c102 = \"statement\",\n        peg$c103 = peg$literalExpectation(\"statement\", true),\n        peg$c104 = \"expression\",\n        peg$c105 = peg$literalExpectation(\"expression\", true),\n        peg$c106 = \"declaration\",\n        peg$c107 = peg$literalExpectation(\"declaration\", true),\n        peg$c108 = \"function\",\n        peg$c109 = peg$literalExpectation(\"function\", true),\n        peg$c110 = \"pattern\",\n        peg$c111 = peg$literalExpectation(\"pattern\", true),\n        peg$c112 = function(c) {\n          return { type: 'class', name: c };\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 30 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c23(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 30 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsehas();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsefirstChild();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parselastChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsenthChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthLastChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseclass();\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c24;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c27;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c32;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c33); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c34(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c35.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c40.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c21;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c42;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c42;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c44(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c45(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c45(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c46(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c47;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c49.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c51;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c54(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c49.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c50); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c47;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c48); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c56;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c57); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c58.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c59); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c51;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c54(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c58.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c52); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c53); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c56;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c55(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 30 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c42;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c61); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c61); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c62(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c64) {\n        s1 = peg$c64;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c66.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c67); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c70(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c71.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c72); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 30 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c75.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c76); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c73;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c74); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c77(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 30 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c42;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c42;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c42;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c78(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c79) {\n        s1 = peg$c79;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c81(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c82) {\n        s1 = peg$c82;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c84(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 30 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c93();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c96(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 30 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c97) {\n        s1 = peg$c97;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c68;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c99(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 30 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c100;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c101); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n          s2 = input.substr(peg$currPos, 9);\n          peg$currPos += 9;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c103); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n            s2 = input.substr(peg$currPos, 10);\n            peg$currPos += 10;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c105); }\n          }\n          if (s2 === peg$FAILED) {\n            if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n              s2 = input.substr(peg$currPos, 11);\n              peg$currPos += 11;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c107); }\n            }\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                s2 = input.substr(peg$currPos, 8);\n                peg$currPos += 8;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c109); }\n              }\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                  s2 = input.substr(peg$currPos, 7);\n                  peg$currPos += 7;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c111); }\n                }\n              }\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c112(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function(match, ch) {\n          switch(ch) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            default: return ch;\n          }\n        });\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\nimport estraverse from 'estraverse';\nimport parser from './parser.js';\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nconst LEFT_SIDE = 'LEFT_SIDE';\nconst RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string} key\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, key) {\n    const keys = key.split('.');\n    for (const key of keys) {\n        if (obj == null) { return obj; }\n        obj = obj[key];\n    }\n    return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path) {\n    if (path.length === 0) { return node === ancestor; }\n    if (ancestor == null) { return false; }\n    const field = ancestor[path[0]];\n    const remainingPath = path.slice(1);\n    if (Array.isArray(field)) {\n        for (const component of field) {\n            if (inPath(node, component, remainingPath)) { return true; }\n        }\n        return false;\n    } else {\n        return inPath(node, field, remainingPath);\n    }\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n/**\n * @typedef {object} ESQueryOptions\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    switch(selector.type) {\n        case 'wildcard':\n            return true;\n\n        case 'identifier':\n            return selector.value.toLowerCase() === node.type.toLowerCase();\n\n        case 'field': {\n            const path = selector.name.split('.');\n            const ancestor = ancestry[path.length - 1];\n            return inPath(node, ancestor, path);\n\n        }\n        case 'matches':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return true; }\n            }\n            return false;\n\n        case 'compound':\n            for (const sel of selector.selectors) {\n                if (!matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'not':\n            for (const sel of selector.selectors) {\n                if (matches(node, sel, ancestry, options)) { return false; }\n            }\n            return true;\n\n        case 'has': {\n            const collector = [];\n            for (const sel of selector.selectors) {\n                const a = [];\n                estraverse.traverse(node, {\n                    enter (node, parent) {\n                        if (parent != null) { a.unshift(parent); }\n                        if (matches(node, sel, a, options)) {\n                            collector.push(node);\n                        }\n                    },\n                    leave () { a.shift(); },\n                    keys: options && options.visitorKeys,\n                    fallback: options && options.fallback || 'iteration'\n                });\n            }\n            return collector.length !== 0;\n\n        }\n        case 'child':\n            if (matches(node, selector.right, ancestry, options)) {\n                return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n            }\n            return false;\n\n        case 'descendant':\n            if (matches(node, selector.right, ancestry, options)) {\n                for (let i = 0, l = ancestry.length; i < l; ++i) {\n                    if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n\n        case 'attribute': {\n            const p = getPath(node, selector.name);\n            switch (selector.operator) {\n                case void 0:\n                    return p != null;\n                case '=':\n                    switch (selector.value.type) {\n                        case 'regexp': return typeof p === 'string' && selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` === `${p}`;\n                        case 'type': return selector.value.value === typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '!=':\n                    switch (selector.value.type) {\n                        case 'regexp': return !selector.value.value.test(p);\n                        case 'literal': return `${selector.value.value}` !== `${p}`;\n                        case 'type': return selector.value.value !== typeof p;\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '<=': return p <= selector.value.value;\n                case '<': return p < selector.value.value;\n                case '>': return p > selector.value.value;\n                case '>=': return p >= selector.value.value;\n            }\n            throw new Error(`Unknown operator: ${selector.operator}`);\n        }\n        case 'sibling':\n            return matches(node, selector.right, ancestry, options) &&\n                sibling(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.left.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n        case 'adjacent':\n            return matches(node, selector.right, ancestry, options) &&\n                adjacent(node, selector.left, ancestry, LEFT_SIDE, options) ||\n                selector.right.subject &&\n                matches(node, selector.left, ancestry, options) &&\n                adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n        case 'nth-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function () {\n                    return selector.index.value - 1;\n                }, options);\n\n        case 'nth-last-child':\n            return matches(node, selector.right, ancestry, options) &&\n                nthChild(node, ancestry, function (length) {\n                    return length - selector.index.value;\n                }, options);\n\n        case 'class':\n            switch(selector.name.toLowerCase()){\n                case 'statement':\n                    if(node.type.slice(-9) === 'Statement') return true;\n                    // fallthrough: interface Declaration <: Statement { }\n                case 'declaration':\n                    return node.type.slice(-11) === 'Declaration';\n                case 'pattern':\n                    if(node.type.slice(-7) === 'Pattern') return true;\n                    // fallthrough: interface Expression <: Node, Pattern { }\n                case 'expression':\n                    return node.type.slice(-10) === 'Expression' ||\n                        node.type.slice(-7) === 'Literal' ||\n                        (\n                            node.type === 'Identifier' &&\n                            (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                        ) ||\n                        node.type === 'MetaProperty';\n                case 'function':\n                    return node.type === 'FunctionDeclaration' ||\n                        node.type === 'FunctionExpression' ||\n                        node.type === 'ArrowFunctionExpression';\n            }\n            throw new Error(`Unknown class name: ${selector.name}`);\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeType = node.type;\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== 'type';\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node) {\n    return node !== null && typeof node === 'object' && typeof node.type === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector.\n * @param {external:AST} node\n * @param {SelectorSequenceAST} selector\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, selector, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) &&  matches(listProp[idx + 1], selector, ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n* @callback IndexFunction\n* @param {Integer} len Containing list's length\n* @returns {Integer}\n*/\n\n/**\n * Determines if the given node is the nth child, determined by\n * `idxFn`, which is given the containing list's length.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {IndexFunction} idxFn\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, idxFn, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (const key of keys) {\n        const listProp = parent[key];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx >= 0 && idx === idxFn(listProp.length)) { return true; }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    for (const [p, sel] of Object.entries(selector)) {\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matches(node, selector, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (matches(node, altSubjects[i], ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["clone","exports","Syntax","VisitorOption","VisitorKeys","BREAK","SKIP","REMOVE","deepCopy","obj","key","val","ret","hasOwnProperty","Reference","parent","Element","node","path","wrap","ref","Controller","isNode","type","isProperty","nodeType","ObjectExpression","ObjectPattern","candidateExistsInLeaveList","leavelist","candidate","i","length","traverse","root","visitor","extendCommentRange","comment","tokens","target","array","func","diff","len","current","upperBound","token","range","extendedRange","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DirectiveStatement","DoWhileStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","GeneratorExpression","Identifier","IfStatement","ImportExpression","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","ModuleSpecifier","NewExpression","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchStatement","SwitchCase","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","Break","Skip","Remove","prototype","replace","this","remove","Array","isArray","splice","iz","j","jz","result","addToPath","push","__current","__leavelist","parents","__execute","callback","element","previous","undefined","__state","call","notify","flag","skip","__initialize","__worklist","__fallback","fallback","Object","keys","__keys","assign","create","worklist","current2","candidates","sentinel","pop","enter","Error","leave","outer","removeElem","nextElem","attachComments","tree","providedComments","cursor","comments","leadingComments","trailingComments","cloneEnvironment","module","peg$SyntaxError","message","expected","found","location","name","captureStackTrace","child","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","descriptions","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c22","peg$c25","peg$c28","peg$c31","peg$c33","peg$c35","peg$c36","peg$c38","peg$c39","a","peg$c40","peg$c41","peg$c43","peg$c45","op","value","operator","peg$c48","peg$c49","peg$c50","peg$c52","peg$c53","peg$c54","b","peg$c55","d","match","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c65","peg$c66","peg$c67","peg$c69","peg$c71","peg$c72","peg$c74","peg$c75","peg$c76","peg$c80","peg$c83","peg$c86","peg$c89","peg$c92","peg$c95","peg$c98","peg$c101","peg$c103","peg$c105","peg$c107","peg$c109","peg$c111","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","s0","s1","s2","ss","cached","peg$resultsCache","nextPos","peg$parse_","peg$parseselectors","selectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","concat","map","peg$parsesequence","reduce","memo","rhs","left","right","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","toLowerCase","peg$parseclass","n","index","factory","matches","selector","ancestry","split","ancestor","inPath","field","remainingPath","sel","collector","estraverse","unshift","shift","visitorKeys","l","getPath","sibling","adjacent","nthChild","getVisitorKeys","filter","_typeof","side","listProp","startIndex","indexOf","lowerBound","k","idx","idxFn","subjects","results","_objectEntries","ast","altSubjects","m","succeedingAncestry","parser","query"],"mappings":"kiFA2BUA,EAAMC,OAGRC,EACAC,EACAC,EACAC,EACAC,EACAC,WAEKC,EAASC,OACAC,EAAKC,EAAfC,EAAM,OACLF,KAAOD,EACJA,EAAII,eAAeH,KACnBC,EAAMF,EAAIC,GAENE,EAAIF,GADW,iBAARC,GAA4B,OAARA,EAChBH,EAASG,GAETA,UAIhBC,WA4LFE,EAAUC,EAAQL,QAClBK,OAASA,OACTL,IAAMA,WAiBNM,EAAQC,EAAMC,EAAMC,EAAMC,QAC1BH,KAAOA,OACPC,KAAOA,OACPC,KAAOA,OACPC,IAAMA,WAGNC,cAuHAC,EAAOL,UACA,MAARA,IAGmB,iBAATA,GAA0C,iBAAdA,EAAKM,eAG1CC,EAAWC,EAAUf,UAClBe,IAAavB,EAAOwB,kBAAoBD,IAAavB,EAAOyB,gBAAkB,eAAiBjB,WAGlGkB,EAA2BC,EAAWC,OACtC,IAAIC,EAAIF,EAAUG,OAAS,EAAGD,GAAK,IAAKA,KACrCF,EAAUE,GAAGd,OAASa,SACf,SAGR,WAwQFG,EAASC,EAAMC,UACH,IAAId,GACHY,SAASC,EAAMC,YAQ5BC,EAAmBC,EAASC,OAC7BC,SAEJA,WA7mBgBC,EAAOC,OACnBC,EAAMC,EAAKZ,EAAGa,MAElBD,EAAMH,EAAMR,OACZD,EAAI,EAEGY,GAGCF,EAAKD,EADTI,EAAUb,GADVW,EAAOC,IAAQ,KAGXA,EAAMD,GAENX,EAAIa,EAAU,EACdD,GAAOD,EAAO,UAGfX,EA6lBEc,CAAWP,GAAQ,SAAgBQ,UACjCA,EAAMC,MAAM,GAAKV,EAAQU,MAAM,MAG1CV,EAAQW,cAAgB,CAACX,EAAQU,MAAM,GAAIV,EAAQU,MAAM,IAErDR,IAAWD,EAAON,SAClBK,EAAQW,cAAc,GAAKV,EAAOC,GAAQQ,MAAM,KAGpDR,GAAU,IACI,IACVF,EAAQW,cAAc,GAAKV,EAAOC,GAAQQ,MAAM,IAG7CV,SAzmBXnC,EAAS,CACL+C,qBAAsB,uBACtBC,kBAAmB,oBACnBC,gBAAiB,kBACjBC,aAAc,eACdC,wBAAyB,0BACzBC,gBAAiB,kBACjBC,eAAgB,iBAChBC,iBAAkB,mBAClBC,eAAgB,iBAChBC,eAAgB,iBAChBC,YAAa,cACbC,gBAAiB,kBACjBC,UAAW,YACXC,iBAAkB,mBAClBC,gBAAiB,kBACjBC,mBAAoB,qBACpBC,wBAAyB,0BACzBC,sBAAuB,wBACvBC,kBAAmB,oBACnBC,kBAAmB,oBACnBC,mBAAoB,qBACpBC,iBAAkB,mBAClBC,eAAgB,iBAChBC,qBAAsB,uBACtBC,yBAA0B,2BAC1BC,uBAAwB,yBACxBC,gBAAiB,kBACjBC,oBAAqB,sBACrBC,aAAc,eACdC,eAAgB,iBAChBC,eAAgB,iBAChBC,oBAAqB,sBACrBC,mBAAoB,qBACpBC,oBAAqB,sBACrBC,WAAY,aACZC,YAAa,cACbC,iBAAkB,mBAClBC,kBAAmB,oBACnBC,uBAAwB,yBACxBC,yBAA0B,2BAC1BC,gBAAiB,kBACjBC,QAAS,UACTC,iBAAkB,mBAClBC,kBAAmB,oBACnBC,iBAAkB,mBAClBC,aAAc,eACdC,iBAAkB,mBAClBC,gBAAiB,kBACjBC,cAAe,gBACfvE,iBAAkB,mBAClBC,cAAe,gBACfuE,QAAS,UACTC,SAAU,WACVC,YAAa,cACbC,gBAAiB,kBACjBC,mBAAoB,qBACpBC,cAAe,gBACfC,MAAO,QACPC,gBAAiB,kBACjBC,WAAY,aACZC,yBAA0B,2BAC1BC,gBAAiB,kBACjBC,gBAAiB,kBACjBC,eAAgB,iBAChBC,eAAgB,iBAChBC,aAAc,eACdC,gBAAiB,kBACjBC,iBAAkB,mBAClBC,oBAAqB,sBACrBC,mBAAoB,qBACpBC,eAAgB,iBAChBC,cAAe,gBACfC,gBAAiB,mBAGrBnH,EAAc,CACV6C,qBAAsB,CAAC,OAAQ,SAC/BC,kBAAmB,CAAC,OAAQ,SAC5BC,gBAAiB,CAAC,YAClBC,aAAc,CAAC,YACfC,wBAAyB,CAAC,SAAU,QACpCC,gBAAiB,CAAC,YAClBC,eAAgB,CAAC,QACjBC,iBAAkB,CAAC,OAAQ,SAC3BC,eAAgB,CAAC,SACjBC,eAAgB,CAAC,SAAU,aAC3BC,YAAa,CAAC,QAAS,QACvBC,gBAAiB,CAAC,cAClBC,UAAW,CAAC,QACZC,iBAAkB,CAAC,KAAM,aAAc,QACvCC,gBAAiB,CAAC,KAAM,aAAc,QACtCC,mBAAoB,CAAC,OAAQ,SAC7BC,wBAAyB,CAAC,SAAU,SAAU,QAC9CC,sBAAuB,CAAC,OAAQ,aAAc,aAC9CC,kBAAmB,CAAC,SACpBC,kBAAmB,GACnBC,mBAAoB,GACpBC,iBAAkB,CAAC,OAAQ,QAC3BC,eAAgB,GAChBC,qBAAsB,CAAC,UACvBC,yBAA0B,CAAC,eAC3BC,uBAAwB,CAAC,cAAe,aAAc,UACtDC,gBAAiB,CAAC,WAAY,SAC9BC,oBAAqB,CAAC,cACtBC,aAAc,CAAC,OAAQ,OAAQ,SAAU,QACzCC,eAAgB,CAAC,OAAQ,QAAS,QAClCC,eAAgB,CAAC,OAAQ,QAAS,QAClCC,oBAAqB,CAAC,KAAM,SAAU,QACtCC,mBAAoB,CAAC,KAAM,SAAU,QACrCC,oBAAqB,CAAC,SAAU,SAAU,QAC1CC,WAAY,GACZC,YAAa,CAAC,OAAQ,aAAc,aACpCC,iBAAkB,CAAC,UACnBC,kBAAmB,CAAC,aAAc,UAClCC,uBAAwB,CAAC,SACzBC,yBAA0B,CAAC,SAC3BC,gBAAiB,CAAC,WAAY,SAC9BC,QAAS,GACTC,iBAAkB,CAAC,QAAS,QAC5BC,kBAAmB,CAAC,OAAQ,SAC5BC,iBAAkB,CAAC,SAAU,YAC7BC,aAAc,CAAC,OAAQ,YACvBC,iBAAkB,CAAC,MAAO,SAC1BC,gBAAiB,GACjBC,cAAe,CAAC,SAAU,aAC1BvE,iBAAkB,CAAC,cACnBC,cAAe,CAAC,cAChBuE,QAAS,CAAC,QACVC,SAAU,CAAC,MAAO,SAClBC,YAAa,CAAE,YACfC,gBAAiB,CAAC,YAClBC,mBAAoB,CAAC,eACrBC,cAAe,CAAC,YAChBC,MAAO,GACPC,gBAAiB,CAAC,eAAgB,SAClCC,WAAY,CAAC,OAAQ,cACrBC,yBAA0B,CAAC,MAAO,SAClCC,gBAAiB,GACjBC,gBAAiB,CAAC,SAAU,eAC5BC,eAAgB,GAChBC,eAAgB,CAAC,YACjBC,aAAc,CAAC,QAAS,UAAW,aACnCC,gBAAiB,CAAC,YAClBC,iBAAkB,CAAC,YACnBC,oBAAqB,CAAC,gBACtBC,mBAAoB,CAAC,KAAM,QAC3BC,eAAgB,CAAC,OAAQ,QACzBC,cAAe,CAAC,SAAU,QAC1BC,gBAAiB,CAAC,aAQtBpH,EAAgB,CACZqH,MALJnH,EAAQ,GAMJoH,KALJnH,EAAO,GAMHoH,OALJnH,EAAS,IAaTO,EAAU6G,UAAUC,QAAU,SAAiB3G,QACtCF,OAAO8G,KAAKnH,KAAOO,GAG5BH,EAAU6G,UAAUG,OAAS,kBACrBC,MAAMC,QAAQH,KAAK9G,cACdA,OAAOkH,OAAOJ,KAAKnH,IAAK,IACtB,SAEFkH,QAAQ,OACN,IAefvG,EAAWsG,UAAUzG,KAAO,eACpBa,EAAGmG,EAAIC,EAAGC,EAAIC,WAETC,EAAUD,EAAQnH,MACnB6G,MAAMC,QAAQ9G,OACTiH,EAAI,EAAGC,EAAKlH,EAAKc,OAAQmG,EAAIC,IAAMD,EACpCE,EAAOE,KAAKrH,EAAKiH,SAGrBE,EAAOE,KAAKrH,OAKf2G,KAAKW,UAAUtH,YACT,SAIXmH,EAAS,GACJtG,EAAI,EAAGmG,EAAKL,KAAKY,YAAYzG,OAAQD,EAAImG,IAAMnG,EAEhDuG,EAAUD,EADAR,KAAKY,YAAY1G,GACDb,aAE9BoH,EAAUD,EAAQR,KAAKW,UAAUtH,MAC1BmH,GAKXhH,EAAWsG,UAAUpG,KAAO,kBACbsG,KAAKjF,UACJrB,MAAQsG,KAAKW,UAAUrH,MAKvCE,EAAWsG,UAAUe,QAAU,eACvB3G,EAAGmG,EAAIG,MAGXA,EAAS,GACJtG,EAAI,EAAGmG,EAAKL,KAAKY,YAAYzG,OAAQD,EAAImG,IAAMnG,EAChDsG,EAAOE,KAAKV,KAAKY,YAAY1G,GAAGd,aAG7BoH,GAKXhH,EAAWsG,UAAU/E,QAAU,kBACpBiF,KAAKW,UAAUvH,MAG1BI,EAAWsG,UAAUgB,UAAY,SAAmBC,EAAUC,OACtDC,EAAUT,SAEdA,OAASU,EAETD,EAAYjB,KAAKW,eACZA,UAAYK,OACZG,QAAU,KACXJ,IACAP,EAASO,EAASK,KAAKpB,KAAMgB,EAAQ5H,KAAM4G,KAAKY,YAAYZ,KAAKY,YAAYzG,OAAS,GAAGf,YAExFuH,UAAYM,EAEVT,GAKXhH,EAAWsG,UAAUuB,OAAS,SAAgBC,QACrCH,QAAUG,GAKnB9H,EAAWsG,UAAUyB,KAAO,gBACnBF,OAAO5I,IAKhBe,EAAWsG,UAAX,MAAgC,gBACvBuB,OAAO7I,IAKhBgB,EAAWsG,UAAUG,OAAS,gBACrBoB,OAAO3I,IAGhBc,EAAWsG,UAAU0B,aAAe,SAASnH,EAAMC,QAC1CA,QAAUA,OACVD,KAAOA,OACPoH,WAAa,QACbb,YAAc,QACdD,UAAY,UACZQ,QAAU,UACVO,WAAa,KACO,cAArBpH,EAAQqH,cACHD,WAAaE,OAAOC,KACU,mBAArBvH,EAAQqH,gBACjBD,WAAapH,EAAQqH,eAGzBG,OAASvJ,EACV+B,EAAQuH,YACHC,OAASF,OAAOG,OAAOH,OAAOI,OAAOhC,KAAK8B,QAASxH,EAAQuH,QAwBxErI,EAAWsG,UAAU1F,SAAW,SAAkBC,EAAMC,OAChD2H,EACAjI,EACAgH,EACA5H,EACAQ,EACAb,EACAF,EACAkC,EACAmH,EACAC,EACAlI,EACAmI,WAECZ,aAAanH,EAAMC,GAExB8H,EAAW,GAGXH,EAAWjC,KAAKyB,WAChBzH,EAAYgG,KAAKY,YAGjBqB,EAASvB,KAAK,IAAIvH,EAAQkB,EAAM,KAAM,KAAM,OAC5CL,EAAU0G,KAAK,IAAIvH,EAAQ,KAAM,KAAM,KAAM,OAEtC8I,EAAS9H,YACZ6G,EAAUiB,EAASI,SAEHD,MAWZpB,EAAQ5H,KAAM,IAEdL,EAAMiH,KAAKc,UAAUxG,EAAQgI,MAAOtB,GAEhChB,KAAKmB,UAAY3I,GAASO,IAAQP,YAItCyJ,EAASvB,KAAK0B,GACdpI,EAAU0G,KAAKM,GAEXhB,KAAKmB,UAAY1I,GAAQM,IAAQN,cAKrCmB,GADAR,EAAO4H,EAAQ5H,MACCM,MAAQsH,EAAQ1H,OAChC6I,EAAanC,KAAK8B,OAAOlI,IACR,KACToG,KAAK0B,iBAGC,IAAIa,MAAM,qBAAuB3I,EAAW,KAFlDuI,EAAanC,KAAK0B,WAAWtI,OAMrC2B,EAAUoH,EAAWhI,QACbY,GAAW,IAAM,MAErBd,EAAYb,EADZP,EAAMsJ,EAAWpH,OAMbmF,MAAMC,QAAQlG,QACdiI,EAAWjI,EAAUE,QACb+H,GAAY,IAAM,MACjBjI,EAAUiI,KAIXnI,EAA2BC,EAAWC,EAAUiI,QAIhDvI,EAAWC,EAAUuI,EAAWpH,IAChCiG,EAAU,IAAI7H,EAAQc,EAAUiI,GAAW,CAACrJ,EAAKqJ,GAAW,WAAY,UACrE,CAAA,IAAIzI,EAAOQ,EAAUiI,aACxBlB,EAAU,IAAI7H,EAAQc,EAAUiI,GAAW,CAACrJ,EAAKqJ,GAAW,KAAM,MAItED,EAASvB,KAAKM,SAEf,GAAIvH,EAAOQ,GAAY,IACtBF,EAA2BC,EAAWC,YAI1CgI,EAASvB,KAAK,IAAIvH,EAAQc,EAAWpB,EAAK,KAAM,iBArExDmI,EAAUhH,EAAUqI,MAEpBtJ,EAAMiH,KAAKc,UAAUxG,EAAQkI,MAAOxB,GAEhChB,KAAKmB,UAAY3I,GAASO,IAAQP,UAwElDgB,EAAWsG,UAAUC,QAAU,SAAiB1F,EAAMC,OAC9C2H,EACAjI,EACAZ,EACAQ,EACAc,EACAsG,EACAjG,EACAmH,EACAC,EACAlI,EACAmI,EACAK,EACA5J,WAEK6J,EAAW1B,OACZ9G,EACArB,EACA8J,EACAzJ,KAEA8H,EAAQzH,IAAI0G,aAEZpH,EAAMmI,EAAQzH,IAAIV,IAClBK,EAAS8H,EAAQzH,IAAIL,OAGrBgB,EAAI+H,EAAS9H,OACND,SACHyI,EAAWV,EAAS/H,IACPX,KAAOoJ,EAASpJ,IAAIL,SAAWA,EAAQ,IAC3CyJ,EAASpJ,IAAIV,IAAMA,UAGtB8J,EAASpJ,IAAIV,cAM1B2I,aAAanH,EAAMC,GAExB8H,EAAW,GAGXH,EAAWjC,KAAKyB,WAChBzH,EAAYgG,KAAKY,YAMjBI,EAAU,IAAI7H,EAAQkB,EAAM,KAAM,KAAM,IAAIpB,EAH5CwJ,EAAQ,CACJpI,KAAMA,GAEmD,SAC7D4H,EAASvB,KAAKM,GACdhH,EAAU0G,KAAKM,GAERiB,EAAS9H,YACZ6G,EAAUiB,EAASI,SAEHD,WA0BDlB,KAJfxG,EAASsF,KAAKc,UAAUxG,EAAQgI,MAAOtB,KAIXtG,IAAWlC,GAASkC,IAAWjC,GAAQiC,IAAWhC,IAE1EsI,EAAQzH,IAAIwG,QAAQrF,GACpBsG,EAAQ5H,KAAOsB,GAGfsF,KAAKmB,UAAYzI,GAAUgC,IAAWhC,IACtCgK,EAAW1B,GACXA,EAAQ5H,KAAO,MAGf4G,KAAKmB,UAAY3I,GAASkC,IAAWlC,SAC9BiK,EAAMpI,SAIjBjB,EAAO4H,EAAQ5H,QAKf6I,EAASvB,KAAK0B,GACdpI,EAAU0G,KAAKM,GAEXhB,KAAKmB,UAAY1I,GAAQiC,IAAWjC,OAIxCmB,EAAWR,EAAKM,MAAQsH,EAAQ1H,OAChC6I,EAAanC,KAAK8B,OAAOlI,IACR,KACToG,KAAK0B,iBAGC,IAAIa,MAAM,qBAAuB3I,EAAW,KAFlDuI,EAAanC,KAAK0B,WAAWtI,OAMrC2B,EAAUoH,EAAWhI,QACbY,GAAW,IAAM,MAErBd,EAAYb,EADZP,EAAMsJ,EAAWpH,OAMbmF,MAAMC,QAAQlG,QACdiI,EAAWjI,EAAUE,QACb+H,GAAY,IAAM,MACjBjI,EAAUiI,OAGXvI,EAAWC,EAAUuI,EAAWpH,IAChCiG,EAAU,IAAI7H,EAAQc,EAAUiI,GAAW,CAACrJ,EAAKqJ,GAAW,WAAY,IAAIjJ,EAAUgB,EAAWiI,QAC9F,CAAA,IAAIzI,EAAOQ,EAAUiI,aACxBlB,EAAU,IAAI7H,EAAQc,EAAUiI,GAAW,CAACrJ,EAAKqJ,GAAW,KAAM,IAAIjJ,EAAUgB,EAAWiI,IAI/FD,EAASvB,KAAKM,SAEXvH,EAAOQ,IACdgI,EAASvB,KAAK,IAAIvH,EAAQc,EAAWpB,EAAK,KAAM,IAAII,EAAUG,EAAMP,cAvFxEmI,EAAUhH,EAAUqI,WAMLnB,KAJfxG,EAASsF,KAAKc,UAAUxG,EAAQkI,MAAOxB,KAIXtG,IAAWlC,GAASkC,IAAWjC,GAAQiC,IAAWhC,GAE1EsI,EAAQzH,IAAIwG,QAAQrF,GAGpBsF,KAAKmB,UAAYzI,GAAUgC,IAAWhC,GACtCgK,EAAW1B,GAGXhB,KAAKmB,UAAY3I,GAASkC,IAAWlC,SAC9BiK,EAAMpI,YA4ElBoI,EAAMpI,MAiIjBjC,EAAQC,OAASA,EACjBD,EAAQgC,SAAWA,EACnBhC,EAAQ2H,iBA3HS1F,EAAMC,UACF,IAAId,GACHuG,QAAQ1F,EAAMC,IA0HpClC,EAAQwK,wBAlGgBC,EAAMC,EAAkBrI,OAEzBD,EAASM,EAAKZ,EAAG6I,EAAhCC,EAAW,OAEVH,EAAK3H,YACA,IAAIqH,MAAM,8CAIf9H,EAAON,OAAQ,IACZ2I,EAAiB3I,OAAQ,KACpBD,EAAI,EAAGY,EAAMgI,EAAiB3I,OAAQD,EAAIY,EAAKZ,GAAK,GACrDM,EAAU7B,EAASmK,EAAiB5I,KAC5BiB,cAAgB,CAAC,EAAG0H,EAAK3H,MAAM,IACvC8H,EAAStC,KAAKlG,GAElBqI,EAAKI,gBAAkBD,SAEpBH,MAGN3I,EAAI,EAAGY,EAAMgI,EAAiB3I,OAAQD,EAAIY,EAAKZ,GAAK,EACrD8I,EAAStC,KAAKnG,EAAmB5B,EAASmK,EAAiB5I,IAAKO,WAIpEsI,EAAS,EACT3I,EAASyI,EAAM,CACXP,MAAO,SAAUlJ,WACToB,EAEGuI,EAASC,EAAS7I,WACrBK,EAAUwI,EAASD,IACP5H,cAAc,GAAK/B,EAAK8B,MAAM,KAItCV,EAAQW,cAAc,KAAO/B,EAAK8B,MAAM,IACnC9B,EAAK6J,kBACN7J,EAAK6J,gBAAkB,IAE3B7J,EAAK6J,gBAAgBvC,KAAKlG,GAC1BwI,EAAS5C,OAAO2C,EAAQ,IAExBA,GAAU,SAKdA,IAAWC,EAAS7I,OACb7B,EAAcqH,MAGrBqD,EAASD,GAAQ5H,cAAc,GAAK/B,EAAK8B,MAAM,GACxC5C,EAAcsH,eAKjCmD,EAAS,EACT3I,EAASyI,EAAM,CACXL,MAAO,SAAUpJ,WACToB,EAEGuI,EAASC,EAAS7I,SACrBK,EAAUwI,EAASD,KACf3J,EAAK8B,MAAM,GAAKV,EAAQW,cAAc,MAItC/B,EAAK8B,MAAM,KAAOV,EAAQW,cAAc,IACnC/B,EAAK8J,mBACN9J,EAAK8J,iBAAmB,IAE5B9J,EAAK8J,iBAAiBxC,KAAKlG,GAC3BwI,EAAS5C,OAAO2C,EAAQ,IAExBA,GAAU,SAKdA,IAAWC,EAAS7I,OACb7B,EAAcqH,MAGrBqD,EAASD,GAAQ5H,cAAc,GAAK/B,EAAK8B,MAAM,GACxC5C,EAAcsH,eAK1BiD,GAOXzK,EAAQG,YAAcA,EACtBH,EAAQE,cAAgBA,EACxBF,EAAQoB,WAAaA,EACrBpB,EAAQ+K,iBAAmB,kBAAqBhL,EAAM,KAE/CC,GACTA,uBCvxByCgL,EAAOhL,UAC9CgL,UAEK,oBASEC,EAAgBC,EAASC,EAAUC,EAAOC,QAC5CH,QAAWA,OACXC,SAAWA,OACXC,MAAWA,OACXC,SAAWA,OACXC,KAAW,cAEuB,mBAA5BnB,MAAMoB,mBACfpB,MAAMoB,kBAAkB3D,KAAMqD,mBAdZO,EAAO1K,YAClB2K,SAAcC,YAAcF,EACrCC,EAAK/D,UAAY5G,EAAO4G,UACxB8D,EAAM9D,UAAY,IAAI+D,EAexBE,CAAaV,EAAiBd,OAE9Bc,EAAgBW,aAAe,SAAST,EAAUC,OAC5CS,EAA2B,CACzBC,QAAS,SAASC,SACT,IAAOC,EAAcD,EAAYE,MAAQ,WAGzC,SAASF,OAEZjK,EADAoK,EAAe,OAGdpK,EAAI,EAAGA,EAAIiK,EAAYI,MAAMpK,OAAQD,IACxCoK,GAAgBH,EAAYI,MAAMrK,aAAcgG,MAC5CsE,EAAYL,EAAYI,MAAMrK,GAAG,IAAM,IAAMsK,EAAYL,EAAYI,MAAMrK,GAAG,IAC9EsK,EAAYL,EAAYI,MAAMrK,UAG7B,KAAOiK,EAAYM,SAAW,IAAM,IAAMH,EAAe,KAGlEI,IAAK,SAASP,SACL,iBAGTQ,IAAK,SAASR,SACL,gBAGTS,MAAO,SAAST,UACPA,EAAYU,uBAIlBC,EAAIC,UACJA,EAAGC,WAAW,GAAGC,SAAS,IAAIC,uBAG9Bd,EAAce,UACdA,EACJpF,QAAQ,MAAO,QACfA,QAAQ,KAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,gBAAyB,SAASgF,SAAa,OAASD,EAAIC,MACpEhF,QAAQ,yBAAyB,SAASgF,SAAa,MAASD,EAAIC,eAGhEP,EAAYW,UACZA,EACJpF,QAAQ,MAAO,QACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,KAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,gBAAyB,SAASgF,SAAa,OAASD,EAAIC,MACpEhF,QAAQ,yBAAyB,SAASgF,SAAa,MAASD,EAAIC,YA6ClE,qBAtCmBxB,OAEpBrJ,EAAGoG,EANoB6D,EAKvBiB,EAAe,IAAIlF,MAAMqD,EAASpJ,YAGjCD,EAAI,EAAGA,EAAIqJ,EAASpJ,OAAQD,IAC/BkL,EAAalL,IATYiK,EASaZ,EAASrJ,GAR1C+J,EAAyBE,EAAYzK,MAAMyK,OAWlDiB,EAAaC,OAETD,EAAajL,OAAS,EAAG,KACtBD,EAAI,EAAGoG,EAAI,EAAGpG,EAAIkL,EAAajL,OAAQD,IACtCkL,EAAalL,EAAI,KAAOkL,EAAalL,KACvCkL,EAAa9E,GAAK8E,EAAalL,GAC/BoG,KAGJ8E,EAAajL,OAASmG,SAGhB8E,EAAajL,aACd,SACIiL,EAAa,QAEjB,SACIA,EAAa,GAAK,OAASA,EAAa,kBAGxCA,EAAaE,MAAM,GAAI,GAAGC,KAAK,MAClC,QACAH,EAAaA,EAAajL,OAAS,IAQxBqL,CAAiBjC,GAAY,iBAJ3BC,UACdA,EAAQ,IAAOY,EAAcZ,GAAS,IAAO,eAGMiC,CAAcjC,GAAS,WA25E9E,CACLkC,YAAarC,EACbsC,eA15EiBC,EAAOC,GACxBA,OAAsB,IAAZA,EAAqBA,EAAU,OA8JrCC,EAwH8BvC,EAAUC,EAAOC,EApR/CsC,EAAa,GAEbC,EAAyB,CAAEC,MAAOC,IAClCC,EAAyBD,GAOzBE,EAASC,GAAuB,KAAK,GACrCC,EAAS,uBACTC,EAASC,GAAqB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAAM,GAAM,GAGjHC,EAASJ,GAAuB,KAAK,GAGrCK,EAAUL,GAAuB,KAAK,GAGtCM,EAAUN,GAAuB,KAAK,GAItCO,EAAUP,GAAuB,KAAK,GAUtCQ,EAAUR,GAAuB,KAAK,GAOtCS,EAAUT,GAAuB,KAAK,GAGtCU,EAAUV,GAAuB,KAAK,GAGtCW,EAAUX,GAAuB,KAAK,GAEtCY,EAAUZ,GAAuB,KAAK,GAEtCa,EAAU,SACVC,EAAUX,GAAqB,CAAC,IAAK,IAAK,MAAM,GAAO,GAEvDY,EAAUf,GAAuB,KAAK,GACtCgB,EAAU,SAASC,UAAaA,GAAK,IAAM,KAC3CC,EAAU,QACVC,EAAUhB,GAAqB,CAAC,IAAK,MAAM,GAAO,GAElDiB,EAAUpB,GAAuB,KAAK,GAItCqB,EAAU,SAAShE,EAAMiE,EAAIC,SAChB,CAAElO,KAAM,YAAagK,KAAMA,EAAMmE,SAAUF,EAAIC,MAAOA,IAInEE,EAAUzB,GAAuB,KAAM,GACvC0B,EAAU,UACVC,EAAUxB,GAAqB,CAAC,KAAM,MAAO,GAAM,GAEnDyB,EAAU5B,GAAuB,MAAM,GACvC6B,EA6HK,CAAExO,KAAM,OA5HbyO,EAAU,SAASb,EAAGc,UAAYd,EAAIc,GACtCC,EAAU,SAASC,SACJ,CAAE5O,KAAM,UAAWkO,OAsyEfzC,EAtyEkCmD,EAAE/C,KAAK,IAuyErDJ,EAAEpF,QAAQ,UAAU,SAASwI,EAAOxD,UAClCA,OACA,UAAY,SACZ,UAAY,SACZ,UAAY,SACZ,UAAY,SACZ,UAAY,SACZ,UAAY,oBACDA,YATDI,GAnyEnBqD,EAAUnC,GAAuB,KAAK,GACtCoC,EAAU,UACVC,EAAUlC,GAAqB,CAAC,KAAM,MAAM,GAAM,GAClDmC,EAAU,SACVC,EAAUpC,GAAqB,CAAC,CAAC,IAAK,OAAO,GAAO,GAQpDqC,EAAUxC,GAAuB,SAAS,GAC1CyC,EAAU,SACVC,EAAUvC,GAAqB,CAAC,IAAK,MAAM,GAAM,GAEjDwC,EAAU3C,GAAuB,KAAK,GAEtC4C,EAAU,UACVC,EAAU1C,GAAqB,CAAC,IAAK,IAAK,IAAK,MAAM,GAAO,GAE5D2C,EAAU9C,GAAuB,KAAK,GACtC+C,EAAU,SACVC,EAAU7C,GAAqB,CAAC,MAAM,GAAM,GAQ5C8C,EAAUjD,GAAuB,SAAS,GAG1CkD,EAAUlD,GAAuB,aAAa,GAG9CmD,EAAUnD,GAAuB,SAAS,GAG1CoD,GAAUpD,GAAuB,gBAAgB,GAGjDqD,GAAUrD,GAAuB,eAAe,GAGhDsD,GAAUtD,GAAuB,eAAe,GAGhDuD,GAAUvD,GAAuB,oBAAoB,GAGrDwD,GAAWxD,GAAuB,KAAK,GAEvCyD,GAAWzD,GAAuB,aAAa,GAE/C0D,GAAW1D,GAAuB,cAAc,GAEhD2D,GAAW3D,GAAuB,eAAe,GAEjD4D,GAAW5D,GAAuB,YAAY,GAE9C6D,GAAW7D,GAAuB,WAAW,GAK7C8D,GAAuB,EAEvBC,GAAuB,CAAC,CAAEC,KAAM,EAAGC,OAAQ,IAC3CC,GAAuB,EACvBC,GAAuB,GACvBC,GAEmB,MAInB,cAAe5E,EAAS,MACpBA,EAAQ6E,aAAa1E,SACnB,IAAIzD,MAAM,mCAAqCsD,EAAQ6E,UAAY,MAG3EvE,EAAwBH,EAAuBH,EAAQ6E,oBA2BhDrE,GAAuBhC,EAAMsG,SAC7B,CAAEjR,KAAM,UAAW2K,KAAMA,EAAMsG,WAAYA,YAG3CnE,GAAqBjC,EAAOE,EAAUkG,SACtC,CAAEjR,KAAM,QAAS6K,MAAOA,EAAOE,SAAUA,EAAUkG,WAAYA,YAe/DC,GAAsBC,OACWC,EAApCC,EAAUX,GAAoBS,MAE9BE,SACKA,MAEPD,EAAID,EAAM,GACFT,GAAoBU,IAC1BA,QAIFC,EAAU,CACRV,MAFFU,EAAUX,GAAoBU,IAEZT,KAChBC,OAAQS,EAAQT,QAGXQ,EAAID,GACmB,KAAxBjF,EAAMZ,WAAW8F,IACnBC,EAAQV,OACRU,EAAQT,OAAS,GAEjBS,EAAQT,SAGVQ,WAGFV,GAAoBS,GAAOE,EACpBA,WAIFC,GAAoBC,EAAUC,OACjCC,EAAkBP,GAAsBK,GACxCG,EAAkBR,GAAsBM,SAErC,CACLjF,MAAO,CACLoF,OAAQJ,EACRZ,KAAQc,EAAgBd,KACxBC,OAAQa,EAAgBb,QAE1B3F,IAAK,CACH0G,OAAQH,EACRb,KAAQe,EAAcf,KACtBC,OAAQc,EAAcd,kBAKnBgB,GAAS/H,GACZ4G,GAAcI,KAEdJ,GAAcI,KAChBA,GAAiBJ,GACjBK,GAAsB,IAGxBA,GAAoB9J,KAAK6C,aAgBlB2C,SACHqF,EAAIC,EAAIC,EAzRQC,EA2RhB7S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,IACLqB,EAAKM,QACM/F,IACT0F,EAAKM,QACMhG,GACJ+F,OACM/F,EAGTwF,EADAC,EA3SqB,KADPE,EA4SFD,GA3SFtR,OAAeuR,EAAG,GAAK,CAAEhS,KAAM,UAAWsS,UAAWN,IAsTnEvB,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,IACLqB,EAAKM,QACM/F,IAETyF,OAAKS,GAEPV,EAAKC,GAGPI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,YAGAO,SACHP,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,WAGhB+K,EAAK,GACiC,KAAlC3F,EAAMZ,WAAWmF,KACnBqB,EAnVS,IAoVTrB,OAEAqB,EAAKzF,EACwBuF,GAASlF,IAEjCoF,IAAOzF,GACZwF,EAAG7K,KAAK8K,GAC8B,KAAlC5F,EAAMZ,WAAWmF,KACnBqB,EA5VO,IA6VPrB,OAEAqB,EAAKzF,EACwBuF,GAASlF,WAI1CwF,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WAGAW,SACHX,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAIhBgL,EAAK,GACDlF,EAAO6F,KAAKvG,EAAMwG,OAAOjC,MAC3BsB,EAAK7F,EAAMwG,OAAOjC,IAClBA,OAEAsB,EAAK1F,EACwBuF,GAAS/E,IAEpCkF,IAAO1F,OACF0F,IAAO1F,GACZyF,EAAG9K,KAAK+K,GACJnF,EAAO6F,KAAKvG,EAAMwG,OAAOjC,MAC3BsB,EAAK7F,EAAMwG,OAAOjC,IAClBA,OAEAsB,EAAK1F,EACwBuF,GAAS/E,SAI1CiF,EAAKzF,SAEHyF,IAAOzF,IAETyF,EAAYA,EA1YoBjG,KAAK,KA4YvCgG,EAAKC,EAELI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WAGAc,SACHd,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,IACLqB,EAAKM,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBsB,EAlaO,IAmaPtB,OAEAsB,EAAK1F,EACwBuF,GAAS7E,IAEpCgF,IAAO1F,GACJ+F,OACM/F,EAGTwF,EADAC,EA1ayB,SAib3BrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,IACLqB,EAAKM,QACM/F,GAC6B,MAAlCH,EAAMZ,WAAWmF,KACnBsB,EA5bM,IA6bNtB,OAEAsB,EAAK1F,EACwBuF,GAAS5E,IAEpC+E,IAAO1F,GACJ+F,OACM/F,EAGTwF,EADAC,EApcwB,WA2c1BrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,IACLqB,EAAKM,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBsB,EAtdI,IAudJtB,OAEAsB,EAAK1F,EACwBuF,GAAS3E,IAEpC8E,IAAO1F,GACJ+F,OACM/F,EAGTwF,EADAC,EA9dsB,YAqexBrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EA5fG,IA6fHrB,OAEAqB,EAAKzF,EACwBuF,GAASlF,IAEpCoF,IAAOzF,IACT0F,EAAKK,QACM/F,EAGTwF,EADAC,EAxfsB,cA+fxBrB,GAAcoB,EACdA,EAAKxF,MAMb6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,YAGAQ,SACHR,EAAIC,EAAIC,EAAIa,EAAIC,EAAIC,EAAIC,EAAIC,EAE5B7T,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,IACLqB,EAAKmB,QACM5G,EAAY,KACrB0F,EAAK,GACLa,EAAKnC,IACLoC,EAAKT,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EA9hBM,IA+hBNrC,OAEAqC,EAAKzG,EACwBuF,GAAS1E,IAEpC4F,IAAOzG,IACT0G,EAAKX,QACM/F,IACT2G,EAAKC,QACM5G,EAETuG,EADAC,EAAK,CAACA,EAAIC,EAAIC,EAAIC,IAWtBvC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,GAEAuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACRA,EAAKnC,IACLoC,EAAKT,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAjkBI,IAkkBJrC,OAEAqC,EAAKzG,EACwBuF,GAAS1E,IAEpC4F,IAAOzG,IACT0G,EAAKX,QACM/F,IACT2G,EAAKC,QACM5G,EAETuG,EADAC,EAAK,CAACA,EAAIC,EAAIC,EAAIC,IAWtBvC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,GAGL0F,IAAO1F,EAGTwF,EADAC,EA9lBO,CA8lBMA,GA9lBFoB,OA8lBMnB,EA9lBIoB,KAAI,SAAU1H,UAAYA,EAAE,QAimBjDgF,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WAGAoB,SACHpB,EAAIC,EAAIC,EAAIa,EAAIC,EAAIC,EA7mBHlF,EA+mBjBzO,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,IACLqB,EAAKsB,QACM/G,EAAY,KACrB0F,EAAK,GACLa,EAAKnC,IACLoC,EAAKF,QACMtG,IACTyG,EAAKM,QACM/G,EAETuG,EADAC,EAAK,CAACA,EAAIC,IAOZrC,GAAcmC,EACdA,EAAKvG,GAEAuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACRA,EAAKnC,IACLoC,EAAKF,QACMtG,IACTyG,EAAKM,QACM/G,EAETuG,EADAC,EAAK,CAACA,EAAIC,IAOZrC,GAAcmC,EACdA,EAAKvG,GAGL0F,IAAO1F,GA7pBQuB,EA+pBJkE,EACbD,EADAC,EAAiBC,EA9pBJsB,QAAO,SAAUC,EAAMC,SACzB,CAAEvT,KAAMuT,EAAI,GAAIC,KAAMF,EAAMG,MAAOF,EAAI,MAC7C3F,KA+pBL6C,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WAGAuB,SACHvB,EAAIC,EAAIC,EAAIa,EAzqBKc,EAASC,EAClBjF,EA0qBRvP,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EAxrBU,IAyrBVrB,OAEAqB,EAAKzF,EACwBuF,GAASzE,IAEpC2E,IAAOzF,IACTyF,EAAK,MAEHA,IAAOzF,EAAY,IACrB0F,EAAK,IACLa,EAAKgB,QACMvH,OACFuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACRA,EAAKgB,UAGP7B,EAAK1F,EAEH0F,IAAO1F,GA1sBQqH,EA4sBJ5B,EA3sBLpD,EAAkB,KADAiF,EA4sBT5B,GA3sBFtR,OAAekT,EAAG,GAAK,CAAE3T,KAAM,WAAYsS,UAAWqB,GAChED,IAAShF,EAAEgF,SAAU,GA2sB1B7B,EADAC,EAzsBSpD,IA4sBT+B,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WAGA+B,SACH/B,EAEA1S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,iBAyCIA,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAIsB,KAAlCoF,EAAMZ,WAAWmF,KACnBqB,EAzxBU,IA0xBVrB,OAEAqB,EAAKzF,EACwBuF,GAASxE,IAEpC0E,IAAOzF,IAETyF,EA/xB+B,CAAE9R,KAAM,WAAYkO,MA+xBtC4D,IAEfD,EAAKC,EAELI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GApEFgC,MACMxH,IACTwF,iBAsEEA,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,EAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EArzBU,IAszBVrB,OAEAqB,EAAKzF,EACwBuF,GAASvE,IAEpCyE,IAAOzF,IACTyF,EAAK,MAEHA,IAAOzF,IACT0F,EAAKS,QACMnG,EAGTwF,EADAC,EAh0B6B,CAAE9R,KAAM,aAAckO,MAg0BtC6D,IAOftB,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA7GAiC,MACMzH,IACTwF,iBA+GAA,EAAIC,EAAQc,EAAQE,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EA71BU,IA81BVrB,OAEAqB,EAAKzF,EACwBuF,GAAStE,IAEpCwE,IAAOzF,GACJ+F,OACM/F,IACTuG,iBAoOAf,EAAIC,EAAQc,EAAQE,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,IACLqB,EAAKiC,QACM1H,GACJ+F,OACM/F,IACTuG,iBAhJAf,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EAp+BU,IAq+BVrB,OAEAqB,EAAKzF,EACwBuF,GAASzE,IAEpC2E,IAAOzF,IACTyF,EAAK,MAEHA,IAAOzF,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBsB,EA39BQ,IA49BRtB,OAEAsB,EAAK1F,EACwBuF,GAASlE,IAEpCqE,IAAO1F,GAETyF,EAAKnE,EAAQmE,GACbD,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GAmGEmC,MACM3H,GACJ+F,OACM/F,IACTyG,iBAgcJjB,EAAIC,EAAQc,EAAIC,EAAIC,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GA7/CO,UA8/CRvE,EAAM+H,OAAOxD,GAAa,IAC5BqB,EA//CU,QAggDVrB,IAAe,IAEfqB,EAAKzF,EACwBuF,GAASzC,IAEpC2C,IAAOzF,KACJ+F,OACM/F,EAAY,IACrBuG,EAAK,GACDxD,EAAQqD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAASvC,IAEpCwD,IAAOxG,OACFwG,IAAOxG,GACZuG,EAAG5L,KAAK6L,GACJzD,EAAQqD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAASvC,SAI1CuD,EAAKvG,EAEHuG,IAAOvG,IACTwG,EAAKT,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EA9hDE,IA+hDFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,GAETyF,EApiDuB,CAAE9R,KAAM,OAAQkO,MAoiD1B0E,EApiDmC/G,KAAK,KAqiDrDgG,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAOToE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,OAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EAjhBMqC,MACM7H,IACTyG,iBA2jBNjB,EAAIC,EAAIC,EAAIa,EAAIC,EAlmDIsB,EAomDpBhV,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EAnnDU,IAonDVrB,OAEAqB,EAAKzF,EACwBuF,GAASnC,IAEpCqC,IAAOzF,EAAY,IACrB0F,EAAK,GACDrC,EAAQ+C,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAASjC,IAEpCiD,IAAOvG,OACFuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACJlD,EAAQ+C,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAASjC,SAI1CoC,EAAK1F,EAEH0F,IAAO1F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBmC,EAlpDM,IAmpDNnC,OAEAmC,EAAKvG,EACwBuF,GAASnC,IAEpCmD,IAAOvG,IACTwG,iBA3FFhB,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAK,GACDtC,EAAQkD,KAAKvG,EAAMwG,OAAOjC,MAC5BqB,EAAK5F,EAAMwG,OAAOjC,IAClBA,OAEAqB,EAAKzF,EACwBuF,GAASpC,IAEpCsC,IAAOzF,OACFyF,IAAOzF,GACZwF,EAAG7K,KAAK8K,GACJvC,EAAQkD,KAAKvG,EAAMwG,OAAOjC,MAC5BqB,EAAK5F,EAAMwG,OAAOjC,IAClBA,OAEAqB,EAAKzF,EACwBuF,GAASpC,SAI1CqC,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EAuDIuC,MACM/H,IACTwG,EAAK,MAEHA,IAAOxG,GAzpDO8H,EA2pDCtB,EAAjBf,EA3pD+B,CAC/B9R,KAAM,SAAUkO,MAAO,IAAImG,OA0pDdtC,EA1pDuBlG,KAAK,IAAKsI,EAAOA,EAAKtI,KAAK,IAAM,KA2pDrEgG,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EAzoBQyC,IAEHxB,IAAOzG,GAETyF,EAAK9D,EAAQ8D,EAAIc,EAAIE,GACrBjB,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,IACLqB,EAAKiC,QACM1H,GACJ+F,OACM/F,IACTuG,iBAhPFf,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GACDjD,EAAQiF,KAAKvG,EAAMwG,OAAOjC,MAC5BqB,EAAK5F,EAAMwG,OAAOjC,IAClBA,OAEAqB,EAAKzF,EACwBuF,GAASnE,IAEpCqE,IAAOzF,IACTyF,EAAK,MAEHA,IAAOzF,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBsB,EAj6BQ,IAk6BRtB,OAEAsB,EAAK1F,EACwBuF,GAASlE,IAEpCqE,IAAO1F,GAETyF,EAAKnE,EAAQmE,GACbD,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACLwB,EAAQ4E,KAAKvG,EAAMwG,OAAOjC,MAC5BoB,EAAK3F,EAAMwG,OAAOjC,IAClBA,OAEAoB,EAAKxF,EACwBuF,GAAS9D,KAI1CoE,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA0LI0C,MACMlI,GACJ+F,OACM/F,IACTyG,iBAgDNjB,EAAIC,EAAIC,EAAIa,EAAIC,EAAIC,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EA5qCU,IA6qCVrB,OAEAqB,EAAKzF,EACwBuF,GAASxD,IAEpC0D,IAAOzF,EAAY,KACrB0F,EAAK,GACD1D,EAAQoE,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAStD,IAEpCsE,IAAOvG,IACTuG,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EA1rCM,KA2rCNpC,OAEAoC,EAAKxG,EACwBuF,GAASrD,IAEpCsE,IAAOxG,GACLH,EAAMzL,OAASgQ,IACjBqC,EAAK5G,EAAMwG,OAAOjC,IAClBA,OAEAqC,EAAKzG,EACwBuF,GAASpD,IAEpCsE,IAAOzG,GAETwG,EAAKpE,EAAQoE,EAAIC,GACjBF,EAAKC,IAELpC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,IAGFuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACJvE,EAAQoE,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAStD,IAEpCsE,IAAOvG,IACTuG,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EAjuCI,KAkuCJpC,OAEAoC,EAAKxG,EACwBuF,GAASrD,IAEpCsE,IAAOxG,GACLH,EAAMzL,OAASgQ,IACjBqC,EAAK5G,EAAMwG,OAAOjC,IAClBA,OAEAqC,EAAKzG,EACwBuF,GAASpD,IAEpCsE,IAAOzG,GAETwG,EAAKpE,EAAQoE,EAAIC,GACjBF,EAAKC,IAELpC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,IAIP0F,IAAO1F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBmC,EAnwCM,IAowCNnC,OAEAmC,EAAKvG,EACwBuF,GAASxD,IAEpCwE,IAAOvG,GAETyF,EAAKnD,EAAQoD,GACbF,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,KAEHwF,IAAOxF,KACTwF,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EAjxCQ,IAkxCRrB,OAEAqB,EAAKzF,EACwBuF,GAAS9C,IAEpCgD,IAAOzF,EAAY,KACrB0F,EAAK,GACDhD,EAAQ0D,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS5C,IAEpC4D,IAAOvG,IACTuG,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EA1yCI,KA2yCJpC,OAEAoC,EAAKxG,EACwBuF,GAASrD,IAEpCsE,IAAOxG,GACLH,EAAMzL,OAASgQ,IACjBqC,EAAK5G,EAAMwG,OAAOjC,IAClBA,OAEAqC,EAAKzG,EACwBuF,GAASpD,IAEpCsE,IAAOzG,GAETwG,EAAKpE,EAAQoE,EAAIC,GACjBF,EAAKC,IAELpC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,IAGFuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACJ7D,EAAQ0D,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS5C,IAEpC4D,IAAOvG,IACTuG,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EAj1CE,KAk1CFpC,OAEAoC,EAAKxG,EACwBuF,GAASrD,IAEpCsE,IAAOxG,GACLH,EAAMzL,OAASgQ,IACjBqC,EAAK5G,EAAMwG,OAAOjC,IAClBA,OAEAqC,EAAKzG,EACwBuF,GAASpD,IAEpCsE,IAAOzG,GAETwG,EAAKpE,EAAQoE,EAAIC,GACjBF,EAAKC,IAELpC,GAAcmC,EACdA,EAAKvG,KAGPoE,GAAcmC,EACdA,EAAKvG,IAIP0F,IAAO1F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBmC,EAx2CI,IAy2CJnC,OAEAmC,EAAKvG,EACwBuF,GAAS9C,IAEpC8D,IAAOvG,GAETyF,EAAKnD,EAAQoD,GACbF,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAIT6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EA9RQ2C,MACMnI,IACTyG,iBAgSRjB,EAAIC,EAAIC,EAAIa,EAh4CKhF,EAAGc,EAER+F,EAg4CZtV,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,WAGhB+K,EAAKpB,GACLqB,EAAKrB,GACLsB,EAAK,GACD9C,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS1C,IAEjC0D,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACJ3D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS1C,OAGtC6C,IAAO1F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBmC,EA37CQ,IA47CRnC,OAEAmC,EAAKvG,EACwBuF,GAAS7D,IAEpC6E,IAAOvG,EAETyF,EADAC,EAAK,CAACA,EAAIa,IAGVnC,GAAcqB,EACdA,EAAKzF,KAGPoE,GAAcqB,EACdA,EAAKzF,GAEHyF,IAAOzF,IACTyF,EAAK,MAEHA,IAAOzF,EAAY,IACrB0F,EAAK,GACD9C,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS1C,IAEpC0D,IAAOvG,OACFuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACJ3D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BmC,EAAK1G,EAAMwG,OAAOjC,IAClBA,OAEAmC,EAAKvG,EACwBuF,GAAS1C,SAI1C6C,EAAK1F,EAEH0F,IAAO1F,GA58CWqC,EA88CHqD,EA58CL0C,GAFK7G,EA88CJkE,GA58CqB,GAAGoB,OAAOwB,MAAM,GAAI9G,GAAG/B,KAAK,IAAM,GA48CpEiG,EA38Ca,CAAE9R,KAAM,UAAWkO,MAAOyG,WAAWF,EAAkB/F,EAAE7C,KAAK,MA48C3EgG,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EA3XU+C,MACMvI,IACTyG,iBA6XVjB,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAIhBgL,EAAKU,QACMnG,IAETyF,EAz+C+B,CAAE9R,KAAM,UAAWkO,MAy+CrC4D,IAEfD,EAAKC,EAELI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GAlZYgD,IAGL/B,IAAOzG,GAETyF,EAAK9D,EAAQ8D,EAAIc,EAAIE,GACrBjB,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAEHwF,IAAOxF,IACTwF,EAAKpB,IACLqB,EAAKiC,QACM1H,IAETyF,EAppC8B,CAAE9R,KAAM,YAAagK,KAopCtC8H,IAEfD,EAAKC,IAITI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA1UEiD,MACMzI,GACJ+F,OACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAz2BE,IA02BFrC,OAEAqC,EAAKzG,EACwBuF,GAASrE,IAEpCuF,IAAOzG,EAGTwF,EADAC,EAAac,GAGbnC,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA3KEkD,MACM1I,IACTwF,iBA0gCFA,EAAIC,EAAIC,EAAIa,EAAIC,EAAIC,EAAIC,EAjrDPvS,EAmrDjBrB,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EA9uDU,IA+uDVrB,OAEAqB,EAAKzF,EACwBuF,GAAS7D,IAEpC+D,IAAOzF,MACT0F,EAAKS,QACMnG,EAAY,KACrBuG,EAAK,GACLC,EAAKpC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqC,EA1vDM,IA2vDNrC,OAEAqC,EAAKzG,EACwBuF,GAAS7D,IAEpC+E,IAAOzG,IACT0G,EAAKP,QACMnG,EAETwG,EADAC,EAAK,CAACA,EAAIC,IAOZtC,GAAcoC,EACdA,EAAKxG,GAEAwG,IAAOxG,GACZuG,EAAG5L,KAAK6L,GACRA,EAAKpC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqC,EAjxDI,IAkxDJrC,OAEAqC,EAAKzG,EACwBuF,GAAS7D,IAEpC+E,IAAOzG,IACT0G,EAAKP,QACMnG,EAETwG,EADAC,EAAK,CAACA,EAAIC,IAOZtC,GAAcoC,EACdA,EAAKxG,GAGLuG,IAAOvG,GArvDM7L,EAuvDFuR,EAAbD,EAtvDK,CAAE9R,KAAM,QAASgK,KAsvDL4I,EAtvDcS,QAAO,SAASC,EAAMlC,UAAWkC,EAAOlC,EAAE,GAAKA,EAAE,KAAO5Q,IAuvDvFqR,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,OAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EAjmCImD,MACM3I,IACTwF,iBAmmCJA,EAAIC,EAAQc,EAAQE,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GApxDO,UAqxDRvE,EAAM+H,OAAOxD,GAAa,IAC5BqB,EAtxDU,QAuxDVrB,IAAe,IAEfqB,EAAKzF,EACwBuF,GAAShC,IAEpCkC,IAAOzF,GACJ+F,OACM/F,IACTuG,EAAKP,QACMhG,GACJ+F,OACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAnzDE,IAozDFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,EAGTwF,EADAC,EA1yDwB,CAAE9R,KAAM,MAAOsS,UA0yD1BM,IAGbnC,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA/pCMoD,MACM5I,IACTwF,iBAiqCNA,EAAIC,EAAQc,EAAQE,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GAj1DO,cAk1DRvE,EAAM+H,OAAOxD,GAAa,IAC5BqB,EAn1DU,YAo1DVrB,IAAe,IAEfqB,EAAKzF,EACwBuF,GAAS/B,IAEpCiC,IAAOzF,GACJ+F,OACM/F,IACTuG,EAAKP,QACMhG,GACJ+F,OACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAn3DE,IAo3DFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,EAGTwF,EADAC,EAv2DwB,CAAE9R,KAAM,UAAWsS,UAu2D9BM,IAGbnC,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA7tCQqD,MACM7I,IACTwF,iBA+tCRA,EAAIC,EAAQc,EAAQE,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GA94DO,UA+4DRvE,EAAM+H,OAAOxD,GAAa,IAC5BqB,EAh5DU,QAi5DVrB,IAAe,IAEfqB,EAAKzF,EACwBuF,GAAS9B,IAEpCgC,IAAOzF,GACJ+F,OACM/F,IACTuG,EAAKP,QACMhG,GACJ+F,OACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAn7DE,IAo7DFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,EAGTwF,EADAC,EAp6DwB,CAAE9R,KAAM,MAAOsS,UAo6D1BM,IAGbnC,GAAcoB,EACdA,EAAKxF,KAeboE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA3xCUsD,MACM9I,IACTwF,iBA6xCVA,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAx8DJ,iBA48DRoF,EAAM+H,OAAOxD,GAAa,KAC5BqB,EA78DU,eA88DVrB,IAAe,KAEfqB,EAAKzF,EACwBuF,GAAS7B,KAEpC+B,IAAOzF,IAETyF,EAn9D8BsD,GAAI,IAq9DpCvD,EAAKC,EAELI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GAxzCYwD,MACMhJ,IACTwF,iBA0zCZA,EAAIC,EAEJ3S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAp+DJ,gBAw+DRoF,EAAM+H,OAAOxD,GAAa,KAC5BqB,EAz+DU,cA0+DVrB,IAAe,KAEfqB,EAAKzF,EACwBuF,GAAS5B,KAEpC8B,IAAOzF,IAETyF,EA/+D8BwD,GAAQ,IAi/DxCzD,EAAKC,EAELI,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GAr1Cc0D,MACMlJ,IACTwF,iBAu1CdA,EAAIC,EAAQc,EAAIC,EAAIC,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GAngEO,gBAogERvE,EAAM+H,OAAOxD,GAAa,KAC5BqB,EArgEU,cAsgEVrB,IAAe,KAEfqB,EAAKzF,EACwBuF,GAAS3B,KAEpC6B,IAAOzF,KACJ+F,OACM/F,EAAY,IACrBuG,EAAK,GACD3D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAAS1C,IAEpC2D,IAAOxG,OACFwG,IAAOxG,GACZuG,EAAG5L,KAAK6L,GACJ5D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAAS1C,SAI1C0D,EAAKvG,EAEHuG,IAAOvG,IACTwG,EAAKT,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EAtkEE,IAukEFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,GAETyF,EA9iEuBsD,GAAII,SA8iEd5C,EA9iEyB/G,KAAK,IAAK,KA+iEhDgG,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAOToE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,OAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EAx6CgB4D,MACMpJ,IACTwF,iBA06ChBA,EAAIC,EAAQc,EAAIC,EAAIC,EAEpB3T,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,GArlEO,qBAslERvE,EAAM+H,OAAOxD,GAAa,KAC5BqB,EAvlEU,mBAwlEVrB,IAAe,KAEfqB,EAAKzF,EACwBuF,GAAS1B,KAEpC4B,IAAOzF,KACJ+F,OACM/F,EAAY,IACrBuG,EAAK,GACD3D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAAS1C,IAEpC2D,IAAOxG,OACFwG,IAAOxG,GACZuG,EAAG5L,KAAK6L,GACJ5D,EAAQwD,KAAKvG,EAAMwG,OAAOjC,MAC5BoC,EAAK3G,EAAMwG,OAAOjC,IAClBA,OAEAoC,EAAKxG,EACwBuF,GAAS1C,SAI1C0D,EAAKvG,EAEHuG,IAAOvG,IACTwG,EAAKT,QACM/F,GAC6B,KAAlCH,EAAMZ,WAAWmF,KACnBqC,EA3pEE,IA4pEFrC,OAEAqC,EAAKzG,EACwBuF,GAAStC,IAEpCwD,IAAOzG,GAETyF,EAhoEuBwD,GAAQE,SAgoElB5C,EAhoE6B/G,KAAK,IAAK,KAioEpDgG,EAAKC,IAELrB,GAAcoB,EACdA,EAAKxF,KAOToE,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,OAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,EA3/CkB6D,MACMrJ,IACTwF,iBA6/ClBA,EAAIC,EAAIC,EAER5S,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,UAE1B8S,GACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,SAGhB+K,EAAKpB,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBqB,EAzqEW,IA0qEXrB,OAEAqB,EAAKzF,EACwBuF,GAASzB,KAEpC2B,IAAOzF,GA7qEE,cA8qEPH,EAAM+H,OAAOxD,GAAa,GAAGkF,eAC/B5D,EAAK7F,EAAM+H,OAAOxD,GAAa,GAC/BA,IAAe,IAEfsB,EAAK1F,EACwBuF,GAASxB,KAEpC2B,IAAO1F,IAnrEA,eAorELH,EAAM+H,OAAOxD,GAAa,IAAIkF,eAChC5D,EAAK7F,EAAM+H,OAAOxD,GAAa,IAC/BA,IAAe,KAEfsB,EAAK1F,EACwBuF,GAASvB,KAEpC0B,IAAO1F,IAzrEF,gBA0rEHH,EAAM+H,OAAOxD,GAAa,IAAIkF,eAChC5D,EAAK7F,EAAM+H,OAAOxD,GAAa,IAC/BA,IAAe,KAEfsB,EAAK1F,EACwBuF,GAAStB,KAEpCyB,IAAO1F,IA/rEJ,aAgsEDH,EAAM+H,OAAOxD,GAAa,GAAGkF,eAC/B5D,EAAK7F,EAAM+H,OAAOxD,GAAa,GAC/BA,IAAe,IAEfsB,EAAK1F,EACwBuF,GAASrB,KAEpCwB,IAAO1F,IArsEN,YAssECH,EAAM+H,OAAOxD,GAAa,GAAGkF,eAC/B5D,EAAK7F,EAAM+H,OAAOxD,GAAa,GAC/BA,IAAe,IAEfsB,EAAK1F,EACwBuF,GAASpB,SAM5CuB,IAAO1F,EAGTwF,EADAC,EAhtEO,CAAE9R,KAAM,QAASgK,KAgtEV+H,IAGdtB,GAAcoB,EACdA,EAAKxF,KAGPoE,GAAcoB,EACdA,EAAKxF,GAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,GA3kDoB+D,IAa3B1D,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,YAwPAkC,SACHlC,EAAIC,EAAIC,EAAIa,EAAIC,EAAIC,EA7+BHlF,EAAG+F,EA++BpBxU,EAAuB,GAAdsR,GAAmB,GAC5BwB,EAASC,GAAiB/S,MAE1B8S,SACFxB,GAAcwB,EAAOE,QAEdF,EAAOnL,UAGhB+K,EAAKpB,IACLqB,EAAKU,QACMnG,EAAY,KACrB0F,EAAK,GACLa,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EAhgCQ,IAigCRpC,OAEAoC,EAAKxG,EACwBuF,GAAS7D,IAEpC8E,IAAOxG,IACTyG,EAAKN,QACMnG,EAETuG,EADAC,EAAK,CAACA,EAAIC,IAOZrC,GAAcmC,EACdA,EAAKvG,GAEAuG,IAAOvG,GACZ0F,EAAG/K,KAAK4L,GACRA,EAAKnC,GACiC,KAAlCvE,EAAMZ,WAAWmF,KACnBoC,EAvhCM,IAwhCNpC,OAEAoC,EAAKxG,EACwBuF,GAAS7D,IAEpC8E,IAAOxG,IACTyG,EAAKN,QACMnG,EAETuG,EADAC,EAAK,CAACA,EAAIC,IAOZrC,GAAcmC,EACdA,EAAKvG,GAGL0F,IAAO1F,GAziCQuB,EA2iCJkE,EA3iCO6B,EA2iCH5B,EACjBF,EADAC,EA1iCS,GAAGoB,OAAOwB,MAAM,CAAC9G,GAAI+F,GAAI9H,KAAK,MA6iCvC4E,GAAcoB,EACdA,EAAKxF,QAGPoE,GAAcoB,EACdA,EAAKxF,SAGP6F,GAAiB/S,GAAO,CAAEgT,QAAS1B,GAAa3J,OAAQ+K,GAEjDA,WA4vCEuD,GAAIS,SAAY,CAAE7V,KAAM,YAAa8V,MAAO,CAAE9V,KAAM,UAAWkO,MAAO2H,aACtEP,GAAQO,SAAY,CAAE7V,KAAM,iBAAkB8V,MAAO,CAAE9V,KAAM,UAAWkO,MAAO2H,QAgB1FzJ,EAAaK,OAEMJ,GAAcoE,KAAgBvE,EAAMzL,cAC9C2L,QAEHA,IAAeC,GAAcoE,GAAcvE,EAAMzL,QACnDmR,GA7rEK,CAAE5R,KAAM,QAyEiB6J,EAwnE9BiH,GAxnEwChH,EAynExC+G,GAAiB3E,EAAMzL,OAASyL,EAAMwG,OAAO7B,IAAkB,KAznEhB9G,EA0nE/C8G,GAAiB3E,EAAMzL,OACnB6Q,GAAoBT,GAAgBA,GAAiB,GACrDS,GAAoBT,GAAgBA,IA3nEnC,IAAIlH,EACTA,EAAgBW,aAAaT,EAAUC,GACvCD,EACAC,EACAC,KAhaagM,OC+ErB,SAASC,EAAQtW,EAAMuW,EAAUC,EAAU/J,OAClC8J,SAAmB,MACnBvW,SAAe,SACfwW,IAAYA,EAAW,IAErBD,EAASjW,UACP,kBACM,MAEN,oBACMiW,EAAS/H,MAAMyH,gBAAkBjW,EAAKM,KAAK2V,kBAEjD,YACKhW,EAAOsW,EAASjM,KAAKmM,MAAM,KAC3BC,EAAWF,EAASvW,EAAKc,OAAS,UAnDpD,SAAS4V,EAAO3W,EAAM0W,EAAUzW,MACR,IAAhBA,EAAKc,cAAuBf,IAAS0W,KACzB,MAAZA,SAA2B,MACzBE,EAAQF,EAASzW,EAAK,IACtB4W,EAAgB5W,EAAKiM,MAAM,MAC7BpF,MAAMC,QAAQ6P,GAAQ,WACEA,kCAAO,IACvBD,EAAO3W,UAAiB6W,UAAyB,wCAElD,SAEAF,EAAO3W,EAAM4W,EAAOC,GAyChBF,CAAO3W,EAAM0W,EAAUzW,OAG7B,oBACiBsW,EAAS3D,0CAAW,KAA3BkE,aACHR,EAAQtW,EAAM8W,EAAKN,EAAU/J,UAAmB,wCAEjD,MAEN,qBACiB8J,EAAS3D,0CAAW,KAA3BkE,cACFR,EAAQtW,EAAM8W,EAAKN,EAAU/J,UAAmB,wCAElD,MAEN,gBACiB8J,EAAS3D,0CAAW,KAA3BkE,aACHR,EAAQtW,EAAM8W,EAAKN,EAAU/J,UAAmB,wCAEjD,MAEN,6BACKsK,EAAY,OACAR,EAAS3D,oCAAhBkE,UACD5I,EAAI,GACV8I,EAAWhW,SAAShB,EAAM,CACtBkJ,eAAOlJ,EAAMF,GACK,MAAVA,GAAkBoO,EAAE+I,QAAQnX,GAC5BwW,EAAQtW,EAAM8W,EAAK5I,EAAGzB,IACtBsK,EAAUzP,KAAKtH,IAGvBoJ,iBAAW8E,EAAEgJ,SACbzO,KAAMgE,GAAWA,EAAQ0K,YACzB5O,SAAUkE,GAAWA,EAAQlE,UAAY,qFAGrB,IAArBwO,EAAUhW,6CAGhB,gBACGuV,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,IACjC6J,EAAQE,EAAS,GAAID,EAASzC,KAAM0C,EAAStK,MAAM,GAAIO,OAIjE,gBACG6J,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,OACnC,IAAI3L,EAAI,EAAGsW,EAAIZ,EAASzV,OAAQD,EAAIsW,IAAKtW,KACtCwV,EAAQE,EAAS1V,GAAIyV,EAASzC,KAAM0C,EAAStK,MAAMpL,EAAI,GAAI2L,UACpD,SAIZ,MAEN,gBACKiF,EA9HlB,SAAiBlS,EAAKC,aACLA,EAAIgX,MAAM,qCACC,KAAbhX,aACI,MAAPD,SAAsBA,EAC1BA,EAAMA,EAAIC,yCAEPD,EAwHW6X,CAAQrX,EAAMuW,EAASjM,aACzBiM,EAAS9H,oBACR,SACW,MAALiD,MACN,WACO6E,EAAS/H,MAAMlO,UACd,eAA8B,iBAANoR,GAAkB6E,EAAS/H,MAAMA,MAAMuE,KAAKrB,OACpE,gBAAkB,UAAG6E,EAAS/H,MAAMA,mBAAekD,OACnD,cAAe6E,EAAS/H,MAAMA,UAAiBkD,SAElD,IAAIvI,6CAAsCoN,EAAS/H,MAAMlO,WAC9D,YACOiW,EAAS/H,MAAMlO,UACd,gBAAkBiW,EAAS/H,MAAMA,MAAMuE,KAAKrB,OAC5C,gBAAkB,UAAG6E,EAAS/H,MAAMA,mBAAekD,OACnD,cAAe6E,EAAS/H,MAAMA,UAAiBkD,SAElD,IAAIvI,6CAAsCoN,EAAS/H,MAAMlO,WAC9D,YAAaoR,GAAK6E,EAAS/H,MAAMA,UACjC,WAAYkD,EAAI6E,EAAS/H,MAAMA,UAC/B,WAAYkD,EAAI6E,EAAS/H,MAAMA,UAC/B,YAAakD,GAAK6E,EAAS/H,MAAMA,YAEpC,IAAIrF,kCAA2BoN,EAAS9H,eAE7C,iBACM6H,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,IAC3C6K,EAAQtX,EAAMuW,EAASzC,KAAM0C,EAnL3B,YAmLgD/J,IAClD8J,EAASzC,KAAKE,SACdsC,EAAQtW,EAAMuW,EAASzC,KAAM0C,EAAU/J,IACvC6K,EAAQtX,EAAMuW,EAASxC,MAAOyC,EArL3B,aAqLiD/J,OACvD,kBACM6J,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,IAC3C8K,EAASvX,EAAMuW,EAASzC,KAAM0C,EAzL5B,YAyLiD/J,IACnD8J,EAASxC,MAAMC,SACfsC,EAAQtW,EAAMuW,EAASzC,KAAM0C,EAAU/J,IACvC8K,EAASvX,EAAMuW,EAASxC,MAAOyC,EA3L5B,aA2LkD/J,OAExD,mBACM6J,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,IAC3C+K,EAASxX,EAAMwW,GAAU,kBACdD,EAASH,MAAM5H,MAAQ,IAC/B/B,OAEN,wBACM6J,EAAQtW,EAAMuW,EAASxC,MAAOyC,EAAU/J,IAC3C+K,EAASxX,EAAMwW,GAAU,SAAUzV,UACxBA,EAASwV,EAASH,MAAM5H,QAChC/B,OAEN,eACM8J,EAASjM,KAAK2L,mBACZ,eAC0B,cAAxBjW,EAAKM,KAAK4L,OAAO,GAAoB,OAAO,MAE9C,oBAC+B,gBAAzBlM,EAAKM,KAAK4L,OAAO,QACvB,aAC0B,YAAxBlM,EAAKM,KAAK4L,OAAO,GAAkB,OAAO,MAE5C,mBAC+B,eAAzBlM,EAAKM,KAAK4L,OAAO,KACI,YAAxBlM,EAAKM,KAAK4L,OAAO,IAEC,eAAdlM,EAAKM,OACgB,IAApBkW,EAASzV,QAAqC,iBAArByV,EAAS,GAAGlW,OAE5B,iBAAdN,EAAKM,SACR,iBACoB,wBAAdN,EAAKM,MACM,uBAAdN,EAAKM,MACS,4BAAdN,EAAKM,WAEX,IAAI6I,oCAA6BoN,EAASjM,aAGlD,IAAInB,uCAAgCoN,EAASjW,OASvD,SAASmX,EAAezX,EAAMyM,OACpBjM,EAAWR,EAAKM,YAClBmM,GAAWA,EAAQ0K,aAAe1K,EAAQ0K,YAAY3W,GAC/CiM,EAAQ0K,YAAY3W,GAE3BwW,EAAW7X,YAAYqB,GAChBwW,EAAW7X,YAAYqB,GAE9BiM,GAAuC,mBAArBA,EAAQlE,SACnBkE,EAAQlE,SAASvI,GAGrBwI,OAAOC,KAAKzI,GAAM0X,QAAO,SAAUjY,SACvB,SAARA,KAUf,SAASY,EAAOL,UACI,OAATA,GAAiC,WAAhB2X,EAAO3X,IAA0C,iBAAdA,EAAKM,KAapE,SAASgX,EAAQtX,EAAMuW,EAAUC,EAAUoB,EAAMnL,OACtC3M,IAAU0W,YACZ1W,SAAiB,YACT2X,EAAe3X,EAAQ2M,mCACZ,KACdoL,EAAW/X,cACbgH,MAAMC,QAAQ8Q,GAAW,KACnBC,EAAaD,EAASE,QAAQ/X,MAChC8X,EAAa,eACbE,SAAYpW,SA3RV,cA4RFgW,GACAI,EAAa,EACbpW,EAAakW,IAEbE,EAAaF,EAAa,EAC1BlW,EAAaiW,EAAS9W,YAErB,IAAIkX,EAAID,EAAYC,EAAIrW,IAAcqW,KACnC5X,EAAOwX,EAASI,KAAO3B,EAAQuB,EAASI,GAAI1B,EAAUC,EAAU/J,UACzD,yCAKhB,EAaX,SAAS8K,EAASvX,EAAMuW,EAAUC,EAAUoB,EAAMnL,OACvC3M,IAAU0W,YACZ1W,SAAiB,YACT2X,EAAe3X,EAAQ2M,mCACZ,KACdoL,EAAW/X,cACbgH,MAAMC,QAAQ8Q,GAAW,KACnBK,EAAML,EAASE,QAAQ/X,MACzBkY,EAAM,cA/TJ,cAgUFN,GAAsBM,EAAM,GAAK7X,EAAOwX,EAASK,EAAM,KAAO5B,EAAQuB,EAASK,EAAM,GAAI3B,EAAUC,EAAU/J,UACtG,KAhUJ,eAkUHmL,GAAuBM,EAAML,EAAS9W,OAAS,GAAKV,EAAOwX,EAASK,EAAM,KAAQ5B,EAAQuB,EAASK,EAAM,GAAI3B,EAAUC,EAAU/J,UAC1H,yCAIZ,EAkBX,SAAS+K,EAASxX,EAAMwW,EAAU2B,EAAO1L,OAC9B3M,IAAU0W,YACZ1W,SAAiB,YACT2X,EAAe3X,EAAQ2M,mCACZ,KACdoL,EAAW/X,cACbgH,MAAMC,QAAQ8Q,GAAW,KACnBK,EAAML,EAASE,QAAQ/X,MACzBkY,GAAO,GAAKA,IAAQC,EAAMN,EAAS9W,eAAkB,yCAG1D,EAUX,SAASqX,EAAS7B,EAAUG,MACR,MAAZH,GAAuC,UAAnBoB,EAAOpB,SAA+B,GAC9C,MAAZG,IAAoBA,EAAWH,WAC7B8B,EAAU9B,EAASvC,QAAU,CAAC0C,GAAY,sGACzB4B,CAAe/B,kBAAW,iBAArC7E,OAAGoF,OACXuB,EAAQ/Q,WAAR+Q,IAAgBD,EAAStB,EAAW,SAANpF,EAAeoF,EAAMJ,YAEhD2B,EAmBX,SAASrX,EAASuX,EAAKhC,EAAUrV,EAASuL,MACjC8J,OACCC,EAAW,GACXgC,EAAcJ,EAAS7B,GAC7BS,EAAWhW,SAASuX,EAAK,CACrBrP,eAAOlJ,EAAMF,MACK,MAAVA,GAAkB0W,EAASS,QAAQnX,GACnCwW,EAAQtW,EAAMuW,EAAUC,EAAU/J,MAC9B+L,EAAYzX,WACP,IAAID,EAAI,EAAGsW,EAAIoB,EAAYzX,OAAQD,EAAIsW,IAAKtW,EAAG,CAC5CwV,EAAQtW,EAAMwY,EAAY1X,GAAI0V,EAAU/J,IACxCvL,EAAQlB,EAAMF,EAAQ0W,OAErB,IAAIyB,EAAI,EAAGQ,EAAIjC,EAASzV,OAAQkX,EAAIQ,IAAKR,EAAG,KACvCS,EAAqBlC,EAAStK,MAAM+L,EAAI,GAC1C3B,EAAQE,EAASyB,GAAIO,EAAY1X,GAAI4X,EAAoBjM,IACzDvL,EAAQsV,EAASyB,GAAInY,EAAQ4Y,SAKzCxX,EAAQlB,EAAMF,EAAQ0W,IAIlCpN,iBAAWoN,EAASU,SACpBzO,KAAMgE,GAAWA,EAAQ0K,YACzB5O,SAAUkE,GAAWA,EAAQlE,UAAY,eAajD,SAAS4G,EAAMoJ,EAAKhC,EAAU9J,OACpB4L,EAAU,UAChBrX,EAASuX,EAAKhC,GAAU,SAAUvW,GAC9BqY,EAAQ/Q,KAAKtH,KACdyM,GACI4L,EAQX,SAAS9L,EAAMgK,UACJoC,EAAOpM,MAAMgK,GAUxB,SAASqC,EAAML,EAAKhC,EAAU9J,UACnB0C,EAAMoJ,EAAKhM,EAAMgK,GAAW9J,UAGvCmM,EAAMrM,MAAQA,EACdqM,EAAMzJ,MAAQA,EACdyJ,EAAM5X,SAAWA,EACjB4X,EAAMtC,QAAUA,EAChBsC,EAAMA,MAAQA"}¹/dist/esquery.lite.min.jsÅ`B!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("estraverse")):"function"==typeof define&&define.amd?define(["estraverse"],e):(t=t||self).esquery=e(t.estraverse)}(this,(function(t){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(t)))return;var r=[],n=!0,a=!1,o=void 0;try{for(var u,s=t[Symbol.iterator]();!(n=(u=s.next()).done)&&(r.push(u.value),!e||r.length!==e);n=!0);}catch(t){a=!0,o=t}finally{try{n||null==s.return||s.return()}finally{if(a)throw o}}return r}(t,e)||a(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function n(t){return function(t){if(Array.isArray(t))return o(t)}(t)||function(t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(t))return Array.from(t)}(t)||a(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function a(t,e){if(t){if("string"==typeof t)return o(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?o(t,e):void 0}}function o(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function u(t,e){var r;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(r=a(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var u,s=!0,c=!1;return{s:function(){r=t[Symbol.iterator]()},n:function(){var t=r.next();return s=t.done,t},e:function(t){c=!0,u=t},f:function(){try{s||null==r.return||r.return()}finally{if(c)throw u}}}}t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var s=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t){t.exports&&(t.exports=function(){function t(e,r,n,a){this.message=e,this.expected=r,this.found=n,this.location=a,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,t)}return function(t,e){function r(){this.constructor=t}r.prototype=e.prototype,t.prototype=new r}(t,Error),t.buildMessage=function(t,e){var r={literal:function(t){return'"'+a(t.text)+'"'},class:function(t){var e,r="";for(e=0;e<t.parts.length;e++)r+=t.parts[e]instanceof Array?o(t.parts[e][0])+"-"+o(t.parts[e][1]):o(t.parts[e]);return"["+(t.inverted?"^":"")+r+"]"},any:function(t){return"any character"},end:function(t){return"end of input"},other:function(t){return t.description}};function n(t){return t.charCodeAt(0).toString(16).toUpperCase()}function a(t){return t.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(t){return"\\x0"+n(t)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(t){return"\\x"+n(t)}))}function o(t){return t.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,(function(t){return"\\x0"+n(t)})).replace(/[\x10-\x1F\x7F-\x9F]/g,(function(t){return"\\x"+n(t)}))}return"Expected "+function(t){var e,n,a,o=new Array(t.length);for(e=0;e<t.length;e++)o[e]=(a=t[e],r[a.type](a));if(o.sort(),o.length>0){for(e=1,n=1;e<o.length;e++)o[e-1]!==o[e]&&(o[n]=o[e],n++);o.length=n}switch(o.length){case 1:return o[0];case 2:return o[0]+" or "+o[1];default:return o.slice(0,-1).join(", ")+", or "+o[o.length-1]}}(t)+" but "+function(t){return t?'"'+a(t)+'"':"end of input"}(e)+" found."},{SyntaxError:t,parse:function(e,r){r=void 0!==r?r:{};var n,a,o,u,s={},c={start:bt},i=bt,l=vt(" ",!1),f=/^[^ [\],():#!=><~+.]/,h=dt([" ","[","]",",","(",")",":","#","!","=",">","<","~","+","."],!0,!1),p=vt(">",!1),y=vt("~",!1),v=vt("+",!1),d=vt(",",!1),A=vt("!",!1),x=vt("*",!1),g=vt("#",!1),b=vt("[",!1),m=vt("]",!1),P=/^[><!]/,w=dt([">","<","!"],!1,!1),C=vt("=",!1),j=function(t){return(t||"")+"="},S=/^[><]/,E=dt([">","<"],!1,!1),I=vt(".",!1),k=function(t,e,r){return{type:"attribute",name:t,operator:e,value:r}},F=vt('"',!1),T=/^[^\\"]/,L=dt(["\\",'"'],!0,!1),O=vt("\\",!1),D={type:"any"},R=function(t,e){return t+e},K=function(t){return{type:"literal",value:(e=t.join(""),e.replace(/\\(.)/g,(function(t,e){switch(e){case"b":return"\b";case"f":return"\f";case"n":return"\n";case"r":return"\r";case"t":return"\t";case"v":return"\v";default:return e}})))};var e},U=vt("'",!1),_=/^[^\\']/,M=dt(["\\","'"],!0,!1),q=/^[0-9]/,G=dt([["0","9"]],!1,!1),H=vt("type(",!1),V=/^[^ )]/,$=dt([" ",")"],!0,!1),z=vt(")",!1),B=/^[imsu]/,J=dt(["i","m","s","u"],!1,!1),N=vt("/",!1),Q=/^[^\/]/,W=dt(["/"],!0,!1),X=vt(":not(",!1),Y=vt(":matches(",!1),Z=vt(":has(",!1),tt=vt(":first-child",!1),et=vt(":last-child",!1),rt=vt(":nth-child(",!1),nt=vt(":nth-last-child(",!1),at=vt(":",!1),ot=vt("statement",!0),ut=vt("expression",!0),st=vt("declaration",!0),ct=vt("function",!0),it=vt("pattern",!0),lt=0,ft=[{line:1,column:1}],ht=0,pt=[],yt={};if("startRule"in r){if(!(r.startRule in c))throw new Error("Can't start parsing from rule \""+r.startRule+'".');i=c[r.startRule]}function vt(t,e){return{type:"literal",text:t,ignoreCase:e}}function dt(t,e,r){return{type:"class",parts:t,inverted:e,ignoreCase:r}}function At(t){var r,n=ft[t];if(n)return n;for(r=t-1;!ft[r];)r--;for(n={line:(n=ft[r]).line,column:n.column};r<t;)10===e.charCodeAt(r)?(n.line++,n.column=1):n.column++,r++;return ft[t]=n,n}function xt(t,e){var r=At(t),n=At(e);return{start:{offset:t,line:r.line,column:r.column},end:{offset:e,line:n.line,column:n.column}}}function gt(t){lt<ht||(lt>ht&&(ht=lt,pt=[]),pt.push(t))}function bt(){var t,e,r,n,a=30*lt+0,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,(e=mt())!==s&&(r=Ct())!==s&&mt()!==s?t=e=1===(n=r).length?n[0]:{type:"matches",selectors:n}:(lt=t,t=s),t===s&&(t=lt,(e=mt())!==s&&(e=void 0),t=e),yt[a]={nextPos:lt,result:t},t)}function mt(){var t,r,n=30*lt+1,a=yt[n];if(a)return lt=a.nextPos,a.result;for(t=[],32===e.charCodeAt(lt)?(r=" ",lt++):(r=s,gt(l));r!==s;)t.push(r),32===e.charCodeAt(lt)?(r=" ",lt++):(r=s,gt(l));return yt[n]={nextPos:lt,result:t},t}function Pt(){var t,r,n,a=30*lt+2,o=yt[a];if(o)return lt=o.nextPos,o.result;if(r=[],f.test(e.charAt(lt))?(n=e.charAt(lt),lt++):(n=s,gt(h)),n!==s)for(;n!==s;)r.push(n),f.test(e.charAt(lt))?(n=e.charAt(lt),lt++):(n=s,gt(h));else r=s;return r!==s&&(r=r.join("")),t=r,yt[a]={nextPos:lt,result:t},t}function wt(){var t,r,n,a=30*lt+3,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,(r=mt())!==s?(62===e.charCodeAt(lt)?(n=">",lt++):(n=s,gt(p)),n!==s&&mt()!==s?t=r="child":(lt=t,t=s)):(lt=t,t=s),t===s&&(t=lt,(r=mt())!==s?(126===e.charCodeAt(lt)?(n="~",lt++):(n=s,gt(y)),n!==s&&mt()!==s?t=r="sibling":(lt=t,t=s)):(lt=t,t=s),t===s&&(t=lt,(r=mt())!==s?(43===e.charCodeAt(lt)?(n="+",lt++):(n=s,gt(v)),n!==s&&mt()!==s?t=r="adjacent":(lt=t,t=s)):(lt=t,t=s),t===s&&(t=lt,32===e.charCodeAt(lt)?(r=" ",lt++):(r=s,gt(l)),r!==s&&(n=mt())!==s?t=r="descendant":(lt=t,t=s)))),yt[a]={nextPos:lt,result:t},t)}function Ct(){var t,r,n,a,o,u,c,i,l=30*lt+4,f=yt[l];if(f)return lt=f.nextPos,f.result;if(t=lt,(r=jt())!==s){for(n=[],a=lt,(o=mt())!==s?(44===e.charCodeAt(lt)?(u=",",lt++):(u=s,gt(d)),u!==s&&(c=mt())!==s&&(i=jt())!==s?a=o=[o,u,c,i]:(lt=a,a=s)):(lt=a,a=s);a!==s;)n.push(a),a=lt,(o=mt())!==s?(44===e.charCodeAt(lt)?(u=",",lt++):(u=s,gt(d)),u!==s&&(c=mt())!==s&&(i=jt())!==s?a=o=[o,u,c,i]:(lt=a,a=s)):(lt=a,a=s);n!==s?t=r=[r].concat(n.map((function(t){return t[3]}))):(lt=t,t=s)}else lt=t,t=s;return yt[l]={nextPos:lt,result:t},t}function jt(){var t,e,r,n,a,o,u,c=30*lt+5,i=yt[c];if(i)return lt=i.nextPos,i.result;if(t=lt,(e=St())!==s){for(r=[],n=lt,(a=wt())!==s&&(o=St())!==s?n=a=[a,o]:(lt=n,n=s);n!==s;)r.push(n),n=lt,(a=wt())!==s&&(o=St())!==s?n=a=[a,o]:(lt=n,n=s);r!==s?(u=e,t=e=r.reduce((function(t,e){return{type:e[0],left:t,right:e[1]}}),u)):(lt=t,t=s)}else lt=t,t=s;return yt[c]={nextPos:lt,result:t},t}function St(){var t,r,n,a,o,u,c,i=30*lt+6,l=yt[i];if(l)return lt=l.nextPos,l.result;if(t=lt,33===e.charCodeAt(lt)?(r="!",lt++):(r=s,gt(A)),r===s&&(r=null),r!==s){if(n=[],(a=Et())!==s)for(;a!==s;)n.push(a),a=Et();else n=s;n!==s?(o=r,c=1===(u=n).length?u[0]:{type:"compound",selectors:u},o&&(c.subject=!0),t=r=c):(lt=t,t=s)}else lt=t,t=s;return yt[i]={nextPos:lt,result:t},t}function Et(){var t,r=30*lt+7,n=yt[r];return n?(lt=n.nextPos,n.result):((t=function(){var t,r,n=30*lt+8,a=yt[n];return a?(lt=a.nextPos,a.result):(42===e.charCodeAt(lt)?(r="*",lt++):(r=s,gt(x)),r!==s&&(r={type:"wildcard",value:r}),t=r,yt[n]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a=30*lt+9,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,35===e.charCodeAt(lt)?(r="#",lt++):(r=s,gt(g)),r===s&&(r=null),r!==s&&(n=Pt())!==s?t=r={type:"identifier",value:n}:(lt=t,t=s),yt[a]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a,o=30*lt+10,u=yt[o];return u?(lt=u.nextPos,u.result):(t=lt,91===e.charCodeAt(lt)?(r="[",lt++):(r=s,gt(b)),r!==s&&mt()!==s&&(n=function(){var t,r,n,a,o=30*lt+14,u=yt[o];return u?(lt=u.nextPos,u.result):(t=lt,(r=It())!==s&&mt()!==s&&(n=function(){var t,r,n,a=30*lt+12,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,33===e.charCodeAt(lt)?(r="!",lt++):(r=s,gt(A)),r===s&&(r=null),r!==s?(61===e.charCodeAt(lt)?(n="=",lt++):(n=s,gt(C)),n!==s?(r=j(r),t=r):(lt=t,t=s)):(lt=t,t=s),yt[a]={nextPos:lt,result:t},t)}())!==s&&mt()!==s?((a=function(){var t,r,n,a,o,u=30*lt+18,c=yt[u];if(c)return lt=c.nextPos,c.result;if(t=lt,"type("===e.substr(lt,5)?(r="type(",lt+=5):(r=s,gt(H)),r!==s)if(mt()!==s){if(n=[],V.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt($)),a!==s)for(;a!==s;)n.push(a),V.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt($));else n=s;n!==s&&(a=mt())!==s?(41===e.charCodeAt(lt)?(o=")",lt++):(o=s,gt(z)),o!==s?(r={type:"type",value:n.join("")},t=r):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;else lt=t,t=s;return yt[u]={nextPos:lt,result:t},t}())===s&&(a=function(){var t,r,n,a,o,u,c=30*lt+20,i=yt[c];if(i)return lt=i.nextPos,i.result;if(t=lt,47===e.charCodeAt(lt)?(r="/",lt++):(r=s,gt(N)),r!==s){if(n=[],Q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(W)),a!==s)for(;a!==s;)n.push(a),Q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(W));else n=s;n!==s?(47===e.charCodeAt(lt)?(a="/",lt++):(a=s,gt(N)),a!==s?((o=function(){var t,r,n=30*lt+19,a=yt[n];if(a)return lt=a.nextPos,a.result;if(t=[],B.test(e.charAt(lt))?(r=e.charAt(lt),lt++):(r=s,gt(J)),r!==s)for(;r!==s;)t.push(r),B.test(e.charAt(lt))?(r=e.charAt(lt),lt++):(r=s,gt(J));else t=s;return yt[n]={nextPos:lt,result:t},t}())===s&&(o=null),o!==s?(u=o,r={type:"regexp",value:new RegExp(n.join(""),u?u.join(""):"")},t=r):(lt=t,t=s)):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;return yt[c]={nextPos:lt,result:t},t}()),a!==s?(r=k(r,n,a),t=r):(lt=t,t=s)):(lt=t,t=s),t===s&&(t=lt,(r=It())!==s&&mt()!==s&&(n=function(){var t,r,n,a=30*lt+11,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,P.test(e.charAt(lt))?(r=e.charAt(lt),lt++):(r=s,gt(w)),r===s&&(r=null),r!==s?(61===e.charCodeAt(lt)?(n="=",lt++):(n=s,gt(C)),n!==s?(r=j(r),t=r):(lt=t,t=s)):(lt=t,t=s),t===s&&(S.test(e.charAt(lt))?(t=e.charAt(lt),lt++):(t=s,gt(E))),yt[a]={nextPos:lt,result:t},t)}())!==s&&mt()!==s?((a=function(){var t,r,n,a,o,u,c=30*lt+15,i=yt[c];if(i)return lt=i.nextPos,i.result;if(t=lt,34===e.charCodeAt(lt)?(r='"',lt++):(r=s,gt(F)),r!==s){for(n=[],T.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(L)),a===s&&(a=lt,92===e.charCodeAt(lt)?(o="\\",lt++):(o=s,gt(O)),o!==s?(e.length>lt?(u=e.charAt(lt),lt++):(u=s,gt(D)),u!==s?(o=R(o,u),a=o):(lt=a,a=s)):(lt=a,a=s));a!==s;)n.push(a),T.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(L)),a===s&&(a=lt,92===e.charCodeAt(lt)?(o="\\",lt++):(o=s,gt(O)),o!==s?(e.length>lt?(u=e.charAt(lt),lt++):(u=s,gt(D)),u!==s?(o=R(o,u),a=o):(lt=a,a=s)):(lt=a,a=s));n!==s?(34===e.charCodeAt(lt)?(a='"',lt++):(a=s,gt(F)),a!==s?(r=K(n),t=r):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;if(t===s)if(t=lt,39===e.charCodeAt(lt)?(r="'",lt++):(r=s,gt(U)),r!==s){for(n=[],_.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(M)),a===s&&(a=lt,92===e.charCodeAt(lt)?(o="\\",lt++):(o=s,gt(O)),o!==s?(e.length>lt?(u=e.charAt(lt),lt++):(u=s,gt(D)),u!==s?(o=R(o,u),a=o):(lt=a,a=s)):(lt=a,a=s));a!==s;)n.push(a),_.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(M)),a===s&&(a=lt,92===e.charCodeAt(lt)?(o="\\",lt++):(o=s,gt(O)),o!==s?(e.length>lt?(u=e.charAt(lt),lt++):(u=s,gt(D)),u!==s?(o=R(o,u),a=o):(lt=a,a=s)):(lt=a,a=s));n!==s?(39===e.charCodeAt(lt)?(a="'",lt++):(a=s,gt(U)),a!==s?(r=K(n),t=r):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;return yt[c]={nextPos:lt,result:t},t}())===s&&(a=function(){var t,r,n,a,o,u,c,i=30*lt+16,l=yt[i];if(l)return lt=l.nextPos,l.result;for(t=lt,r=lt,n=[],q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G));a!==s;)n.push(a),q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G));if(n!==s?(46===e.charCodeAt(lt)?(a=".",lt++):(a=s,gt(I)),a!==s?r=n=[n,a]:(lt=r,r=s)):(lt=r,r=s),r===s&&(r=null),r!==s){if(n=[],q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G)),a!==s)for(;a!==s;)n.push(a),q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G));else n=s;n!==s?(u=n,c=(o=r)?[].concat.apply([],o).join(""):"",r={type:"literal",value:parseFloat(c+u.join(""))},t=r):(lt=t,t=s)}else lt=t,t=s;return yt[i]={nextPos:lt,result:t},t}())===s&&(a=function(){var t,e,r=30*lt+17,n=yt[r];return n?(lt=n.nextPos,n.result):((e=Pt())!==s&&(e={type:"literal",value:e}),t=e,yt[r]={nextPos:lt,result:t},t)}()),a!==s?(r=k(r,n,a),t=r):(lt=t,t=s)):(lt=t,t=s),t===s&&(t=lt,(r=It())!==s&&(r={type:"attribute",name:r}),t=r)),yt[o]={nextPos:lt,result:t},t)}())!==s&&mt()!==s?(93===e.charCodeAt(lt)?(a="]",lt++):(a=s,gt(m)),a!==s?t=r=n:(lt=t,t=s)):(lt=t,t=s),yt[o]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a,o,u,c,i,l=30*lt+21,f=yt[l];if(f)return lt=f.nextPos,f.result;if(t=lt,46===e.charCodeAt(lt)?(r=".",lt++):(r=s,gt(I)),r!==s)if((n=Pt())!==s){for(a=[],o=lt,46===e.charCodeAt(lt)?(u=".",lt++):(u=s,gt(I)),u!==s&&(c=Pt())!==s?o=u=[u,c]:(lt=o,o=s);o!==s;)a.push(o),o=lt,46===e.charCodeAt(lt)?(u=".",lt++):(u=s,gt(I)),u!==s&&(c=Pt())!==s?o=u=[u,c]:(lt=o,o=s);a!==s?(i=n,r={type:"field",name:a.reduce((function(t,e){return t+e[0]+e[1]}),i)},t=r):(lt=t,t=s)}else lt=t,t=s;else lt=t,t=s;return yt[l]={nextPos:lt,result:t},t}())===s&&(t=function(){var t,r,n,a,o=30*lt+22,u=yt[o];return u?(lt=u.nextPos,u.result):(t=lt,":not("===e.substr(lt,5)?(r=":not(",lt+=5):(r=s,gt(X)),r!==s&&mt()!==s&&(n=Ct())!==s&&mt()!==s?(41===e.charCodeAt(lt)?(a=")",lt++):(a=s,gt(z)),a!==s?t=r={type:"not",selectors:n}:(lt=t,t=s)):(lt=t,t=s),yt[o]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a,o=30*lt+23,u=yt[o];return u?(lt=u.nextPos,u.result):(t=lt,":matches("===e.substr(lt,9)?(r=":matches(",lt+=9):(r=s,gt(Y)),r!==s&&mt()!==s&&(n=Ct())!==s&&mt()!==s?(41===e.charCodeAt(lt)?(a=")",lt++):(a=s,gt(z)),a!==s?t=r={type:"matches",selectors:n}:(lt=t,t=s)):(lt=t,t=s),yt[o]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a,o=30*lt+24,u=yt[o];return u?(lt=u.nextPos,u.result):(t=lt,":has("===e.substr(lt,5)?(r=":has(",lt+=5):(r=s,gt(Z)),r!==s&&mt()!==s&&(n=Ct())!==s&&mt()!==s?(41===e.charCodeAt(lt)?(a=")",lt++):(a=s,gt(z)),a!==s?t=r={type:"has",selectors:n}:(lt=t,t=s)):(lt=t,t=s),yt[o]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n=30*lt+25,a=yt[n];return a?(lt=a.nextPos,a.result):(":first-child"===e.substr(lt,12)?(r=":first-child",lt+=12):(r=s,gt(tt)),r!==s&&(r=kt(1)),t=r,yt[n]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n=30*lt+26,a=yt[n];return a?(lt=a.nextPos,a.result):(":last-child"===e.substr(lt,11)?(r=":last-child",lt+=11):(r=s,gt(et)),r!==s&&(r=Ft(1)),t=r,yt[n]={nextPos:lt,result:t},t)}())===s&&(t=function(){var t,r,n,a,o,u=30*lt+27,c=yt[u];if(c)return lt=c.nextPos,c.result;if(t=lt,":nth-child("===e.substr(lt,11)?(r=":nth-child(",lt+=11):(r=s,gt(rt)),r!==s)if(mt()!==s){if(n=[],q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G)),a!==s)for(;a!==s;)n.push(a),q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G));else n=s;n!==s&&(a=mt())!==s?(41===e.charCodeAt(lt)?(o=")",lt++):(o=s,gt(z)),o!==s?(r=kt(parseInt(n.join(""),10)),t=r):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;else lt=t,t=s;return yt[u]={nextPos:lt,result:t},t}())===s&&(t=function(){var t,r,n,a,o,u=30*lt+28,c=yt[u];if(c)return lt=c.nextPos,c.result;if(t=lt,":nth-last-child("===e.substr(lt,16)?(r=":nth-last-child(",lt+=16):(r=s,gt(nt)),r!==s)if(mt()!==s){if(n=[],q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G)),a!==s)for(;a!==s;)n.push(a),q.test(e.charAt(lt))?(a=e.charAt(lt),lt++):(a=s,gt(G));else n=s;n!==s&&(a=mt())!==s?(41===e.charCodeAt(lt)?(o=")",lt++):(o=s,gt(z)),o!==s?(r=Ft(parseInt(n.join(""),10)),t=r):(lt=t,t=s)):(lt=t,t=s)}else lt=t,t=s;else lt=t,t=s;return yt[u]={nextPos:lt,result:t},t}())===s&&(t=function(){var t,r,n,a=30*lt+29,o=yt[a];return o?(lt=o.nextPos,o.result):(t=lt,58===e.charCodeAt(lt)?(r=":",lt++):(r=s,gt(at)),r!==s?("statement"===e.substr(lt,9).toLowerCase()?(n=e.substr(lt,9),lt+=9):(n=s,gt(ot)),n===s&&("expression"===e.substr(lt,10).toLowerCase()?(n=e.substr(lt,10),lt+=10):(n=s,gt(ut)),n===s&&("declaration"===e.substr(lt,11).toLowerCase()?(n=e.substr(lt,11),lt+=11):(n=s,gt(st)),n===s&&("function"===e.substr(lt,8).toLowerCase()?(n=e.substr(lt,8),lt+=8):(n=s,gt(ct)),n===s&&("pattern"===e.substr(lt,7).toLowerCase()?(n=e.substr(lt,7),lt+=7):(n=s,gt(it)))))),n!==s?t=r={type:"class",name:n}:(lt=t,t=s)):(lt=t,t=s),yt[a]={nextPos:lt,result:t},t)}()),yt[r]={nextPos:lt,result:t},t)}function It(){var t,r,n,a,o,u,c,i,l=30*lt+13,f=yt[l];if(f)return lt=f.nextPos,f.result;if(t=lt,(r=Pt())!==s){for(n=[],a=lt,46===e.charCodeAt(lt)?(o=".",lt++):(o=s,gt(I)),o!==s&&(u=Pt())!==s?a=o=[o,u]:(lt=a,a=s);a!==s;)n.push(a),a=lt,46===e.charCodeAt(lt)?(o=".",lt++):(o=s,gt(I)),o!==s&&(u=Pt())!==s?a=o=[o,u]:(lt=a,a=s);n!==s?(c=r,i=n,t=r=[].concat.apply([c],i).join("")):(lt=t,t=s)}else lt=t,t=s;return yt[l]={nextPos:lt,result:t},t}function kt(t){return{type:"nth-child",index:{type:"literal",value:t}}}function Ft(t){return{type:"nth-last-child",index:{type:"literal",value:t}}}if((n=i())!==s&&lt===e.length)return n;throw n!==s&&lt<e.length&&gt({type:"end"}),a=pt,o=ht<e.length?e.charAt(ht):null,u=ht<e.length?xt(ht,ht+1):xt(ht,ht),new t(t.buildMessage(a,o),a,o,u)}}}())}));function c(r,n,a,o){if(!n)return!0;if(!r)return!1;switch(a||(a=[]),n.type){case"wildcard":return!0;case"identifier":return n.value.toLowerCase()===r.type.toLowerCase();case"field":var s=n.name.split("."),i=a[s.length-1];return function t(e,r,n){if(0===n.length)return e===r;if(null==r)return!1;var a=r[n[0]],o=n.slice(1);if(Array.isArray(a)){var s,c=u(a);try{for(c.s();!(s=c.n()).done;){if(t(e,s.value,o))return!0}}catch(t){c.e(t)}finally{c.f()}return!1}return t(e,a,o)}(r,i,s);case"matches":var l,y=u(n.selectors);try{for(y.s();!(l=y.n()).done;){var v=l.value;if(c(r,v,a,o))return!0}}catch(t){y.e(t)}finally{y.f()}return!1;case"compound":var d,A=u(n.selectors);try{for(A.s();!(d=A.n()).done;){var x=d.value;if(!c(r,x,a,o))return!1}}catch(t){A.e(t)}finally{A.f()}return!0;case"not":var g,b=u(n.selectors);try{for(b.s();!(g=b.n()).done;){var m=g.value;if(c(r,m,a,o))return!1}}catch(t){b.e(t)}finally{b.f()}return!0;case"has":var P=function(){var e,a=[],s=u(n.selectors);try{var i=function(){var n=e.value,u=[];t.traverse(r,{enter:function(t,e){null!=e&&u.unshift(e),c(t,n,u,o)&&a.push(t)},leave:function(){u.shift()},keys:o&&o.visitorKeys,fallback:o&&o.fallback||"iteration"})};for(s.s();!(e=s.n()).done;)i()}catch(t){s.e(t)}finally{s.f()}return{v:0!==a.length}}();if("object"===e(P))return P.v;case"child":return!!c(r,n.right,a,o)&&c(a[0],n.left,a.slice(1),o);case"descendant":if(c(r,n.right,a,o))for(var w=0,C=a.length;w<C;++w)if(c(a[w],n.left,a.slice(w+1),o))return!0;return!1;case"attribute":var j=function(t,e){var r,n=u(e.split("."));try{for(n.s();!(r=n.n()).done;){var a=r.value;if(null==t)return t;t=t[a]}}catch(t){n.e(t)}finally{n.f()}return t}(r,n.name);switch(n.operator){case void 0:return null!=j;case"=":switch(n.value.type){case"regexp":return"string"==typeof j&&n.value.value.test(j);case"literal":return"".concat(n.value.value)==="".concat(j);case"type":return n.value.value===e(j)}throw new Error("Unknown selector value type: ".concat(n.value.type));case"!=":switch(n.value.type){case"regexp":return!n.value.value.test(j);case"literal":return"".concat(n.value.value)!=="".concat(j);case"type":return n.value.value!==e(j)}throw new Error("Unknown selector value type: ".concat(n.value.type));case"<=":return j<=n.value.value;case"<":return j<n.value.value;case">":return j>n.value.value;case">=":return j>=n.value.value}throw new Error("Unknown operator: ".concat(n.operator));case"sibling":return c(r,n.right,a,o)&&f(r,n.left,a,"LEFT_SIDE",o)||n.left.subject&&c(r,n.left,a,o)&&f(r,n.right,a,"RIGHT_SIDE",o);case"adjacent":return c(r,n.right,a,o)&&h(r,n.left,a,"LEFT_SIDE",o)||n.right.subject&&c(r,n.left,a,o)&&h(r,n.right,a,"RIGHT_SIDE",o);case"nth-child":return c(r,n.right,a,o)&&p(r,a,(function(){return n.index.value-1}),o);case"nth-last-child":return c(r,n.right,a,o)&&p(r,a,(function(t){return t-n.index.value}),o);case"class":switch(n.name.toLowerCase()){case"statement":if("Statement"===r.type.slice(-9))return!0;case"declaration":return"Declaration"===r.type.slice(-11);case"pattern":if("Pattern"===r.type.slice(-7))return!0;case"expression":return"Expression"===r.type.slice(-10)||"Literal"===r.type.slice(-7)||"Identifier"===r.type&&(0===a.length||"MetaProperty"!==a[0].type)||"MetaProperty"===r.type;case"function":return"FunctionDeclaration"===r.type||"FunctionExpression"===r.type||"ArrowFunctionExpression"===r.type}throw new Error("Unknown class name: ".concat(n.name))}throw new Error("Unknown selector type: ".concat(n.type))}function i(e,r){var n=e.type;return r&&r.visitorKeys&&r.visitorKeys[n]?r.visitorKeys[n]:t.VisitorKeys[n]?t.VisitorKeys[n]:r&&"function"==typeof r.fallback?r.fallback(e):Object.keys(e).filter((function(t){return"type"!==t}))}function l(t){return null!==t&&"object"===e(t)&&"string"==typeof t.type}function f(t,e,n,a,o){var s=r(n,1)[0];if(!s)return!1;var f,h=u(i(s,o));try{for(h.s();!(f=h.n()).done;){var p=s[f.value];if(Array.isArray(p)){var y=p.indexOf(t);if(y<0)continue;var v=void 0,d=void 0;"LEFT_SIDE"===a?(v=0,d=y):(v=y+1,d=p.length);for(var A=v;A<d;++A)if(l(p[A])&&c(p[A],e,n,o))return!0}}}catch(t){h.e(t)}finally{h.f()}return!1}function h(t,e,n,a,o){var s=r(n,1)[0];if(!s)return!1;var f,h=u(i(s,o));try{for(h.s();!(f=h.n()).done;){var p=s[f.value];if(Array.isArray(p)){var y=p.indexOf(t);if(y<0)continue;if("LEFT_SIDE"===a&&y>0&&l(p[y-1])&&c(p[y-1],e,n,o))return!0;if("RIGHT_SIDE"===a&&y<p.length-1&&l(p[y+1])&&c(p[y+1],e,n,o))return!0}}}catch(t){h.e(t)}finally{h.f()}return!1}function p(t,e,n,a){var o=r(e,1)[0];if(!o)return!1;var s,c=u(i(o,a));try{for(c.s();!(s=c.n()).done;){var l=o[s.value];if(Array.isArray(l)){var f=l.indexOf(t);if(f>=0&&f===n(l.length))return!0}}}catch(t){c.e(t)}finally{c.f()}return!1}function y(t,a){if(null==t||"object"!=e(t))return[];null==a&&(a=t);for(var o=t.subject?[a]:[],u=0,s=function(t){for(var e=[],r=Object.keys(t),n=0;n<r.length;n++)e.push([r[n],t[r[n]]]);return e}(t);u<s.length;u++){var c=r(s[u],2),i=c[0],l=c[1];o.push.apply(o,n(y(l,"left"===i?l:a)))}return o}function v(e,r,n,a){if(r){var o=[],u=y(r);t.traverse(e,{enter:function(t,e){if(null!=e&&o.unshift(e),c(t,r,o,a))if(u.length)for(var s=0,i=u.length;s<i;++s){c(t,u[s],o,a)&&n(t,e,o);for(var l=0,f=o.length;l<f;++l){var h=o.slice(l+1);c(o[l],u[s],h,a)&&n(o[l],e,h)}}else n(t,e,o)},leave:function(){o.shift()},keys:a&&a.visitorKeys,fallback:a&&a.fallback||"iteration"})}}function d(t,e,r){var n=[];return v(t,e,(function(t){n.push(t)}),r),n}function A(t){return s.parse(t)}function x(t,e,r){return d(t,A(e),r)}return x.parse=A,x.match=d,x.traverse=v,x.matches=c,x.query=x,x}));
//# sourceMappingURL=esquery.lite.min.js.map
